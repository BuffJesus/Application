// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: FableMod.Gfx.Integration, Version=1.0.4918.443, Culture=neutral, PublicKeyToken=null
// MVID: 11191760-BFE8-4917-AB7A-ED7AB3A5A394
// Assembly location: C:\Users\Cornelio\Desktop\Chocolate Box\FableMod.Gfx.Integration.dll

using \u003CCppImplementationDetails\u003E;
using \u003CCrtImplementationDetails\u003E;
using FableMod;
using FableMod.Data;
using FableMod.Gfx;
using FableMod.Gfx.Integration;
using std;
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Threading;

#nullable disable
internal class \u003CModule\u003E
{
  internal static \u0024_TypeDescriptor\u0024_extraBytes_58 \u003F\u003F_R0\u003FAV\u003F\u0024SmartPointer\u0040VTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024SmartPointer\u0040VTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024SmartPointer\u0040VTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024SmartPointer\u0040VTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4\u003F\u0024SmartPointer\u0040VTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024SmartPointer\u0040VTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  public static __FnPtr<int (AllocateHierarchy*, sbyte*, _D3DXFRAME**)> __m2mep\u0040\u003FCreateFrame\u0040AllocateHierarchy\u0040Integration\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAJPEBDPEAPEAU_D3DXFRAME\u0040\u0040\u0040Z;
  public static __FnPtr<int (AllocateHierarchy*, sbyte*, _D3DXMESHDATA*, _D3DXMATERIAL*, _D3DXEFFECTINSTANCE*, uint, uint*, ID3DXSkinInfo*, _D3DXMESHCONTAINER**)> __m2mep\u0040\u003FCreateMeshContainer\u0040AllocateHierarchy\u0040Integration\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAJPEBDPEBU_D3DXMESHDATA\u0040\u0040PEBU_D3DXMATERIAL\u0040\u0040PEBU_D3DXEFFECTINSTANCE\u0040\u0040KPEBKPEAUID3DXSkinInfo\u0040\u0040PEAPEAU_D3DXMESHCONTAINER\u0040\u0040\u0040Z;
  public static __FnPtr<int (AllocateHierarchy*, _D3DXFRAME*)> __m2mep\u0040\u003FDestroyFrame\u0040AllocateHierarchy\u0040Integration\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAJPEAU_D3DXFRAME\u0040\u0040\u0040Z;
  public static __FnPtr<int (AllocateHierarchy*, _D3DXMESHCONTAINER*)> __m2mep\u0040\u003FDestroyMeshContainer\u0040AllocateHierarchy\u0040Integration\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAJPEAU_D3DXMESHCONTAINER\u0040\u0040\u0040Z;
  public static __FnPtr<void* (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E*, uint)> __m2mep\u0040\u003F\u003F_E\u003F\u0024SmartPointer\u0040VTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BD\u0040GNOHACJB\u0040BONE_OFFSET_MATRIX\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05DHHFPMJA\u0040HDMY_\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040POPMPNFF\u0040NAME_NOT_FOUND\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05LIHIPBGP\u0040HPNT_\u003F\u0024AA\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024SmartPointer\u0040VD3DXModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024SmartPointer\u0040VNode\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024SmartPointer\u0040VD3DXModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024SmartPointer\u0040VNode\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024SmartPointer\u0040VD3DXModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_60 \u003F\u003F_R0\u003FAV\u003F\u0024SmartPointer\u0040VD3DXModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024SmartPointer\u0040VNode\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_55 \u003F\u003F_R0\u003FAV\u003F\u0024SmartPointer\u0040VNode\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4\u003F\u0024SmartPointer\u0040VD3DXModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4\u003F\u0024SmartPointer\u0040VNode\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024SmartPointer\u0040VD3DXModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024SmartPointer\u0040VNode\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_55 \u003F\u003F_R0\u003FAV\u003F\u0024SmartPointer\u0040VMesh\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024SmartPointer\u0040VMesh\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024SmartPointer\u0040VMesh\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024SmartPointer\u0040VMesh\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4\u003F\u0024SmartPointer\u0040VMesh\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024SmartPointer\u0040VMesh\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  public static __FnPtr<void* (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E*, uint)> __m2mep\u0040\u003F\u003F_E\u003F\u0024SmartPointer\u0040VNode\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void* (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AD3DXModel\u003E*, uint)> __m2mep\u0040\u003F\u003F_E\u003F\u0024SmartPointer\u0040VD3DXModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void* (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E*, uint)> __m2mep\u0040\u003F\u003F_E\u003F\u0024SmartPointer\u0040VMesh\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17GFFKFGK\u0040\u003F\u0024AAU\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003F\u003F_C\u0040_1BA\u0040GOGLBMBE\u0040\u003F\u0024AAO\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAT\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1DG\u0040KEJLMGJG\u0040\u003F\u0024AAG\u003F\u0024AAf\u003F\u0024AAx\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA_\u003F\u0024AAR\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AA_\u003F\u0024AAO\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAT\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CG\u0040DGKMFBFC\u0040\u003F\u0024AAG\u003F\u0024AAf\u003F\u0024AAx\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA_\u003F\u0024AAR\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_29 \u003F\u003F_R0\u003FAVException\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040GLANBBEC\u0040Scene\u003F5Root\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040CAOGKCDA\u0040Orphan_Helpers\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040HODBKJBP\u0040Movement_dummy\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003F\u003F_C\u0040_08IMCBCIPL\u0040Movement\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0O\u0040PFDLJPFL\u0040Bow_bone_main\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09FLFDMKOE\u0040root_bone\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040GFPCKMMN\u0040Main_Root_Bone\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07MGCPDNLD\u0040DEFAULT\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BD\u0040OLBABOEK\u0040vector\u003F\u0024DMT\u003F\u0024DO\u003F5too\u003F5long\u003F\u0024AA\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2AllocateHierarchy\u0040Integration\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2ID3DXAllocateHierarchy\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040AllocateHierarchy\u0040Integration\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040ID3DXAllocateHierarchy\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3AllocateHierarchy\u0040Integration\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_49 \u003F\u003F_R0\u003FAVAllocateHierarchy\u0040Integration\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3ID3DXAllocateHierarchy\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_29 \u003F\u003F_R0\u003FAUID3DXAllocateHierarchy\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4AllocateHierarchy\u0040Integration\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_16 _CTA2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408\u003F\u003F0exception\u0040std\u0040\u0040\u0024\u0024FQEAA\u0040AEBV01\u0040\u0040Z24;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408\u003F\u003F0bad_alloc\u0040std\u0040\u0040\u0024\u0024FQEAA\u0040AEBV01\u0040\u0040Z24;
  internal static _s__ThrowInfo _TI2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040bad_alloc\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2exception\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3exception\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040exception\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7AllocateHierarchy\u0040Integration\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  public static __FnPtr<bad_alloc* (bad_alloc*, bad_alloc*)> __m2mep\u0040\u003F\u003F0bad_alloc\u0040std\u0040\u0040\u0024\u0024FQEAA\u0040AEBV01\u0040\u0040Z;
  public static __FnPtr<void (bad_alloc*)> __m2mep\u0040\u003F\u003F1bad_alloc\u0040std\u0040\u0040\u0024\u0024FUEAA\u0040XZ;
  public static __FnPtr<void* (bad_alloc*, uint)> __m2mep\u0040\u003F\u003F_Ebad_alloc\u0040std\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04HKMFGHFA\u00403DRT\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04DFMHHGNM\u0040MTLS\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04IMHECKIP\u0040SUBM\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07PLGIHJEC\u0040HCVL_\u003F\u0024CFs\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04KEIKGGPK\u0040TRFM\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04FKFGIHAH\u0040PRIM\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04HLJHBOBI\u0040TRIS\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04JDKLPIAI\u0040VERT\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CE\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CE\u0040BFKMGDCD\u0040Copyright\u003F5Big\u003F5Blue\u003F5Box\u003F5Studios\u003F5L\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0N\u0040GMGNLDOE\u0040Material\u003F5\u003F\u0024CD24\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04CBEPCLMK\u0040UNIV\u003F\u0024AA\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAVMesh\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_27 \u003F\u003F_R0\u003FAVSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAVNode\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_58 \u003F\u003F_R0\u003FAV\u003F\u0024SmartPointer\u0040VSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024SmartPointer\u0040VSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024SmartPointer\u0040VSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024SmartPointer\u0040VSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4\u003F\u0024SmartPointer\u0040VSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024SmartPointer\u0040VSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CE\u0040FALCKKJ\u0040\u003F\u0024AAG\u003F\u0024AAf\u003F\u0024AAx\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AAV\u003F\u0024AAi\u003F\u0024AAe\u003F\u0024AAw\u003F\u0024AA_\u003F\u0024AAA\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CE\u0040GEHKGPEF\u0040\u003F\u0024AAF\u003F\u0024AAi\u003F\u0024AAr\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAP\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAs\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AA\u003F5\u003F\u0024AAM\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CK\u0040DGILGNGD\u0040\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAo\u003F\u0024AAb\u003F\u0024AAj\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAs\u003F\u0024AA\u003F3\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAu\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024SmartPointer\u0040VArrowheadModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024SmartPointer\u0040VArrowheadModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024SmartPointer\u0040VArrowheadModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_65 \u003F\u003F_R0\u003FAV\u003F\u0024SmartPointer\u0040VArrowheadModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4\u003F\u0024SmartPointer\u0040VArrowheadModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024SmartPointer\u0040VArrowheadModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_27 \u003F\u003F_R0\u003FAVTerrain\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static uint \u003FA0x98271962\u002E\u003FCOLORZ\u0040\u003F1\u003F\u003FDrawAxes\u0040GfxThingView\u0040Integration\u0040Gfx\u0040FableMod\u0040\u0040IE\u0024AAMXXZ\u00404KB;
  internal static uint \u003FA0x98271962\u002E\u003FCOLORY\u0040\u003F1\u003F\u003FDrawAxes\u0040GfxThingView\u0040Integration\u0040Gfx\u0040FableMod\u0040\u0040IE\u0024AAMXXZ\u00404KB;
  internal static uint \u003FA0x98271962\u002E\u003FCOLORX\u0040\u003F1\u003F\u003FDrawAxes\u0040GfxThingView\u0040Integration\u0040Gfx\u0040FableMod\u0040\u0040IE\u0024AAMXXZ\u00404KB;
  public static __FnPtr<void* (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E*, uint)> __m2mep\u0040\u003F\u003F_E\u003F\u0024SmartPointer\u0040VArrowheadModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003F\u003F_C\u0040_1BA\u0040MKDGPOGN\u0040\u003F\u0024AAS\u003F\u0024AAp\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003F\u003F_C\u0040_1BA\u0040NFNMOFEE\u0040\u003F\u0024AAT\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0LA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BGA\u0040EAHBCOAN\u0040\u003F\u0024AAD\u003F\u0024AA3\u003F\u0024AAD\u003F\u0024AAX\u003F\u0024AAC\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAS\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAf\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F\u0024CI\u003F\u0024AA\u003F5\u003F\u0024AAM\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAa\u003F\u0024AAg\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003F\u003F_C\u0040_1BA\u0040GOAFNGME\u0040\u003F\u0024AAM\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAp\u003F\u0024AAp\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CM\u0040OKAGFLBM\u0040\u003F\u0024AA\u003F\u0024CI\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA\u003F3\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAd\u003F\u0024AA\u003F\u0024CJ\u003F\u0024AA\u003F3\u003F\u0024AA\u003F5\u003F\u0024AAD\u003F\u0024AAX\u003F\u0024AAE\u003F\u0024AAR\u003F\u0024AAR\u003F\u0024AA\u003F3\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CC\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA\u003F\u0024CC\u003F\u0024AA\u003F6\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CE\u0040PFCJEMGN\u0040\u003F\u0024AAG\u003F\u0024AAF\u003F\u0024AAX\u003F\u0024AA_\u003F\u0024AAD\u003F\u0024AA3\u003F\u0024AAD\u003F\u0024AA_\u003F\u0024AAE\u003F\u0024AAX\u003F\u0024AAC\u003F\u0024AAE\u003F\u0024AAP\u003F\u0024AAT\u003F\u0024AAI\u003F\u0024AAO\u003F\u0024AAN\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1IE\u0040KMKKAJAB\u0040\u003F\u0024AAD\u003F\u0024AA3\u003F\u0024AAD\u003F\u0024AAX\u003F\u0024AAC\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAS\u003F\u0024AAp\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F\u0024CI\u003F\u0024AA\u003F5\u003F\u0024AAM\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F3\u003F\u0024AA\u003F3\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAD\u003F\u0024AAe\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DK\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1HE\u0040PHDMMFAC\u0040\u003F\u0024AAs\u003F\u0024AAp\u003F\u0024AAT\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AA\u003F9\u003F\u0024AA\u003F\u0024DO\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAD\u003F\u0024AA3\u003F\u0024AAD\u003F\u0024AAT\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AA\u003F\u0024CI\u003F\u0024AA\u003F\u0024CJ\u003F\u0024AA\u003F9\u003F\u0024AA\u003F\u0024DO\u003F\u0024AAG\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAS\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1GE\u0040DLMGDEEJ\u0040\u003F\u0024AAp\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAS\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAf\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F9\u003F\u0024AA\u003F\u0024DO\u003F\u0024AAB\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAS\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AA\u003F\u0024CI\u003F\u0024AAp\u003F\u0024AAS\u003F\u0024AAu\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CG\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EM\u0040HGKLLBBD\u0040\u003F\u0024AAp\u003F\u0024AAS\u003F\u0024AAp\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F9\u003F\u0024AA\u003F\u0024DO\u003F\u0024AAB\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AA\u003F\u0024CI\u003F\u0024AAD\u003F\u0024AA3\u003F\u0024AAD\u003F\u0024AAX\u003F\u0024AAS\u003F\u0024AAP\u003F\u0024AAR\u003F\u0024AAI\u003F\u0024AAT\u003F\u0024AAE\u003F\u0024AA_\u003F\u0024AAA\u003F\u0024AAL\u003F\u0024AAP\u003F\u0024AAH\u003F\u0024AAA\u003F\u0024AAB\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BO\u0040IIOBCGCK\u0040\u003F\u0024AAp\u003F\u0024AAS\u003F\u0024AAp\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F9\u003F\u0024AA\u003F\u0024DO\u003F\u0024AAE\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AA\u003F\u0024CI\u003F\u0024AA\u003F\u0024CJ\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CP\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FO\u0040DFCDCANC\u0040\u003F\u0024AAp\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAS\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAf\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F9\u003F\u0024AA\u003F\u0024DO\u003F\u0024AAE\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAS\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AA\u003F\u0024CI\u003F\u0024AAD\u003F\u0024AA3\u003F\u0024AAD\u003F\u0024AAX\u003F\u0024AA_\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024SmartPointer\u0040VTerrain\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2Exception\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024SmartPointer\u0040VTerrain\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040Exception\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024SmartPointer\u0040VTerrain\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_58 \u003F\u003F_R0\u003FAV\u003F\u0024SmartPointer\u0040VTerrain\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3Exception\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4\u003F\u0024SmartPointer\u0040VTerrain\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4Exception\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024SmartPointer\u0040VTerrain\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7Exception\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_8 _CTA1\u003FAVException\u0040Gfx\u0040FableMod\u0040\u0040;
  internal static _s__ThrowInfo _TI1\u003FAVException\u0040Gfx\u0040FableMod\u0040\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_66 \u003F\u003F_R0\u003FAV\u003F\u0024SmartPointer\u0040VEditableTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024SmartPointer\u0040VEditableTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024SmartPointer\u0040VEditableTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024SmartPointer\u0040VEditableTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4\u003F\u0024SmartPointer\u0040VEditableTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024SmartPointer\u0040VEditableTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
  public static __FnPtr<void* (FableMod.Gfx.Exception*, uint)> __m2mep\u0040\u003F\u003F_EException\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void* (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATerrain\u003E*, uint)> __m2mep\u0040\u003F\u003F_E\u003F\u0024SmartPointer\u0040VTerrain\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void* (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AEditableTexture\u003E*, uint)> __m2mep\u0040\u003F\u003F_E\u003F\u0024SmartPointer\u0040VEditableTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  internal static int __\u0040\u0040_PchSym_\u004000\u0040UuzyovnlwUhixUuzyovnlwOtucOrmgvtizgrlmUcGEUivovzhvUhgwzucOlyq\u0040;
  internal static __s_GUID _GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02;
  internal static __s_GUID _GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x54b01a5b\u002E__xc_mp_z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x54b01a5b\u002E__xi_vt_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x54b01a5b\u002E\u003FInitializedVtables\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  [FixedAddressValueType]
  internal static bool \u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA;
  internal static __FnPtr<void ()> \u003FA0x54b01a5b\u002E\u003FIsDefaultDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x54b01a5b\u002E__xc_ma_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x54b01a5b\u002E\u003FInitializedPerAppDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x54b01a5b\u002E__xc_ma_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x54b01a5b\u002E\u003FInitializedNative\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  internal static __s_GUID _GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x54b01a5b\u002E__xi_vt_z;
  [FixedAddressValueType]
  internal static int \u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x54b01a5b\u002E\u003FUninitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  [FixedAddressValueType]
  internal static int \u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x54b01a5b\u002E\u003FInitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  internal static bool \u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static bool \u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static int \u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA;
  internal static TriBool.State \u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static TriBool.State \u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static bool \u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x54b01a5b\u002E__xc_mp_a;
  internal static __s_GUID _GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02;
  internal static __FnPtr<void ()> \u003FA0x54b01a5b\u002E\u003FInitializedPerProcess\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  public static __FnPtr<int (void*)> __m2mep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z;
  public static __FnPtr<int (void*)> __m2mep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z;
  public static unsafe int** __unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z;
  [FixedAddressValueType]
  internal static ulong __exit_list_size_app_domain;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitbegin_app_domain;
  internal static ulong \u003FA0x60cd967c\u002E__exit_list_size;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitend_app_domain;
  internal static unsafe __FnPtr<void ()>* \u003FA0x60cd967c\u002E__onexitbegin_m;
  internal static unsafe __FnPtr<void ()>* \u003FA0x60cd967c\u002E__onexitend_m;
  [FixedAddressValueType]
  internal static int \u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  [FixedAddressValueType]
  internal static unsafe void* \u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7type_info\u0040\u00406B\u0040;
  internal static unsafe Device* \u003Fm_pDevice\u0040Manager\u0040Gfx\u0040FableMod\u0040\u00401PEAVDevice\u004023\u0040EA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_z;
  internal static volatile uint __native_vcclrit_reason;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_a;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_a;
  internal static volatile __enative_startup_state __native_startup_state;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_z;
  internal static volatile unsafe void* __native_startup_lock;
  internal static volatile uint __native_dllmain_reason;

  internal static unsafe D3DXEXTENDEDFRAME* FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002E\u007Bctor\u007D(
    [In] D3DXEXTENDEDFRAME* obj0)
  {
    SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E* fableModGfxTexturePtr1 = (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E*) ((IntPtr) obj0 + 104L);
    *(long*) fableModGfxTexturePtr1 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    *(long*) ((IntPtr) fableModGfxTexturePtr1 + 8L) = 0L;
    // ISSUE: fault handler
    try
    {
      SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E* fableModGfxTexturePtr2 = (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E*) ((IntPtr) obj0 + 120L);
      *(long*) fableModGfxTexturePtr2 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
      *(long*) ((IntPtr) fableModGfxTexturePtr2 + 8L) = 0L;
      // ISSUE: fault handler
      try
      {
        SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E* fableModGfxTexturePtr3 = (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E*) ((IntPtr) obj0 + 136L);
        *(long*) fableModGfxTexturePtr3 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
        *(long*) ((IntPtr) fableModGfxTexturePtr3 + 8L) = 0L;
        // ISSUE: fault handler
        try
        {
          // ISSUE: initblk instruction
          __memset((IntPtr) obj0, 0, 168);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 136L));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 120L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 104L));
    }
    return obj0;
  }

  internal static unsafe int FableMod\u002EGfx\u002EIntegration\u002EAllocateHierarchy\u002ECreateFrame(
    [In] AllocateHierarchy* obj0,
    sbyte* Name,
    _D3DXFRAME** ppNewFrame)
  {
    *(long*) ppNewFrame = 0L;
    D3DXEXTENDEDFRAME* d3DxextendedframePtr1 = (D3DXEXTENDEDFRAME*) \u003CModule\u003E.@new(168UL);
    D3DXEXTENDEDFRAME* d3DxextendedframePtr2;
    // ISSUE: fault handler
    try
    {
      d3DxextendedframePtr2 = (IntPtr) d3DxextendedframePtr1 == IntPtr.Zero ? (D3DXEXTENDEDFRAME*) 0L : \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002E\u007Bctor\u007D(d3DxextendedframePtr1);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) d3DxextendedframePtr1);
    }
    sbyte* numPtr1 = Name;
    if (*Name != (sbyte) 0)
    {
      do
      {
        ++numPtr1;
      }
      while (*numPtr1 != (sbyte) 0);
    }
    void* voidPtr1 = \u003CModule\u003E.new\u005B\u005D((ulong) ((IntPtr) numPtr1 - (IntPtr) Name + 1L));
    *(long*) d3DxextendedframePtr2 = (long) voidPtr1;
    sbyte* numPtr2 = Name;
    void* voidPtr2 = voidPtr1;
    sbyte num;
    do
    {
      num = *numPtr2;
      *(sbyte*) voidPtr2 = num;
      ++numPtr2;
      ++voidPtr2;
    }
    while (num != (sbyte) 0);
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 56L) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 52L) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 48L /*0x30*/) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 44L) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 36L) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 32L /*0x20*/) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 28L) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 24L) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 16L /*0x10*/) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 12L) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 8L) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 4L) = 0.0f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 60L) = 1f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 40L) = 1f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L + 20L) = 1f;
    *(float*) ((IntPtr) d3DxextendedframePtr2 + 8L) = 1f;
    *(long*) ppNewFrame = (long) d3DxextendedframePtr2;
    return 0;
  }

  internal static unsafe int FableMod\u002EGfx\u002EIntegration\u002EAllocateHierarchy\u002ECreateMeshContainer(
    [In] AllocateHierarchy* obj0,
    sbyte* Name,
    _D3DXMESHDATA* pMeshData,
    _D3DXMATERIAL* pMaterials,
    _D3DXEFFECTINSTANCE* pEffectInstances,
    uint NumMaterials,
    uint* pAdjacency,
    ID3DXSkinInfo* pSkinInfo,
    _D3DXMESHCONTAINER** ppNewMeshContainer)
  {
    _D3DXMESHCONTAINER* d3DxmeshcontainerPtr1 = (_D3DXMESHCONTAINER*) \u003CModule\u003E.@new(72UL);
    // ISSUE: initblk instruction
    __memset((IntPtr) d3DxmeshcontainerPtr1, 0, 72);
    *(long*) ppNewMeshContainer = 0L;
    sbyte* numPtr1 = Name;
    if (*Name != (sbyte) 0)
    {
      do
      {
        ++numPtr1;
      }
      while (*numPtr1 != (sbyte) 0);
    }
    void* voidPtr1 = \u003CModule\u003E.new\u005B\u005D((ulong) ((IntPtr) numPtr1 - (IntPtr) Name + 1L));
    *(long*) d3DxmeshcontainerPtr1 = (long) voidPtr1;
    sbyte* numPtr2 = Name;
    void* voidPtr2 = voidPtr1;
    sbyte num1;
    do
    {
      num1 = *numPtr2;
      *(sbyte*) voidPtr2 = num1;
      ++numPtr2;
      ++voidPtr2;
    }
    while (num1 != (sbyte) 0);
    if (*(int*) pMeshData != 1)
    {
      AllocateHierarchy* allocateHierarchyPtr = obj0;
      _D3DXMESHCONTAINER* d3DxmeshcontainerPtr2 = d3DxmeshcontainerPtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, _D3DXMESHCONTAINER*)>) *(long*) (*(long*) obj0 + 24L))((IntPtr) allocateHierarchyPtr, d3DxmeshcontainerPtr2);
      return -2147467259 /*0x80004005*/;
    }
    *(int*) ((IntPtr) d3DxmeshcontainerPtr1 + 8L) = 1;
    IDirect3DDevice9* idirect3Ddevice9Ptr1 = (IDirect3DDevice9*) 0L;
    long num3 = *(long*) ((IntPtr) pMeshData + 8L);
    long num4 = num3;
    ref IDirect3DDevice9* local1 = ref idirect3Ddevice9Ptr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = __calli((__FnPtr<int (IntPtr, IDirect3DDevice9**)>) *(long*) (*(long*) num3 + 80L /*0x50*/))((IntPtr) num4, (IDirect3DDevice9**) ref local1);
    long num6 = *(long*) ((IntPtr) pMeshData + 8L);
    long num7 = num6;
    \u0024ArrayType\u0024\u0024\u0024BY0EB\u0040U_D3DVERTEXELEMENT9\u0040\u0040 d3DvertexelemenT9;
    ref \u0024ArrayType\u0024\u0024\u0024BY0EB\u0040U_D3DVERTEXELEMENT9\u0040\u0040 local2 = ref d3DvertexelemenT9;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (__calli((__FnPtr<int (IntPtr, _D3DVERTEXELEMENT9*)>) *(long*) (*(long*) num6 + 56L))((IntPtr) num7, (_D3DVERTEXELEMENT9*) ref local2) < 0)
    {
      AllocateHierarchy* allocateHierarchyPtr = obj0;
      _D3DXMESHCONTAINER* d3DxmeshcontainerPtr3 = d3DxmeshcontainerPtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num8 = __calli((__FnPtr<int (IntPtr, _D3DXMESHCONTAINER*)>) *(long*) (*(long*) obj0 + 24L))((IntPtr) allocateHierarchyPtr, d3DxmeshcontainerPtr3);
      return -2147467259 /*0x80004005*/;
    }
    long num9 = *(long*) ((IntPtr) pMeshData + 8L);
    long num10 = num9;
    IDirect3DDevice9* idirect3Ddevice9Ptr2 = idirect3Ddevice9Ptr1;
    IntPtr num11 = (IntPtr) d3DxmeshcontainerPtr1 + 16L /*0x10*/;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num12 = __calli((__FnPtr<int (IntPtr, uint, uint, IDirect3DDevice9*, ID3DXMesh**)>) *(long*) (*(long*) num9 + 88L))((IntPtr) num10, 544U, 274U, idirect3Ddevice9Ptr2, (ID3DXMesh**) num11);
    IDirect3DDevice9* idirect3Ddevice9Ptr3 = idirect3Ddevice9Ptr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num13 = (int) __calli((__FnPtr<uint (IntPtr)>) *(long*) (*(long*) idirect3Ddevice9Ptr3 + 16L /*0x10*/))((IntPtr) idirect3Ddevice9Ptr3);
    uint num14 = NumMaterials == 0U ? 1U : NumMaterials;
    *(int*) ((IntPtr) d3DxmeshcontainerPtr1 + 40L) = (int) num14;
    void* voidPtr3 = \u003CModule\u003E.new\u005B\u005D((ulong) num14 * 80UL /*0x50*/);
    *(long*) ((IntPtr) d3DxmeshcontainerPtr1 + 24L) = (long) voidPtr3;
    if (NumMaterials > 0U)
    {
      if (0U < NumMaterials)
      {
        _D3DXMATERIAL* d3DxmaterialPtr1 = (_D3DXMATERIAL*) ((IntPtr) pMaterials + 72L);
        _D3DXMATERIAL* d3DxmaterialPtr2 = (_D3DXMATERIAL*) (-72L - (IntPtr) pMaterials);
        uint num15 = NumMaterials;
        do
        {
          _D3DXMATERIAL* d3DxmaterialPtr3 = (_D3DXMATERIAL*) ((IntPtr) d3DxmaterialPtr2 + (IntPtr) d3DxmaterialPtr1);
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) d3DxmaterialPtr3 + *(long*) ((IntPtr) d3DxmeshcontainerPtr1 + 24L), (IntPtr) d3DxmaterialPtr1 - 72L, 68);
          ulong num16 = (ulong) *(long*) d3DxmaterialPtr1;
          if (num16 != 0UL)
          {
            long num17 = (long) num16;
            long num18 = num17;
            if (*(sbyte*) num17 != (sbyte) 0)
            {
              do
              {
                ++num18;
              }
              while (*(sbyte*) num18 != (sbyte) 0);
            }
            sbyte* numPtr3 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (num18 - num17) + 1UL);
            *(long*) (*(long*) ((IntPtr) d3DxmeshcontainerPtr1 + 24L) + (IntPtr) d3DxmaterialPtr3 + 72L) = (long) numPtr3;
            long num19 = *(long*) d3DxmaterialPtr1;
            long num20 = *(long*) (*(long*) ((IntPtr) d3DxmeshcontainerPtr1 + 24L) + (IntPtr) d3DxmaterialPtr3 + 72L);
            sbyte num21;
            do
            {
              num21 = *(sbyte*) num19;
              *(sbyte*) num20 = num21;
              ++num19;
              ++num20;
            }
            while (num21 != (sbyte) 0);
          }
          d3DxmaterialPtr1 += 80L /*0x50*/;
          num15 += uint.MaxValue;
        }
        while (num15 > 0U);
      }
    }
    else
    {
      // ISSUE: initblk instruction
      __memset((IntPtr) voidPtr3, 0, 68);
      *(float*) (*(long*) ((IntPtr) d3DxmeshcontainerPtr1 + 24L) + 12L) = 1f;
      *(float*) *(long*) ((IntPtr) d3DxmeshcontainerPtr1 + 24L) = 1f;
      *(float*) (*(long*) ((IntPtr) d3DxmeshcontainerPtr1 + 24L) + 4L) = 1f;
      *(float*) (*(long*) ((IntPtr) d3DxmeshcontainerPtr1 + 24L) + 8L) = 1f;
      long num22 = *(long*) ((IntPtr) d3DxmeshcontainerPtr1 + 24L);
      // ISSUE: cpblk instruction
      __memcpy(num22 + 16L /*0x10*/, num22, 16 /*0x10*/);
    }
    if ((IntPtr) pSkinInfo != IntPtr.Zero)
    {
      *(long*) ((IntPtr) d3DxmeshcontainerPtr1 + 56L) = (long) pSkinInfo;
      ID3DXSkinInfo* id3DxSkinInfoPtr = pSkinInfo;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num23 = (int) __calli((__FnPtr<uint (IntPtr)>) *(long*) (*(long*) id3DxSkinInfoPtr + 8L))((IntPtr) id3DxSkinInfoPtr);
    }
    else
      *(long*) ((IntPtr) d3DxmeshcontainerPtr1 + 56L) = 0L;
    *(long*) ppNewMeshContainer = (long) d3DxmeshcontainerPtr1;
    return 0;
  }

  internal static unsafe int FableMod\u002EGfx\u002EIntegration\u002EAllocateHierarchy\u002EDestroyFrame(
    [In] AllocateHierarchy* obj0,
    _D3DXFRAME* pFrameToFree)
  {
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002EDestroy((D3DXEXTENDEDFRAME*) pFrameToFree);
    return 0;
  }

  internal static unsafe int FableMod\u002EGfx\u002EIntegration\u002EAllocateHierarchy\u002EDestroyMeshContainer(
    [In] AllocateHierarchy* obj0,
    _D3DXMESHCONTAINER* pMeshContainerToFree)
  {
    \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) pMeshContainerToFree);
    \u003CModule\u003E.delete((void*) pMeshContainerToFree);
    return 0;
  }

  internal static unsafe void* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E\u002E__vecDelDtor(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E* fableModGfxTexturePtr = (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E*) ((IntPtr) obj0 - 8L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL /*0x10*/, *(int*) fableModGfxTexturePtr, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) fableModGfxTexturePtr);
      return (void*) fableModGfxTexturePtr;
    }
    \u003CModule\u003E.FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E\u002E\u007Bdtor\u007D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (num1 == 0UL)
      return;
    RootObject* rootObjectPtr = (RootObject*) num1;
    uint num2 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
    if (num2 > 0U)
      *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num2 - 1;
    if (*(int*) ((IntPtr) rootObjectPtr + 8L) != 0)
      return;
    Texture* texturePtr1 = (Texture*) *(long*) ((IntPtr) obj0 + 8L);
    if ((IntPtr) texturePtr1 != IntPtr.Zero)
    {
      Texture* texturePtr2 = texturePtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) texturePtr1)((IntPtr) texturePtr2, 1U);
    }
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
  }

  internal static unsafe MTRL* FableMod\u002EGfx\u002EIntegration\u002EMTRL\u002E\u007Bctor\u007D(
    [In] MTRL* obj0)
  {
    *(long*) ((IntPtr) obj0 + 4L) = 0L;
    return obj0;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EMTRL\u002E\u007Bdtor\u007D(
    [In] MTRL* obj0)
  {
  }

  internal static unsafe VGRPSub* FableMod\u002EGfx\u002EIntegration\u002EVGRPSub\u002E\u007Bctor\u007D(
    [In] VGRPSub* obj0)
  {
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
    return obj0;
  }

  internal static unsafe VGRP* FableMod\u002EGfx\u002EIntegration\u002EVGRP\u002E\u007Bctor\u007D(
    [In] VGRP* obj0)
  {
    // ISSUE: initblk instruction
    __memset((IntPtr) obj0, 0, 12);
    return obj0;
  }

  internal static unsafe int FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection(
    sbyte* dest,
    sbyte* src,
    int size)
  {
    uint num1 = (uint) *(ushort*) src;
    if (num1 == (uint) ushort.MaxValue)
      num1 = (uint) (*(int*) (src + 2L) + 4);
    uint num2 = (uint) size;
    if (num1 == 0U)
    {
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) dest, (IntPtr) (src + 2L), (long) size);
      return size + 2;
    }
    uint inlen = num1 + 5U;
    LZO.DecompressChunk((byte*) src, inlen, (byte*) dest, &num2);
    return (int) inlen;
  }

  internal static unsafe int FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002ECompressSection(
    sbyte* dest,
    sbyte* src,
    int size,
    int destlen,
    [MarshalAs(UnmanagedType.U1)] bool forceNoCompression,
    [MarshalAs(UnmanagedType.U1)] bool forceDWORDLength)
  {
    uint num = (uint) destlen;
    LZO.CompressChunk((byte*) src, (uint) size, (byte*) dest, &num, 3, forceDWORDLength);
    if (num < (uint) size && !forceNoCompression)
      return (int) num;
    *(short*) dest = (short) 0;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) (dest + 2L), (IntPtr) src, (long) size);
    return size + 2;
  }

  internal static unsafe CompiledModel* FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002E\u007Bctor\u007D(
    [In] CompiledModel* obj0,
    sbyte* data,
    uint* length)
  {
    // ISSUE: initblk instruction
    __memset((IntPtr) obj0, 0, 220);
    sbyte* numPtr1 = data;
    if (*data != (sbyte) 0)
    {
      do
      {
        ++numPtr1;
      }
      while (*numPtr1 != (sbyte) 0);
    }
    int num1 = (int) ((IntPtr) numPtr1 - (IntPtr) data);
    ulong num2 = (ulong) (num1 + 1);
    void* voidPtr1 = \u003CModule\u003E.new\u005B\u005D(num2);
    *(long*) obj0 = (long) voidPtr1;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) voidPtr1, (IntPtr) data, (long) num2);
    uint num3 = (uint) (num1 + 1);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 8L, (long) num3 + (IntPtr) data, 51);
    uint num4 = num3 + 51U;
    ushort num5 = *(ushort*) ((IntPtr) obj0 + 49L);
    if (num5 != (ushort) 0)
    {
      HPNT* dest = (HPNT*) \u003CModule\u003E.new\u005B\u005D((ulong) num5 * 20UL);
      *(long*) ((IntPtr) obj0 + 59L) = (long) dest;
      num4 += (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection((sbyte*) dest, (sbyte*) ((long) num4 + (IntPtr) data), (int) ((long) *(ushort*) ((IntPtr) obj0 + 49L) * 20L));
    }
    ushort num6 = *(ushort*) ((IntPtr) obj0 + 51L);
    if (num6 != (ushort) 0)
    {
      HDMY* dest = (HDMY*) \u003CModule\u003E.new\u005B\u005D((ulong) num6 * 56UL);
      *(long*) ((IntPtr) obj0 + 67L) = (long) dest;
      num4 += (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection((sbyte*) dest, (sbyte*) ((long) num4 + (IntPtr) data), (int) ((long) *(ushort*) ((IntPtr) obj0 + 51L) * 56L));
    }
    uint num7 = (uint) *(int*) ((IntPtr) obj0 + 53L);
    if (num7 != 0U)
    {
      sbyte* dest = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) num7);
      num4 += (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection(dest, (sbyte*) ((long) num4 + (IntPtr) data), *(int*) ((IntPtr) obj0 + 53L));
      ushort num8;
      // ISSUE: cpblk instruction
      __memcpy(ref num8, (IntPtr) dest, 2);
      int num9 = 2;
      int num10 = 0;
      int num11 = 0;
      int num12 = 2;
      if (2U < (uint) *(int*) ((IntPtr) obj0 + 53L))
      {
        uint num13 = (uint) *(int*) ((IntPtr) obj0 + 53L);
        sbyte* numPtr2 = dest + 2L;
        do
        {
          if (*numPtr2 == (sbyte) 0)
          {
            if (num12 < (int) num8)
              ++num10;
            else
              ++num11;
          }
          ++num12;
          ++numPtr2;
        }
        while ((uint) num12 < num13);
      }
      int num14 = num10 - 1;
      int num15 = num11 - 1;
      ulong num16 = (ulong) num14;
      sbyte** numPtr3 = (sbyte**) \u003CModule\u003E.new\u005B\u005D(num16 > 2305843009213693951UL /*0x1FFFFFFFFFFFFFFF*/ ? ulong.MaxValue : num16 * 8UL);
      *(long*) ((IntPtr) obj0 + 77L) = (long) numPtr3;
      ulong num17 = (ulong) num15;
      sbyte** numPtr4 = (sbyte**) \u003CModule\u003E.new\u005B\u005D(num17 > 2305843009213693951UL /*0x1FFFFFFFFFFFFFFF*/ ? ulong.MaxValue : num17 * 8UL);
      *(long*) ((IntPtr) obj0 + 87L) = (long) numPtr4;
      *(short*) ((IntPtr) obj0 + 75L) = (short) num14;
      *(short*) ((IntPtr) obj0 + 85L) = (short) num15;
      long num18 = 0;
      long num19 = (long) num14;
      if (0L < num19)
      {
        do
        {
          sbyte* numPtr5 = (sbyte*) ((long) num9 + (IntPtr) dest);
          sbyte* numPtr6 = numPtr5;
          sbyte* numPtr7 = numPtr6;
          if (*numPtr6 != (sbyte) 0)
          {
            do
            {
              ++numPtr7;
            }
            while (*numPtr7 != (sbyte) 0);
          }
          int num20 = (int) ((IntPtr) numPtr7 - (IntPtr) numPtr6);
          ulong num21 = (ulong) (num20 + 1);
          sbyte* numPtr8 = (sbyte*) \u003CModule\u003E.new\u005B\u005D(num21);
          *(long*) (num18 * 8L + *(long*) ((IntPtr) obj0 + 77L)) = (long) numPtr8;
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) numPtr8, (IntPtr) numPtr5, (long) num21);
          num9 += num20 + 1;
          ++num18;
        }
        while (num18 < num19);
      }
      int num22 = num9 + 1;
      long num23 = 0;
      long num24 = (long) num15;
      if (0L < num24)
      {
        do
        {
          sbyte* numPtr9 = (sbyte*) ((long) num22 + (IntPtr) dest);
          sbyte* numPtr10 = numPtr9;
          sbyte* numPtr11 = numPtr10;
          if (*numPtr10 != (sbyte) 0)
          {
            do
            {
              ++numPtr11;
            }
            while (*numPtr11 != (sbyte) 0);
          }
          int num25 = (int) ((IntPtr) numPtr11 - (IntPtr) numPtr10);
          ulong num26 = (ulong) (num25 + 1);
          sbyte* numPtr12 = (sbyte*) \u003CModule\u003E.new\u005B\u005D(num26);
          *(long*) (num23 * 8L + *(long*) ((IntPtr) obj0 + 87L)) = (long) numPtr12;
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) numPtr12, (IntPtr) numPtr9, (long) num26);
          num22 += num25 + 1;
          ++num23;
        }
        while (num23 < num24);
      }
      \u003CModule\u003E.delete\u005B\u005D((void*) dest);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 95L, (long) num4 + (IntPtr) data, 21);
    uint num27 = num4 + 21U;
    uint num28 = (uint) *(int*) ((IntPtr) obj0 + 103L);
    if (num28 != 0U)
    {
      ushort* dest1 = (ushort*) \u003CModule\u003E.new\u005B\u005D((ulong) (num28 - 1U) * 2UL);
      *(long*) ((IntPtr) obj0 + 116L) = (long) dest1;
      uint num29 = num27 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection((sbyte*) dest1, (sbyte*) ((long) num27 + (IntPtr) data), (int) ((long) (uint) (*(int*) ((IntPtr) obj0 + 103L) - 1) * 2L));
      sbyte* dest2 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) obj0 + 107L));
      uint num30 = num29 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection(dest2, (sbyte*) ((long) num29 + (IntPtr) data), *(int*) ((IntPtr) obj0 + 107L));
      sbyte** numPtr13 = (sbyte**) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) obj0 + 103L) * 8UL);
      *(long*) ((IntPtr) obj0 + 124L) = (long) numPtr13;
      sbyte* numPtr14 = dest2;
      if (*dest2 != (sbyte) 0)
      {
        do
        {
          ++numPtr14;
        }
        while (*numPtr14 != (sbyte) 0);
      }
      ulong num31 = (ulong) ((int) ((IntPtr) numPtr14 - (IntPtr) dest2) + 1);
      sbyte* numPtr15 = (sbyte*) \u003CModule\u003E.new\u005B\u005D(num31);
      *(long*) *(long*) ((IntPtr) obj0 + 124L) = (long) numPtr15;
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) numPtr15, (IntPtr) dest2, (long) num31);
      int num32 = 0;
      if (0U < (uint) (*(int*) ((IntPtr) obj0 + 103L) - 1))
      {
        long num33 = *(long*) ((IntPtr) obj0 + 116L);
        long num34 = 0;
        long num35 = 0;
        do
        {
          sbyte* numPtr16 = (sbyte*) ((long) *(ushort*) (num33 + num34) + (IntPtr) dest2);
          sbyte* numPtr17 = numPtr16;
          if (*numPtr16 != (sbyte) 0)
          {
            do
            {
              ++numPtr17;
            }
            while (*numPtr17 != (sbyte) 0);
          }
          ulong num36 = (ulong) ((int) ((IntPtr) numPtr17 - (IntPtr) numPtr16) + 1);
          sbyte* numPtr18 = (sbyte*) \u003CModule\u003E.new\u005B\u005D(num36);
          *(long*) (num35 + *(long*) ((IntPtr) obj0 + 124L) + 8L) = (long) numPtr18;
          num33 = *(long*) ((IntPtr) obj0 + 116L);
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) numPtr18, (long) *(ushort*) (num33 + num34) + (IntPtr) dest2, (long) num36);
          ++num32;
          num35 += 8L;
          num34 += 2L;
        }
        while ((uint) num32 < (uint) (*(int*) ((IntPtr) obj0 + 103L) - 1));
      }
      \u003CModule\u003E.delete\u005B\u005D((void*) dest2);
      BONE_SUB_CHUNK_1* dest3 = (BONE_SUB_CHUNK_1*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) obj0 + 103L) * 60UL);
      *(long*) ((IntPtr) obj0 + 132L) = (long) dest3;
      uint num37 = num30 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection((sbyte*) dest3, (sbyte*) ((long) num30 + (IntPtr) data), (int) ((long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 60L));
      BONE_SUB_CHUNK_2* dest4 = (BONE_SUB_CHUNK_2*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) obj0 + 103L) * 48UL /*0x30*/);
      *(long*) ((IntPtr) obj0 + 140L) = (long) dest4;
      uint num38 = num37 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection((sbyte*) dest4, (sbyte*) ((long) num37 + (IntPtr) data), (int) ((long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 48L /*0x30*/));
      BONE_SUB_CHUNK_3* dest5 = (BONE_SUB_CHUNK_3*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) obj0 + 103L) * 64UL /*0x40*/);
      *(long*) ((IntPtr) obj0 + 148L) = (long) dest5;
      num27 = num38 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection((sbyte*) dest5, (sbyte*) ((long) num38 + (IntPtr) data), (int) ((long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 64L /*0x40*/));
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 156L, (long) num27 + (IntPtr) data, 48 /*0x30*/);
    uint num39 = num27 + 48U /*0x30*/;
    ulong num40 = (ulong) (uint) *(int*) ((IntPtr) obj0 + 95L);
    ulong num41;
    if (num40 <= 409927646082434480UL /*0x05B05B05B05B05B0*/)
    {
      ulong num42 = num40 * 45UL;
      if (num42 <= 18446744073709551611UL)
      {
        num41 = num42 + 4UL;
        goto label_36;
      }
    }
    num41 = ulong.MaxValue;
label_36:
    MTRL* mtrlPtr1 = (MTRL*) \u003CModule\u003E.new\u005B\u005D(num41);
    MTRL* ptr;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) mtrlPtr1 != IntPtr.Zero)
      {
        uint count = (uint) num40;
        *(int*) mtrlPtr1 = (int) count;
        ptr = (MTRL*) ((IntPtr) mtrlPtr1 + 4L);
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.__ehvec_ctor((void*) ptr, 45UL, (int) count, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002EIntegration\u002EMTRL\u002E\u007Bctor\u007D), (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002EIntegration\u002EMTRL\u002E\u007Bdtor\u007D));
        ptr = ptr;
      }
      else
        ptr = (MTRL*) 0L;
    }
    __fault
    {
      \u003CModule\u003E.delete\u005B\u005D((void*) mtrlPtr1);
    }
    *(long*) ((IntPtr) obj0 + 204L) = (long) ptr;
    int num43 = 0;
    if (0U < (uint) *(int*) ((IntPtr) obj0 + 95L))
    {
      MTRL* mtrlPtr2 = ptr;
      long num44 = 0;
      do
      {
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) mtrlPtr2 + num44, (long) num39 + (IntPtr) data, 4);
        uint num45 = num39 + 4U;
        sbyte* numPtr19 = (sbyte*) ((long) num45 + (IntPtr) data);
        sbyte* numPtr20 = numPtr19;
        sbyte* numPtr21 = numPtr20;
        if (*numPtr20 != (sbyte) 0)
        {
          do
          {
            ++numPtr21;
          }
          while (*numPtr21 != (sbyte) 0);
        }
        int num46 = (int) ((IntPtr) numPtr21 - (IntPtr) numPtr20);
        ulong num47 = (ulong) (num46 + 1);
        sbyte* numPtr22 = (sbyte*) \u003CModule\u003E.new\u005B\u005D(num47);
        mtrlPtr2 = (MTRL*) *(long*) ((IntPtr) obj0 + 204L);
        *(long*) ((IntPtr) mtrlPtr2 + num44 + 4L) = (long) numPtr22;
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) numPtr22, (IntPtr) numPtr19, (long) num47);
        uint num48 = num45 + (uint) (num46 + 1);
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) mtrlPtr2 + num44 + 12L, (long) num48 + (IntPtr) data, 33);
        num39 = num48 + 33U;
        ++num43;
        num44 += 45L;
      }
      while ((uint) num43 < (uint) *(int*) ((IntPtr) obj0 + 95L));
    }
    SUBM** submPtr1 = (SUBM**) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) obj0 + 99L) * 8UL);
    *(long*) ((IntPtr) obj0 + 212L) = (long) submPtr1;
    int num49 = 0;
    if (0U < (uint) *(int*) ((IntPtr) obj0 + 99L))
    {
      long num50 = 0;
      do
      {
        SUBM* submPtr2 = (SUBM*) \u003CModule\u003E.@new(144UL /*0x90*/);
        SUBM* submPtr3;
        // ISSUE: fault handler
        try
        {
          if ((IntPtr) submPtr2 != IntPtr.Zero)
          {
            // ISSUE: initblk instruction
            __memset((IntPtr) submPtr2, 0, 144 /*0x90*/);
            submPtr3 = submPtr2;
          }
          else
            submPtr3 = (SUBM*) 0L;
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) submPtr2);
        }
        long num51 = *(long*) ((IntPtr) obj0 + 212L) + num50;
        *(long*) num51 = (long) submPtr3;
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) submPtr3, (long) num39 + (IntPtr) data, 60);
        uint num52 = num39 + 60U;
        SUBM_SUB_CHUNK_1* submSubChunk1Ptr = (SUBM_SUB_CHUNK_1*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) (*(long*) num51 + 28L) * 15UL);
        long num53 = *(long*) ((IntPtr) obj0 + 212L) + num50;
        *(long*) (*(long*) num53 + 60L) = (long) submSubChunk1Ptr;
        long num54 = *(long*) num53;
        // ISSUE: cpblk instruction
        __memcpy(*(long*) (num54 + 60L), (long) num52 + (IntPtr) data, (long) (uint) *(int*) (num54 + 28L) * 15L);
        long num55 = *(long*) num53;
        uint num56 = (uint) ((ulong) (uint) *(int*) (num55 + 28L) * 15UL + (ulong) num52);
        SUBM_SUB_CHUNK_2** submSubChunk2Ptr1 = (SUBM_SUB_CHUNK_2**) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) (num55 + 32L /*0x20*/) * 8UL);
        long num57 = *(long*) ((IntPtr) obj0 + 212L) + num50;
        *(long*) (*(long*) num57 + 68L) = (long) submSubChunk2Ptr1;
        int num58 = 0;
        if (0U < (uint) *(int*) (*(long*) num57 + 32L /*0x20*/))
        {
          long num59 = 0;
          do
          {
            SUBM_SUB_CHUNK_2* submSubChunk2Ptr2 = (SUBM_SUB_CHUNK_2*) \u003CModule\u003E.@new(27UL);
            SUBM_SUB_CHUNK_2* submSubChunk2Ptr3;
            // ISSUE: fault handler
            try
            {
              if ((IntPtr) submSubChunk2Ptr2 != IntPtr.Zero)
              {
                *(long*) ((IntPtr) submSubChunk2Ptr2 + 19L) = 0L;
                submSubChunk2Ptr3 = submSubChunk2Ptr2;
              }
              else
                submSubChunk2Ptr3 = (SUBM_SUB_CHUNK_2*) 0L;
            }
            __fault
            {
              \u003CModule\u003E.delete((void*) submSubChunk2Ptr2);
            }
            long num60 = *(long*) ((IntPtr) obj0 + 212L) + num50;
            *(long*) (*(long*) (*(long*) num60 + 68L) + num59) = (long) submSubChunk2Ptr3;
            // ISSUE: cpblk instruction
            __memcpy(*(long*) (*(long*) (*(long*) num60 + 68L) + num59), (long) num56 + (IntPtr) data, 19);
            uint num61 = num56 + 19U;
            byte* numPtr23 = (byte*) \u003CModule\u003E.new\u005B\u005D((ulong) *(byte*) (*(long*) (*(long*) (*(long*) num60 + 68L) + num59) + 18L));
            long num62 = *(long*) ((IntPtr) obj0 + 212L) + num50;
            *(long*) (*(long*) (*(long*) (*(long*) num62 + 68L) + num59) + 19L) = (long) numPtr23;
            long num63 = *(long*) (*(long*) (*(long*) num62 + 68L) + num59);
            // ISSUE: cpblk instruction
            __memcpy(*(long*) (num63 + 19L), (long) num61 + (IntPtr) data, (long) *(byte*) (num63 + 18L));
            num56 = num61 + (uint) *(byte*) (*(long*) (*(long*) (*(long*) num62 + 68L) + num59) + 18L);
            ++num58;
            num59 += 8L;
          }
          while ((uint) num58 < (uint) *(int*) (*(long*) (*(long*) ((IntPtr) obj0 + 212L) + num50) + 32L /*0x20*/));
        }
        long num64 = *(long*) ((IntPtr) obj0 + 212L) + num50;
        // ISSUE: cpblk instruction
        __memcpy(*(long*) num64 + 76L, (long) num56 + (IntPtr) data, 40);
        uint num65 = num56 + 40U;
        uint num66;
        if (*(int*) (*(long*) num64 + 4L) == 0)
        {
          long num67 = *(long*) num64;
          sbyte* numPtr24 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) (*(int*) (num67 + 108L) * *(int*) (num67 + 36L)));
          long num68 = *(long*) ((IntPtr) obj0 + 212L) + num50;
          *(long*) (*(long*) num68 + 116L) = (long) numPtr24;
          long num69 = *(long*) num68;
          uint num70 = num65 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection((sbyte*) *(long*) (num69 + 116L), (sbyte*) ((long) num65 + (IntPtr) data), *(int*) (num69 + 108L) * *(int*) (num69 + 36L));
          ushort* numPtr25 = (ushort*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) (*(long*) (*(long*) ((IntPtr) obj0 + 212L) + num50) + 44L) * 2UL);
          long num71 = *(long*) ((IntPtr) obj0 + 212L) + num50;
          *(long*) (*(long*) num71 + 124L) = (long) numPtr25;
          long num72 = *(long*) num71;
          num66 = num70 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection((sbyte*) *(long*) (num72 + 124L), (sbyte*) ((long) num70 + (IntPtr) data), (int) ((long) (uint) *(int*) (num72 + 44L) * 2L));
        }
        else
        {
          long num73 = *(long*) num64;
          sbyte* numPtr26 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) (*(int*) (num73 + 108L) * *(int*) (num73 + 36L) * *(int*) (num73 + 4L)));
          long num74 = *(long*) ((IntPtr) obj0 + 212L) + num50;
          *(long*) (*(long*) num74 + 116L) = (long) numPtr26;
          long num75 = *(long*) num74;
          uint num76 = num65 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection((sbyte*) *(long*) (num75 + 116L), (sbyte*) ((long) num65 + (IntPtr) data), *(int*) (num75 + 108L) * *(int*) (num75 + 36L) * *(int*) (num75 + 4L));
          long num77 = *(long*) (*(long*) ((IntPtr) obj0 + 212L) + num50);
          ushort* numPtr27 = (ushort*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) (*(int*) (num77 + 44L) * *(int*) (num77 + 4L)) * 2UL);
          long num78 = *(long*) ((IntPtr) obj0 + 212L) + num50;
          *(long*) (*(long*) num78 + 124L) = (long) numPtr27;
          long num79 = *(long*) num78;
          num66 = num76 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection((sbyte*) *(long*) (num79 + 124L), (sbyte*) ((long) num76 + (IntPtr) data), (int) ((long) (uint) *(int*) (num79 + 44L) * (long) (uint) *(int*) (num79 + 4L) * 2L));
        }
        long num80 = *(long*) ((IntPtr) obj0 + 212L) + num50;
        // ISSUE: cpblk instruction
        __memcpy(*(long*) num80 + 132L, (long) num66 + (IntPtr) data, 4);
        num39 = num66 + 4U;
        CLTH** clthPtr1 = (CLTH**) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) (*(long*) num80 + 132L) * 8UL);
        long num81 = *(long*) ((IntPtr) obj0 + 212L) + num50;
        *(long*) (*(long*) num81 + 136L) = (long) clthPtr1;
        int num82 = 0;
        if (0U < (uint) *(int*) (*(long*) num81 + 132L))
        {
          long num83 = 0;
          do
          {
            CLTH* clthPtr2 = (CLTH*) \u003CModule\u003E.@new(168UL);
            CLTH* clthPtr3;
            // ISSUE: fault handler
            try
            {
              if ((IntPtr) clthPtr2 != IntPtr.Zero)
              {
                // ISSUE: initblk instruction
                __memset((IntPtr) clthPtr2, 0, 168);
                clthPtr3 = clthPtr2;
              }
              else
                clthPtr3 = (CLTH*) 0L;
            }
            __fault
            {
              \u003CModule\u003E.delete((void*) clthPtr2);
            }
            long num84 = *(long*) ((IntPtr) obj0 + 212L) + num50;
            *(long*) (*(long*) (*(long*) num84 + 136L) + num83) = (long) clthPtr3;
            CLTH* clthPtr4 = (CLTH*) *(long*) (*(long*) (*(long*) num84 + 136L) + num83);
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthPtr4, (long) num39 + (IntPtr) data, 12);
            uint num85 = num39 + 12U;
            sbyte* dest = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) clthPtr4 + 8L));
            num39 = num85 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002EDecompressSection(dest, (sbyte*) ((long) num85 + (IntPtr) data), *(int*) ((IntPtr) clthPtr4 + 8L));
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthPtr4 + 12L, (IntPtr) dest, 8);
            sbyte* numPtr28 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) clthPtr4 + 16L /*0x10*/));
            *(long*) ((IntPtr) clthPtr4 + 20L) = (long) numPtr28;
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) numPtr28, (IntPtr) (dest + 8L), (long) (uint) *(int*) ((IntPtr) clthPtr4 + 16L /*0x10*/));
            int num86 = *(int*) ((IntPtr) clthPtr4 + 16L /*0x10*/) + 8;
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthPtr4 + 28L, (long) num86 + (IntPtr) dest, 16 /*0x10*/);
            int num87 = num86 + 16 /*0x10*/;
            CLTH_Particle* clthParticlePtr = (CLTH_Particle*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) clthPtr4 + 40L) * 12UL);
            *(long*) ((IntPtr) clthPtr4 + 44L) = (long) clthParticlePtr;
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthParticlePtr, (long) num87 + (IntPtr) dest, (long) (uint) *(int*) ((IntPtr) clthPtr4 + 40L) * 12L);
            ulong num88 = (ulong) (uint) *(int*) ((IntPtr) clthPtr4 + 40L);
            int num89 = (int) ((long) num88 * 12L + (long) num87);
            float* numPtr29 = (float*) \u003CModule\u003E.new\u005B\u005D(num88 * 4UL);
            *(long*) ((IntPtr) clthPtr4 + 52L) = (long) numPtr29;
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) numPtr29, (long) num89 + (IntPtr) dest, (long) (uint) (*(int*) ((IntPtr) clthPtr4 + 40L) * 4));
            int num90 = num89 + *(int*) ((IntPtr) clthPtr4 + 40L) * 4;
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthPtr4 + 60L, (long) num90 + (IntPtr) dest, 23);
            int num91 = num90 + 23;
            CLTH_Tri* clthTriPtr = (CLTH_Tri*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) clthPtr4 + 79L) * 6UL);
            *(long*) ((IntPtr) clthPtr4 + 83L) = (long) clthTriPtr;
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthTriPtr, (long) num91 + (IntPtr) dest, (long) (uint) *(int*) ((IntPtr) clthPtr4 + 79L) * 6L);
            int num92 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr4 + 79L) * 6L + (long) num91);
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthPtr4 + 91L, (long) num92 + (IntPtr) dest, 8);
            int num93 = num92 + 8;
            UnknownEntry* unknownEntryPtr = (UnknownEntry*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) clthPtr4 + 95L) * 4UL);
            *(long*) ((IntPtr) clthPtr4 + 99L) = (long) unknownEntryPtr;
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) unknownEntryPtr, (long) num93 + (IntPtr) dest, (long) (uint) *(int*) ((IntPtr) clthPtr4 + 95L) * 4L);
            int num94 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr4 + 95L) * 4L + (long) num93);
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthPtr4 + 107L, (long) num94 + (IntPtr) dest, 4);
            int num95 = num94 + 4;
            CLTH_Vertex* clthVertexPtr = (CLTH_Vertex*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) clthPtr4 + 107L) * 12UL);
            *(long*) ((IntPtr) clthPtr4 + 111L) = (long) clthVertexPtr;
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthVertexPtr, (long) num95 + (IntPtr) dest, (long) (uint) *(int*) ((IntPtr) clthPtr4 + 107L) * 12L);
            int num96 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr4 + 107L) * 12L + (long) num95);
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthPtr4 + 119L, (long) num96 + (IntPtr) dest, 4);
            int num97 = num96 + 4;
            CLTH_TexCoord* clthTexCoordPtr = (CLTH_TexCoord*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) clthPtr4 + 119L) * 8UL);
            *(long*) ((IntPtr) clthPtr4 + 123L) = (long) clthTexCoordPtr;
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthTexCoordPtr, (long) num97 + (IntPtr) dest, (long) (uint) *(int*) ((IntPtr) clthPtr4 + 119L) * 8L);
            int num98 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr4 + 119L) * 8L + (long) num97);
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthPtr4 + 131L, (long) num98 + (IntPtr) dest, 4);
            int num99 = num98 + 4;
            uint* numPtr30 = (uint*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) clthPtr4 + 131L) * 4UL);
            *(long*) ((IntPtr) clthPtr4 + 135L) = (long) numPtr30;
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) numPtr30, (long) num99 + (IntPtr) dest, (long) (uint) *(int*) ((IntPtr) clthPtr4 + 131L) * 4L);
            int num100 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr4 + 131L) * 4L + (long) num99);
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthPtr4 + 143L, (long) num100 + (IntPtr) dest, 4);
            int num101 = num100 + 4;
            uint* numPtr31 = (uint*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) clthPtr4 + 143L) * 4UL);
            *(long*) ((IntPtr) clthPtr4 + 147L) = (long) numPtr31;
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) numPtr31, (long) num101 + (IntPtr) dest, (long) (uint) *(int*) ((IntPtr) clthPtr4 + 143L) * 4L);
            int num102 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr4 + 143L) * 4L + (long) num101);
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) clthPtr4 + 155L, (long) num102 + (IntPtr) dest, 1);
            int num103 = num102 + 1;
            *(int*) ((IntPtr) clthPtr4 + 156L) = 4;
            VGRP** vgrpPtr1 = (VGRP**) \u003CModule\u003E.new\u005B\u005D(32UL /*0x20*/);
            *(long*) ((IntPtr) clthPtr4 + 160L /*0xA0*/) = (long) vgrpPtr1;
            int num104 = 0;
            if (0U < (uint) *(int*) ((IntPtr) clthPtr4 + 156L))
            {
              long num105 = 0;
              do
              {
                VGRP* vgrpPtr2 = (VGRP*) \u003CModule\u003E.@new(12UL);
                VGRP* vgrpPtr3;
                // ISSUE: fault handler
                try
                {
                  vgrpPtr3 = (IntPtr) vgrpPtr2 == IntPtr.Zero ? (VGRP*) 0L : \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EVGRP\u002E\u007Bctor\u007D(vgrpPtr2);
                }
                __fault
                {
                  \u003CModule\u003E.delete((void*) vgrpPtr2);
                }
                *(long*) (*(long*) ((IntPtr) clthPtr4 + 160L /*0xA0*/) + num105) = (long) vgrpPtr3;
                VGRP* vgrpPtr4 = (VGRP*) *(long*) (*(long*) ((IntPtr) clthPtr4 + 160L /*0xA0*/) + num105);
                // ISSUE: cpblk instruction
                __memcpy((IntPtr) vgrpPtr4, (long) num103 + (IntPtr) dest, 4);
                num103 += 4;
                VGRPSub** vgrpSubPtr1 = (VGRPSub**) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) vgrpPtr4 * 8UL);
                *(long*) ((IntPtr) vgrpPtr4 + 4L) = (long) vgrpSubPtr1;
                int num106 = 0;
                if (0U < (uint) *(int*) vgrpPtr4)
                {
                  long num107 = 0;
                  do
                  {
                    VGRPSub* vgrpSubPtr2 = (VGRPSub*) \u003CModule\u003E.@new(16UL /*0x10*/);
                    VGRPSub* vgrpSubPtr3;
                    // ISSUE: fault handler
                    try
                    {
                      vgrpSubPtr3 = (IntPtr) vgrpSubPtr2 == IntPtr.Zero ? (VGRPSub*) 0L : \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EVGRPSub\u002E\u007Bctor\u007D(vgrpSubPtr2);
                    }
                    __fault
                    {
                      \u003CModule\u003E.delete((void*) vgrpSubPtr2);
                    }
                    *(long*) (num107 + *(long*) ((IntPtr) vgrpPtr4 + 4L)) = (long) vgrpSubPtr3;
                    VGRPSub* vgrpSubPtr4 = (VGRPSub*) *(long*) (num107 + *(long*) ((IntPtr) vgrpPtr4 + 4L));
                    // ISSUE: cpblk instruction
                    __memcpy((IntPtr) vgrpSubPtr4, (long) num103 + (IntPtr) dest, 8);
                    int num108 = num103 + 8;
                    void* voidPtr2 = \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) vgrpSubPtr4 + 4L) * 8UL);
                    *(long*) ((IntPtr) vgrpSubPtr4 + 8L) = (long) voidPtr2;
                    // ISSUE: cpblk instruction
                    __memcpy((IntPtr) voidPtr2, (long) num108 + (IntPtr) dest, (long) (uint) *(int*) ((IntPtr) vgrpSubPtr4 + 4L) * 8L);
                    num103 = (int) ((long) (uint) *(int*) ((IntPtr) vgrpSubPtr4 + 4L) * 8L + (long) num108);
                    ++num106;
                    num107 += 8L;
                  }
                  while ((uint) num106 < (uint) *(int*) vgrpPtr4);
                }
                ++num104;
                num105 += 8L;
              }
              while ((uint) num104 < (uint) *(int*) ((IntPtr) clthPtr4 + 156L));
            }
            \u003CModule\u003E.delete\u005B\u005D((void*) dest);
            ++num82;
            num83 += 8L;
          }
          while ((uint) num82 < (uint) *(int*) (*(long*) (*(long*) ((IntPtr) obj0 + 212L) + num50) + 132L));
        }
        ++num49;
        num50 += 8L;
      }
      while ((uint) num49 < (uint) *(int*) ((IntPtr) obj0 + 99L));
    }
    *length = num39;
    return obj0;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002E\u007Bdtor\u007D(
    [In] CompiledModel* obj0)
  {
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EDestroy(obj0);
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EDestroy(
    [In] CompiledModel* obj0)
  {
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EClearSubMeshes(obj0);
    *(int*) ((IntPtr) obj0 + 99L) = 0;
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EDestroyMaterials(obj0);
    ulong num = (ulong) *(long*) obj0;
    if (num != 0UL)
    {
      \u003CModule\u003E.delete\u005B\u005D((void*) num);
      *(long*) obj0 = 0L;
    }
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EClearBones(obj0);
    *(int*) ((IntPtr) obj0 + 103L) = 0;
    *(int*) ((IntPtr) obj0 + 107L) = 0;
    *(sbyte*) ((IntPtr) obj0 + 8L) = (sbyte) 0;
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EClearHelpers(obj0);
    *(short*) ((IntPtr) obj0 + 75L) = (short) 0;
    *(short*) ((IntPtr) obj0 + 85L) = (short) 0;
    *(int*) ((IntPtr) obj0 + 53L) = 0;
    *(short*) ((IntPtr) obj0 + 49L) = (short) 0;
    *(short*) ((IntPtr) obj0 + 51L) = (short) 0;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002ESaveToBuffer(
    [In] CompiledModel* obj0,
    sbyte* data,
    int* length)
  {
    long num1 = *(long*) obj0;
    long num2 = num1;
    long num3 = num2;
    if (*(sbyte*) num2 != (sbyte) 0)
    {
      do
      {
        ++num3;
      }
      while (*(sbyte*) num3 != (sbyte) 0);
    }
    int num4 = (int) (num3 - num2) + 1;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) data, num1, (long) num4);
    uint num5 = (uint) num4;
    *(int*) ((IntPtr) obj0 + 53L) = 0;
    ushort num6 = *(ushort*) ((IntPtr) obj0 + 85L);
    ushort num7 = *(ushort*) ((IntPtr) obj0 + 75L);
    sbyte* in1;
    if ((int) num7 + (int) num6 > 0)
    {
      ushort num8 = 2;
      if ((ushort) 0 < num7)
      {
        long num9 = *(long*) ((IntPtr) obj0 + 77L);
        uint num10 = (uint) *(ushort*) ((IntPtr) obj0 + 75L);
        do
        {
          long num11 = *(long*) num9;
          long num12 = num11;
          if (*(sbyte*) num11 != (sbyte) 0)
          {
            do
            {
              ++num12;
            }
            while (*(sbyte*) num12 != (sbyte) 0);
          }
          num8 = (ushort) (uint) ((ulong) (num12 - num11) + (ulong) num8 + 1UL);
          num9 += 8L;
          num10 += uint.MaxValue;
        }
        while (num10 > 0U);
      }
      ushort num13 = (ushort) ((int) num8 + 1);
      uint num14 = (uint) num13;
      *(int*) ((IntPtr) obj0 + 53L) = (int) num14;
      int num15 = 0;
      if ((ushort) 0 < num6)
      {
        uint num16 = num14;
        long num17 = *(long*) ((IntPtr) obj0 + 87L);
        do
        {
          long num18 = *(long*) num17;
          long num19 = num18;
          if (*(sbyte*) num18 != (sbyte) 0)
          {
            do
            {
              ++num19;
            }
            while (*(sbyte*) num19 != (sbyte) 0);
          }
          num16 = (uint) ((ulong) (num19 - num18) + (ulong) num16 + 1UL);
          *(int*) ((IntPtr) obj0 + 53L) = (int) num16;
          ++num15;
          num17 += 8L;
        }
        while (num15 < (int) *(ushort*) ((IntPtr) obj0 + 85L));
      }
      *(int*) ((IntPtr) obj0 + 53L) = *(int*) ((IntPtr) obj0 + 53L) + 1;
      in1 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) obj0 + 53L));
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) in1, ref num13, 2);
      int num20 = 2;
      int num21 = 0;
      if ((ushort) 0 < *(ushort*) ((IntPtr) obj0 + 75L))
      {
        long num22 = 0;
        do
        {
          long num23 = *(long*) (num22 + *(long*) ((IntPtr) obj0 + 77L));
          sbyte* numPtr = (sbyte*) ((long) num20 + (IntPtr) in1);
          sbyte num24;
          do
          {
            num24 = *(sbyte*) num23;
            *numPtr = num24;
            ++num23;
            ++numPtr;
          }
          while (num24 != (sbyte) 0);
          long num25 = *(long*) (num22 + *(long*) ((IntPtr) obj0 + 77L));
          long num26 = num25;
          if (*(sbyte*) num25 != (sbyte) 0)
          {
            do
            {
              ++num26;
            }
            while (*(sbyte*) num26 != (sbyte) 0);
          }
          num20 = (int) (num26 - num25 + (long) num20 + 1L);
          ++num21;
          num22 += 8L;
        }
        while (num21 < (int) *(ushort*) ((IntPtr) obj0 + 75L));
      }
      *(sbyte*) ((long) num20 + (IntPtr) in1) = (sbyte) 0;
      int num27 = num20 + 1;
      int num28 = 0;
      if ((ushort) 0 < *(ushort*) ((IntPtr) obj0 + 85L))
      {
        long num29 = 0;
        do
        {
          long num30 = *(long*) (num29 + *(long*) ((IntPtr) obj0 + 87L));
          sbyte* numPtr = (sbyte*) ((long) num27 + (IntPtr) in1);
          sbyte num31;
          do
          {
            num31 = *(sbyte*) num30;
            *numPtr = num31;
            ++num30;
            ++numPtr;
          }
          while (num31 != (sbyte) 0);
          long num32 = *(long*) (num29 + *(long*) ((IntPtr) obj0 + 87L));
          long num33 = num32;
          if (*(sbyte*) num32 != (sbyte) 0)
          {
            do
            {
              ++num33;
            }
            while (*(sbyte*) num33 != (sbyte) 0);
          }
          num27 = (int) (num33 - num32 + (long) num27 + 1L);
          ++num28;
          num29 += 8L;
        }
        while (num28 < (int) *(ushort*) ((IntPtr) obj0 + 85L));
      }
      *(sbyte*) ((long) num27 + (IntPtr) in1) = (sbyte) 0;
      if (num27 + 1 != *(int*) ((IntPtr) obj0 + 53L))
        throw new System.Exception("Err, indexed, compressed, helper strings are gay");
    }
    // ISSUE: cpblk instruction
    __memcpy((long) num5 + (IntPtr) data, (IntPtr) obj0 + 8L, 51);
    uint num34 = num5 + 51U;
    ushort num35 = *(ushort*) ((IntPtr) obj0 + 49L);
    if (num35 != (ushort) 0)
    {
      int inlen = (int) ((long) num35 * 20L);
      sbyte* in2 = (sbyte*) *(long*) ((IntPtr) obj0 + 59L);
      sbyte* @out = (sbyte*) ((long) num34 + (IntPtr) data);
      uint num36 = (uint) *length - num34;
      LZO.CompressChunk((byte*) in2, (uint) inlen, (byte*) @out, &num36, 3, false);
      uint num37;
      if (num36 < (uint) inlen)
      {
        num37 = num36;
      }
      else
      {
        *(short*) @out = (short) 0;
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) (@out + 2L), (IntPtr) in2, (long) inlen);
        num37 = (uint) (inlen + 2);
      }
      num34 += num37;
    }
    ushort num38 = *(ushort*) ((IntPtr) obj0 + 51L);
    if (num38 != (ushort) 0)
    {
      int inlen = (int) ((long) num38 * 56L);
      sbyte* in3 = (sbyte*) *(long*) ((IntPtr) obj0 + 67L);
      sbyte* @out = (sbyte*) ((long) num34 + (IntPtr) data);
      uint num39 = (uint) *length - num34;
      LZO.CompressChunk((byte*) in3, (uint) inlen, (byte*) @out, &num39, 3, false);
      uint num40;
      if (num39 < (uint) inlen)
      {
        num40 = num39;
      }
      else
      {
        *(short*) @out = (short) 0;
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) (@out + 2L), (IntPtr) in3, (long) inlen);
        num40 = (uint) (inlen + 2);
      }
      num34 += num40;
    }
    uint num41 = (uint) *(int*) ((IntPtr) obj0 + 53L);
    if (num41 != 0U)
    {
      int inlen = (int) num41;
      sbyte* @out = (sbyte*) ((long) num34 + (IntPtr) data);
      uint num42 = (uint) *length - num34;
      LZO.CompressChunk((byte*) in1, (uint) inlen, (byte*) @out, &num42, 3, false);
      uint num43;
      if (num42 < (uint) inlen)
      {
        num43 = num42;
      }
      else
      {
        *(short*) @out = (short) 0;
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) (@out + 2L), (IntPtr) in1, (long) inlen);
        num43 = (uint) (inlen + 2);
      }
      num34 += num43;
      \u003CModule\u003E.delete((void*) in1);
    }
    uint num44 = (uint) *(int*) ((IntPtr) obj0 + 103L);
    ushort* src1;
    sbyte* in4;
    if (num44 != 0U)
    {
      src1 = (ushort*) \u003CModule\u003E.new\u005B\u005D((ulong) (num44 - 1U) * 2UL);
      long num45 = *(long*) *(long*) ((IntPtr) obj0 + 124L);
      long num46 = num45;
      if (*(sbyte*) num45 != (sbyte) 0)
      {
        do
        {
          ++num46;
        }
        while (*(sbyte*) num46 != (sbyte) 0);
      }
      ulong num47 = (ulong) (num46 - num45);
      *(int*) ((IntPtr) obj0 + 107L) = (int) (uint) (num47 + 1UL);
      int num48 = 1;
      if (1U < (uint) *(int*) ((IntPtr) obj0 + 103L))
      {
        long num49 = 8;
        ushort* numPtr = src1;
        do
        {
          *numPtr = (ushort) *(int*) ((IntPtr) obj0 + 107L);
          long num50 = *(long*) (num49 + *(long*) ((IntPtr) obj0 + 124L));
          long num51 = num50;
          if (*(sbyte*) num50 != (sbyte) 0)
          {
            do
            {
              ++num51;
            }
            while (*(sbyte*) num51 != (sbyte) 0);
          }
          ulong num52 = (ulong) (num51 - num50);
          *(int*) ((IntPtr) obj0 + 107L) = (int) (uint) (num52 + (ulong) (uint) *(int*) ((IntPtr) obj0 + 107L) + 1UL);
          ++num48;
          numPtr += 2L;
          num49 += 8L;
        }
        while ((uint) num48 < (uint) *(int*) ((IntPtr) obj0 + 103L));
      }
      in4 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) obj0 + 107L));
      int num53 = 0;
      int num54 = 0;
      if (0U < (uint) *(int*) ((IntPtr) obj0 + 103L))
      {
        long num55 = 0;
        do
        {
          long num56 = *(long*) (*(long*) ((IntPtr) obj0 + 124L) + num55);
          sbyte* numPtr = (sbyte*) ((long) num53 + (IntPtr) in4);
          sbyte num57;
          do
          {
            num57 = *(sbyte*) num56;
            *numPtr = num57;
            ++num56;
            ++numPtr;
          }
          while (num57 != (sbyte) 0);
          long num58 = *(long*) (*(long*) ((IntPtr) obj0 + 124L) + num55);
          long num59 = num58;
          if (*(sbyte*) num58 != (sbyte) 0)
          {
            do
            {
              ++num59;
            }
            while (*(sbyte*) num59 != (sbyte) 0);
          }
          num53 = (int) (num59 - num58 + (long) num53 + 1L);
          ++num54;
          num55 += 8L;
        }
        while ((uint) num54 < (uint) *(int*) ((IntPtr) obj0 + 103L));
      }
      if (num53 != *(int*) ((IntPtr) obj0 + 107L))
        throw new System.Exception("bone index gayness");
    }
    // ISSUE: cpblk instruction
    __memcpy((long) num34 + (IntPtr) data, (IntPtr) obj0 + 95L, 21);
    uint num60 = num34 + 21U;
    uint num61 = (uint) *(int*) ((IntPtr) obj0 + 103L);
    if (num61 != 0U)
    {
      uint destlen = (uint) *length - num60;
      sbyte* dest = (sbyte*) ((long) num60 + (IntPtr) data);
      uint num62 = num60 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002ECompressSection(dest, (sbyte*) src1, (int) ((long) (num61 - 1U) * 2L), (int) destlen, true, false);
      \u003CModule\u003E.delete((void*) src1);
      int inlen1 = *(int*) ((IntPtr) obj0 + 107L);
      sbyte* out1 = (sbyte*) ((long) num62 + (IntPtr) data);
      uint num63 = (uint) *length - num62;
      LZO.CompressChunk((byte*) in4, (uint) inlen1, (byte*) out1, &num63, 3, false);
      uint num64;
      if (num63 < (uint) inlen1)
      {
        num64 = num63;
      }
      else
      {
        *(short*) out1 = (short) 0;
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) (out1 + 2L), (IntPtr) in4, (long) inlen1);
        num64 = (uint) (inlen1 + 2);
      }
      uint num65 = num62 + num64;
      \u003CModule\u003E.delete((void*) in4);
      int inlen2 = (int) ((long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 60L);
      sbyte* in5 = (sbyte*) *(long*) ((IntPtr) obj0 + 132L);
      sbyte* out2 = (sbyte*) ((long) num65 + (IntPtr) data);
      uint num66 = (uint) *length - num65;
      LZO.CompressChunk((byte*) in5, (uint) inlen2, (byte*) out2, &num66, 3, false);
      uint num67;
      if (num66 < (uint) inlen2)
      {
        num67 = num66;
      }
      else
      {
        *(short*) out2 = (short) 0;
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) (out2 + 2L), (IntPtr) in5, (long) inlen2);
        num67 = (uint) (inlen2 + 2);
      }
      uint num68 = num65 + num67;
      int inlen3 = (int) ((long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 48L /*0x30*/);
      sbyte* in6 = (sbyte*) *(long*) ((IntPtr) obj0 + 140L);
      sbyte* out3 = (sbyte*) ((long) num68 + (IntPtr) data);
      uint num69 = (uint) *length - num68;
      LZO.CompressChunk((byte*) in6, (uint) inlen3, (byte*) out3, &num69, 3, false);
      uint num70;
      if (num69 < (uint) inlen3)
      {
        num70 = num69;
      }
      else
      {
        *(short*) out3 = (short) 0;
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) (out3 + 2L), (IntPtr) in6, (long) inlen3);
        num70 = (uint) (inlen3 + 2);
      }
      uint num71 = num68 + num70;
      int inlen4 = (int) ((long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 64L /*0x40*/);
      sbyte* in7 = (sbyte*) *(long*) ((IntPtr) obj0 + 148L);
      sbyte* out4 = (sbyte*) ((long) num71 + (IntPtr) data);
      uint num72 = (uint) *length - num71;
      LZO.CompressChunk((byte*) in7, (uint) inlen4, (byte*) out4, &num72, 3, false);
      uint num73;
      if (num72 < (uint) inlen4)
      {
        num73 = num72;
      }
      else
      {
        *(short*) out4 = (short) 0;
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) (out4 + 2L), (IntPtr) in7, (long) inlen4);
        num73 = (uint) (inlen4 + 2);
      }
      num60 = num71 + num73;
    }
    // ISSUE: cpblk instruction
    __memcpy((long) num60 + (IntPtr) data, (IntPtr) obj0 + 156L, 48 /*0x30*/);
    uint num74 = num60 + 48U /*0x30*/;
    int num75 = 0;
    if (0U < (uint) *(int*) ((IntPtr) obj0 + 95L))
    {
      long num76 = 0;
      do
      {
        // ISSUE: cpblk instruction
        __memcpy((long) num74 + (IntPtr) data, *(long*) ((IntPtr) obj0 + 204L) + num76, 4);
        uint num77 = num74 + 4U;
        long num78 = *(long*) (num76 + *(long*) ((IntPtr) obj0 + 204L) + 4L);
        sbyte* numPtr = (sbyte*) ((long) num77 + (IntPtr) data);
        sbyte num79;
        do
        {
          num79 = *(sbyte*) num78;
          *numPtr = num79;
          ++num78;
          ++numPtr;
        }
        while (num79 != (sbyte) 0);
        long num80 = *(long*) ((IntPtr) obj0 + 204L) + num76;
        long num81 = *(long*) (num80 + 4L);
        long num82 = num81;
        if (*(sbyte*) num81 != (sbyte) 0)
        {
          do
          {
            ++num82;
          }
          while (*(sbyte*) num82 != (sbyte) 0);
        }
        uint num83 = (uint) ((ulong) (num82 - num81) + (ulong) num77 + 1UL);
        // ISSUE: cpblk instruction
        __memcpy((long) num83 + (IntPtr) data, num80 + 12L, 33);
        num74 = num83 + 33U;
        ++num75;
        num76 += 45L;
      }
      while ((uint) num75 < (uint) *(int*) ((IntPtr) obj0 + 95L));
    }
    int num84 = 0;
    if (0U < (uint) *(int*) ((IntPtr) obj0 + 99L))
    {
      long num85 = 0;
      do
      {
        // ISSUE: cpblk instruction
        __memcpy((long) num74 + (IntPtr) data, *(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85), 60);
        uint num86 = num74 + 60U;
        long num87 = *(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85);
        // ISSUE: cpblk instruction
        __memcpy((long) num86 + (IntPtr) data, *(long*) (num87 + 60L), (long) (uint) *(int*) (num87 + 28L) * 15L);
        long num88 = *(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85);
        uint num89 = (uint) ((ulong) (uint) *(int*) (num88 + 28L) * 15UL + (ulong) num86);
        int num90 = 0;
        if (0U < (uint) *(int*) (num88 + 32L /*0x20*/))
        {
          long num91 = *(long*) (num88 + 68L);
          long num92 = 0;
          do
          {
            // ISSUE: cpblk instruction
            __memcpy((long) num89 + (IntPtr) data, *(long*) (num91 + num92), 19);
            uint num93 = num89 + 19U;
            long num94 = *(long*) (*(long*) (*(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85) + 68L) + num92);
            // ISSUE: cpblk instruction
            __memcpy((long) num93 + (IntPtr) data, *(long*) (num94 + 19L), (long) *(byte*) (num94 + 18L));
            num91 = *(long*) (*(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85) + 68L);
            num89 = num93 + (uint) *(byte*) (*(long*) (num91 + num92) + 18L);
            ++num90;
            num92 += 8L;
          }
          while ((uint) num90 < (uint) *(int*) (*(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85) + 32L /*0x20*/));
        }
        // ISSUE: cpblk instruction
        __memcpy((long) num89 + (IntPtr) data, *(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85) + 76L, 40);
        uint num95 = num89 + 40U;
        long num96 = *(long*) ((IntPtr) obj0 + 212L) + num85;
        long num97 = *(long*) num96;
        uint num98;
        if (*(int*) (num97 + 4L) == 0)
        {
          uint destlen1 = (uint) *length - num95;
          byte forceDWORDLength = (byte) ((uint) *(int*) (num97 + 32L /*0x20*/) > 1U);
          long num99 = *(long*) num96;
          sbyte* dest1 = (sbyte*) ((long) num95 + (IntPtr) data);
          uint num100 = num95 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002ECompressSection(dest1, (sbyte*) *(long*) (num99 + 116L), *(int*) (num99 + 108L) * *(int*) (num99 + 36L), (int) destlen1, false, (bool) forceDWORDLength);
          uint destlen2 = (uint) *length - num100;
          long num101 = *(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85);
          sbyte* dest2 = (sbyte*) ((long) num100 + (IntPtr) data);
          num98 = num100 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002ECompressSection(dest2, (sbyte*) *(long*) (num101 + 124L), (int) ((long) (uint) *(int*) (num101 + 44L) * 2L), (int) destlen2, false, false);
        }
        else
        {
          uint destlen3 = (uint) *length - num95;
          long num102 = *(long*) num96;
          sbyte* dest3 = (sbyte*) ((long) num95 + (IntPtr) data);
          uint num103 = num95 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002ECompressSection(dest3, (sbyte*) *(long*) (num102 + 116L), *(int*) (num102 + 108L) * *(int*) (num102 + 36L) * *(int*) (num102 + 4L), (int) destlen3, false, false);
          uint destlen4 = (uint) *length - num103;
          long num104 = *(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85);
          sbyte* dest4 = (sbyte*) ((long) num103 + (IntPtr) data);
          num98 = num103 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002ECompressSection(dest4, (sbyte*) *(long*) (num104 + 124L), (int) ((long) (uint) *(int*) (num104 + 44L) * (long) (uint) *(int*) (num104 + 4L) * 2L), (int) destlen4, false, false);
        }
        // ISSUE: cpblk instruction
        __memcpy((long) num98 + (IntPtr) data, *(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85) + 132L, 4);
        num74 = num98 + 4U;
        int num105 = 0;
        if (0U < (uint) *(int*) (*(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85) + 132L))
        {
          long num106 = 0;
          do
          {
            CLTH* clthPtr1 = (CLTH*) *(long*) (*(long*) (*(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85) + 136L) + num106);
            // ISSUE: cpblk instruction
            __memcpy((long) num74 + (IntPtr) data, (IntPtr) clthPtr1, 12);
            uint num107 = num74 + 12U;
            sbyte* src2 = (sbyte*) \u003CModule\u003E.new\u005B\u005D(262144UL /*0x040000*/);
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) src2, (IntPtr) clthPtr1 + 12L, 8);
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) (src2 + 8L), *(long*) ((IntPtr) clthPtr1 + 20L), (long) (uint) *(int*) ((IntPtr) clthPtr1 + 16L /*0x10*/));
            int num108 = *(int*) ((IntPtr) clthPtr1 + 16L /*0x10*/) + 8;
            // ISSUE: cpblk instruction
            __memcpy((long) num108 + (IntPtr) src2, (IntPtr) clthPtr1 + 28L, 16 /*0x10*/);
            int num109 = num108 + 16 /*0x10*/;
            // ISSUE: cpblk instruction
            __memcpy((long) num109 + (IntPtr) src2, *(long*) ((IntPtr) clthPtr1 + 44L), (long) (uint) *(int*) ((IntPtr) clthPtr1 + 40L) * 12L);
            ulong num110 = (ulong) (uint) *(int*) ((IntPtr) clthPtr1 + 40L);
            int num111 = (int) ((long) num110 * 12L + (long) num109);
            // ISSUE: cpblk instruction
            __memcpy((long) num111 + (IntPtr) src2, *(long*) ((IntPtr) clthPtr1 + 52L), (long) num110 * 4L);
            int num112 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr1 + 40L) * 4L + (long) num111);
            // ISSUE: cpblk instruction
            __memcpy((long) num112 + (IntPtr) src2, (IntPtr) clthPtr1 + 60L, 23);
            int num113 = num112 + 23;
            // ISSUE: cpblk instruction
            __memcpy((long) num113 + (IntPtr) src2, *(long*) ((IntPtr) clthPtr1 + 83L), (long) (uint) *(int*) ((IntPtr) clthPtr1 + 79L) * 6L);
            int num114 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr1 + 79L) * 6L + (long) num113);
            // ISSUE: cpblk instruction
            __memcpy((long) num114 + (IntPtr) src2, (IntPtr) clthPtr1 + 91L, 8);
            int num115 = num114 + 8;
            // ISSUE: cpblk instruction
            __memcpy((long) num115 + (IntPtr) src2, *(long*) ((IntPtr) clthPtr1 + 99L), (long) (uint) *(int*) ((IntPtr) clthPtr1 + 95L) * 4L);
            int num116 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr1 + 95L) * 4L + (long) num115);
            // ISSUE: cpblk instruction
            __memcpy((long) num116 + (IntPtr) src2, (IntPtr) clthPtr1 + 107L, 4);
            int num117 = num116 + 4;
            // ISSUE: cpblk instruction
            __memcpy((long) num117 + (IntPtr) src2, *(long*) ((IntPtr) clthPtr1 + 111L), (long) (uint) *(int*) ((IntPtr) clthPtr1 + 107L) * 12L);
            int num118 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr1 + 107L) * 12L + (long) num117);
            // ISSUE: cpblk instruction
            __memcpy((long) num118 + (IntPtr) src2, (IntPtr) clthPtr1 + 119L, 4);
            int num119 = num118 + 4;
            // ISSUE: cpblk instruction
            __memcpy((long) num119 + (IntPtr) src2, *(long*) ((IntPtr) clthPtr1 + 123L), (long) (uint) *(int*) ((IntPtr) clthPtr1 + 119L) * 8L);
            int num120 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr1 + 119L) * 8L + (long) num119);
            // ISSUE: cpblk instruction
            __memcpy((long) num120 + (IntPtr) src2, (IntPtr) clthPtr1 + 131L, 4);
            int num121 = num120 + 4;
            // ISSUE: cpblk instruction
            __memcpy((long) num121 + (IntPtr) src2, *(long*) ((IntPtr) clthPtr1 + 135L), (long) (uint) *(int*) ((IntPtr) clthPtr1 + 131L) * 4L);
            int num122 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr1 + 131L) * 4L + (long) num121);
            // ISSUE: cpblk instruction
            __memcpy((long) num122 + (IntPtr) src2, (IntPtr) clthPtr1 + 143L, 4);
            int num123 = num122 + 4;
            // ISSUE: cpblk instruction
            __memcpy((long) num123 + (IntPtr) src2, *(long*) ((IntPtr) clthPtr1 + 147L), (long) (uint) *(int*) ((IntPtr) clthPtr1 + 143L) * 4L);
            int num124 = (int) ((long) (uint) *(int*) ((IntPtr) clthPtr1 + 143L) * 4L + (long) num123);
            // ISSUE: cpblk instruction
            __memcpy((long) num124 + (IntPtr) src2, (IntPtr) clthPtr1 + 155L, 1);
            int size = num124 + 1;
            int num125 = 0;
            if (0U < (uint) *(int*) ((IntPtr) clthPtr1 + 156L))
            {
              CLTH* clthPtr2 = (CLTH*) ((IntPtr) clthPtr1 + 160L /*0xA0*/);
              long num126 = 0;
              do
              {
                VGRP* vgrpPtr1 = (VGRP*) *(long*) (*(long*) clthPtr2 + num126);
                // ISSUE: cpblk instruction
                __memcpy((long) size + (IntPtr) src2, (IntPtr) vgrpPtr1, 4);
                size += 4;
                int num127 = 0;
                if (0U < (uint) *(int*) vgrpPtr1)
                {
                  VGRP* vgrpPtr2 = (VGRP*) ((IntPtr) vgrpPtr1 + 4L);
                  long num128 = 0;
                  do
                  {
                    VGRPSub* vgrpSubPtr = (VGRPSub*) *(long*) (*(long*) vgrpPtr2 + num128);
                    // ISSUE: cpblk instruction
                    __memcpy((long) size + (IntPtr) src2, (IntPtr) vgrpSubPtr, 8);
                    int num129 = size + 8;
                    // ISSUE: cpblk instruction
                    __memcpy((long) num129 + (IntPtr) src2, *(long*) ((IntPtr) vgrpSubPtr + 8L), (long) (uint) *(int*) ((IntPtr) vgrpSubPtr + 4L) * 8L);
                    size = (int) ((long) (uint) *(int*) ((IntPtr) vgrpSubPtr + 4L) * 8L + (long) num129);
                    ++num127;
                    num128 += 8L;
                  }
                  while ((uint) num127 < (uint) *(int*) vgrpPtr1);
                }
                ++num125;
                num126 += 8L;
              }
              while ((uint) num125 < (uint) *(int*) ((IntPtr) clthPtr1 + 156L));
            }
            *(int*) ((IntPtr) clthPtr1 + 8L) = size;
            uint destlen = (uint) *length - num107;
            sbyte* dest = (sbyte*) ((long) num107 + (IntPtr) data);
            num74 = num107 + (uint) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xc6ab5b14\u002ECompressSection(dest, src2, size, (int) destlen, false, false);
            \u003CModule\u003E.delete\u005B\u005D((void*) src2);
            ++num105;
            num106 += 8L;
          }
          while ((uint) num105 < (uint) *(int*) (*(long*) (*(long*) ((IntPtr) obj0 + 212L) + num85) + 132L));
        }
        ++num84;
        num85 += 8L;
      }
      while ((uint) num84 < (uint) *(int*) ((IntPtr) obj0 + 99L));
    }
    *length = (int) num74;
  }

  internal static unsafe MTRL* FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EGetMaterialFromID(
    [In] CompiledModel* obj0,
    uint id)
  {
    int num1 = 0;
    uint num2 = (uint) *(int*) ((IntPtr) obj0 + 95L);
    if (0U < num2)
    {
      long num3 = *(long*) ((IntPtr) obj0 + 204L);
      long num4 = num3;
      while (*(int*) num4 != (int) id)
      {
        ++num1;
        num4 += 45L;
        if ((uint) num1 >= num2)
          goto label_5;
      }
      return (MTRL*) ((long) num1 * 45L + num3);
    }
label_5:
    return (MTRL*) 0L;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EHDMY\u002EGetMatrix(
    [In] HDMY* obj0,
    D3DXMATRIX* mat)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040M arrayTypeBy0BaM;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 12) = 0.0f;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 28) = 0.0f;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 44) = 0.0f;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 60) = 1f;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ref arrayTypeBy0BaM = *(float*) ((IntPtr) obj0 + 4L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 4) = *(float*) ((IntPtr) obj0 + 8L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 8) = *(float*) ((IntPtr) obj0 + 12L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 16 /*0x10*/) = *(float*) ((IntPtr) obj0 + 16L /*0x10*/);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 20) = *(float*) ((IntPtr) obj0 + 20L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 24) = *(float*) ((IntPtr) obj0 + 24L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 32 /*0x20*/) = *(float*) ((IntPtr) obj0 + 28L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 36) = *(float*) ((IntPtr) obj0 + 32L /*0x20*/);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 40) = *(float*) ((IntPtr) obj0 + 36L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 48 /*0x30*/) = *(float*) ((IntPtr) obj0 + 40L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 52) = *(float*) ((IntPtr) obj0 + 44L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 56) = *(float*) ((IntPtr) obj0 + 48L /*0x30*/);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) mat, ref arrayTypeBy0BaM, 64 /*0x40*/);
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EHDMY\u002ESetMatrix(
    [In] HDMY* obj0,
    D3DXMATRIX* mat)
  {
    *(float*) ((IntPtr) obj0 + 4L) = *(float*) mat;
    *(float*) ((IntPtr) obj0 + 8L) = *(float*) ((IntPtr) mat + 4L);
    *(float*) ((IntPtr) obj0 + 12L) = *(float*) ((IntPtr) mat + 8L);
    *(float*) ((IntPtr) obj0 + 16L /*0x10*/) = *(float*) ((IntPtr) mat + 16L /*0x10*/);
    *(float*) ((IntPtr) obj0 + 20L) = *(float*) ((IntPtr) mat + 20L);
    *(float*) ((IntPtr) obj0 + 24L) = *(float*) ((IntPtr) mat + 24L);
    *(float*) ((IntPtr) obj0 + 28L) = *(float*) ((IntPtr) mat + 32L /*0x20*/);
    *(float*) ((IntPtr) obj0 + 32L /*0x20*/) = *(float*) ((IntPtr) mat + 36L);
    *(float*) ((IntPtr) obj0 + 36L) = *(float*) ((IntPtr) mat + 40L);
    *(float*) ((IntPtr) obj0 + 40L) = *(float*) ((IntPtr) mat + 48L /*0x30*/);
    *(float*) ((IntPtr) obj0 + 44L) = *(float*) ((IntPtr) mat + 52L);
    *(float*) ((IntPtr) obj0 + 48L /*0x30*/) = *(float*) ((IntPtr) mat + 56L);
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EHPNT\u002ESetMatrix(
    [In] HPNT* obj0,
    D3DXMATRIX* mat)
  {
    *(float*) ((IntPtr) obj0 + 4L) = *(float*) ((IntPtr) mat + 48L /*0x30*/);
    *(float*) ((IntPtr) obj0 + 8L) = *(float*) ((IntPtr) mat + 52L);
    *(float*) ((IntPtr) obj0 + 12L) = *(float*) ((IntPtr) mat + 56L);
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EBONE_SUB_CHUNK_1\u002EGetMatrix(
    [In] BONE_SUB_CHUNK_1* obj0,
    D3DXMATRIX* mat)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040M arrayTypeBy0BaM;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 12) = 0.0f;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 28) = 0.0f;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 44) = 0.0f;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 60) = 1f;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ref arrayTypeBy0BaM = *(float*) ((IntPtr) obj0 + 12L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 4) = *(float*) ((IntPtr) obj0 + 16L /*0x10*/);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 8) = *(float*) ((IntPtr) obj0 + 20L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 16 /*0x10*/) = *(float*) ((IntPtr) obj0 + 24L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 20) = *(float*) ((IntPtr) obj0 + 28L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 24) = *(float*) ((IntPtr) obj0 + 32L /*0x20*/);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 32 /*0x20*/) = *(float*) ((IntPtr) obj0 + 36L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 36) = *(float*) ((IntPtr) obj0 + 40L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 40) = *(float*) ((IntPtr) obj0 + 44L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 48 /*0x30*/) = *(float*) ((IntPtr) obj0 + 48L /*0x30*/);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 52) = *(float*) ((IntPtr) obj0 + 52L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 56) = *(float*) ((IntPtr) obj0 + 56L);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) mat, ref arrayTypeBy0BaM, 64 /*0x40*/);
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EBONE_SUB_CHUNK_1\u002ESetMatrix(
    [In] BONE_SUB_CHUNK_1* obj0,
    D3DXMATRIX* mat)
  {
    *(float*) ((IntPtr) obj0 + 12L) = *(float*) mat;
    *(float*) ((IntPtr) obj0 + 16L /*0x10*/) = *(float*) ((IntPtr) mat + 4L);
    *(float*) ((IntPtr) obj0 + 20L) = *(float*) ((IntPtr) mat + 8L);
    *(float*) ((IntPtr) obj0 + 24L) = *(float*) ((IntPtr) mat + 16L /*0x10*/);
    *(float*) ((IntPtr) obj0 + 28L) = *(float*) ((IntPtr) mat + 20L);
    *(float*) ((IntPtr) obj0 + 32L /*0x20*/) = *(float*) ((IntPtr) mat + 24L);
    *(float*) ((IntPtr) obj0 + 36L) = *(float*) ((IntPtr) mat + 32L /*0x20*/);
    *(float*) ((IntPtr) obj0 + 40L) = *(float*) ((IntPtr) mat + 36L);
    *(float*) ((IntPtr) obj0 + 44L) = *(float*) ((IntPtr) mat + 40L);
    *(float*) ((IntPtr) obj0 + 48L /*0x30*/) = *(float*) ((IntPtr) mat + 48L /*0x30*/);
    *(float*) ((IntPtr) obj0 + 52L) = *(float*) ((IntPtr) mat + 52L);
    *(float*) ((IntPtr) obj0 + 56L) = *(float*) ((IntPtr) mat + 56L);
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EBONE_SUB_CHUNK_3\u002EGetMatrix(
    [In] BONE_SUB_CHUNK_3* obj0,
    D3DXMATRIX* mat)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040M arrayTypeBy0BaM;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ref arrayTypeBy0BaM = *(float*) obj0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 4) = *(float*) ((IntPtr) obj0 + 16L /*0x10*/);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 8) = *(float*) ((IntPtr) obj0 + 32L /*0x20*/);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 12) = *(float*) ((IntPtr) obj0 + 48L /*0x30*/);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 16 /*0x10*/) = *(float*) ((IntPtr) obj0 + 4L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 20) = *(float*) ((IntPtr) obj0 + 20L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 24) = *(float*) ((IntPtr) obj0 + 36L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 28) = *(float*) ((IntPtr) obj0 + 52L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 32 /*0x20*/) = *(float*) ((IntPtr) obj0 + 8L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 36) = *(float*) ((IntPtr) obj0 + 24L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 40) = *(float*) ((IntPtr) obj0 + 40L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 44) = *(float*) ((IntPtr) obj0 + 56L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 48 /*0x30*/) = *(float*) ((IntPtr) obj0 + 12L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 52) = *(float*) ((IntPtr) obj0 + 28L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 56) = *(float*) ((IntPtr) obj0 + 44L);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &arrayTypeBy0BaM + 60) = *(float*) ((IntPtr) obj0 + 60L);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) mat, ref arrayTypeBy0BaM, 64 /*0x40*/);
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EBONE_SUB_CHUNK_3\u002ESetMatrix(
    [In] BONE_SUB_CHUNK_3* obj0,
    D3DXMATRIX* mat)
  {
    *(float*) obj0 = *(float*) mat;
    *(float*) ((IntPtr) obj0 + 16L /*0x10*/) = *(float*) ((IntPtr) mat + 4L);
    *(float*) ((IntPtr) obj0 + 32L /*0x20*/) = *(float*) ((IntPtr) mat + 8L);
    *(float*) ((IntPtr) obj0 + 48L /*0x30*/) = *(float*) ((IntPtr) mat + 12L);
    *(float*) ((IntPtr) obj0 + 4L) = *(float*) ((IntPtr) mat + 16L /*0x10*/);
    *(float*) ((IntPtr) obj0 + 20L) = *(float*) ((IntPtr) mat + 20L);
    *(float*) ((IntPtr) obj0 + 36L) = *(float*) ((IntPtr) mat + 24L);
    *(float*) ((IntPtr) obj0 + 52L) = *(float*) ((IntPtr) mat + 28L);
    *(float*) ((IntPtr) obj0 + 8L) = *(float*) ((IntPtr) mat + 32L /*0x20*/);
    *(float*) ((IntPtr) obj0 + 24L) = *(float*) ((IntPtr) mat + 36L);
    *(float*) ((IntPtr) obj0 + 40L) = *(float*) ((IntPtr) mat + 40L);
    *(float*) ((IntPtr) obj0 + 56L) = *(float*) ((IntPtr) mat + 44L);
    *(float*) ((IntPtr) obj0 + 12L) = *(float*) ((IntPtr) mat + 48L /*0x30*/);
    *(float*) ((IntPtr) obj0 + 28L) = *(float*) ((IntPtr) mat + 52L);
    *(float*) ((IntPtr) obj0 + 44L) = *(float*) ((IntPtr) mat + 56L);
    *(float*) ((IntPtr) obj0 + 60L) = *(float*) ((IntPtr) mat + 60L);
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EBONE_SUB_CHUNK_2\u002EGetMatrix(
    [In] BONE_SUB_CHUNK_2* obj0,
    D3DXMATRIX* mat)
  {
    float num1 = *(float*) ((IntPtr) obj0 + 24L);
    float num2 = *(float*) ((IntPtr) obj0 + 20L);
    D3DXVECTOR3 d3DxvectoR3_1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ref d3DxvectoR3_1 = *(float*) ((IntPtr) obj0 + 16L /*0x10*/);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &d3DxvectoR3_1 + 4) = num2;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &d3DxvectoR3_1 + 8) = num1;
    float num3 = -*(float*) ((IntPtr) obj0 + 12L);
    float num4 = *(float*) ((IntPtr) obj0 + 8L);
    float num5 = *(float*) ((IntPtr) obj0 + 4L);
    D3DXQUATERNION d3Dxquaternion;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ref d3Dxquaternion = *(float*) obj0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &d3Dxquaternion + 4) = num5;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &d3Dxquaternion + 8) = num4;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &d3Dxquaternion + 12) = num3;
    float num6 = *(float*) ((IntPtr) obj0 + 40L);
    float num7 = *(float*) ((IntPtr) obj0 + 36L);
    D3DXVECTOR3 d3DxvectoR3_2;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ref d3DxvectoR3_2 = *(float*) ((IntPtr) obj0 + 32L /*0x20*/);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &d3DxvectoR3_2 + 4) = num7;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(float&) ((IntPtr) &d3DxvectoR3_2 + 8) = num6;
    \u003CModule\u003E.D3DXMatrixTransformation(mat, (D3DXVECTOR3*) 0L, (D3DXQUATERNION*) 0L, &d3DxvectoR3_2, (D3DXVECTOR3*) 0L, &d3Dxquaternion, &d3DxvectoR3_1);
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EBONE_SUB_CHUNK_2\u002ESetMatrix(
    [In] BONE_SUB_CHUNK_2* obj0,
    D3DXMATRIX* mat)
  {
    D3DXVECTOR3 d3DxvectoR3_1;
    D3DXQUATERNION d3Dxquaternion;
    D3DXVECTOR3 d3DxvectoR3_2;
    \u003CModule\u003E.D3DXMatrixDecompose(&d3DxvectoR3_1, &d3Dxquaternion, &d3DxvectoR3_2, mat);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(float*) ((IntPtr) obj0 + 32L /*0x20*/) = ^(float&) ref d3DxvectoR3_1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(float*) ((IntPtr) obj0 + 36L) = ^(float&) ((IntPtr) &d3DxvectoR3_1 + 4);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(float*) ((IntPtr) obj0 + 40L) = ^(float&) ((IntPtr) &d3DxvectoR3_1 + 8);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(float*) obj0 = ^(float&) ref d3Dxquaternion;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(float*) ((IntPtr) obj0 + 4L) = ^(float&) ((IntPtr) &d3Dxquaternion + 4);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(float*) ((IntPtr) obj0 + 8L) = ^(float&) ((IntPtr) &d3Dxquaternion + 8);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(float*) ((IntPtr) obj0 + 12L) = -^(float&) ((IntPtr) &d3Dxquaternion + 12);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(float*) ((IntPtr) obj0 + 16L /*0x10*/) = ^(float&) ref d3DxvectoR3_2;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(float*) ((IntPtr) obj0 + 20L) = ^(float&) ((IntPtr) &d3DxvectoR3_2 + 4);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(float*) ((IntPtr) obj0 + 24L) = ^(float&) ((IntPtr) &d3DxvectoR3_2 + 8);
  }

  internal static unsafe D3DXEXTENDEDFRAME* FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002ECreateBoneHeirarchy(
    [In] CompiledModel* obj0,
    int bonenum,
    D3DXMATRIX* parentTransform)
  {
    D3DXEXTENDEDFRAME* d3DxextendedframePtr1 = (D3DXEXTENDEDFRAME*) \u003CModule\u003E.@new(168UL);
    D3DXEXTENDEDFRAME* boneHeirarchy1;
    // ISSUE: fault handler
    try
    {
      boneHeirarchy1 = (IntPtr) d3DxextendedframePtr1 == IntPtr.Zero ? (D3DXEXTENDEDFRAME*) 0L : \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002E\u007Bctor\u007D(d3DxextendedframePtr1);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) d3DxextendedframePtr1);
    }
    long num1 = (long) bonenum;
    *(long*) boneHeirarchy1 = (long) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECopyXFileSafeString((sbyte*) *(long*) (num1 * 8L + *(long*) ((IntPtr) obj0 + 124L)));
    *(long*) ((IntPtr) boneHeirarchy1 + 80L /*0x50*/) = 0L;
    *(long*) ((IntPtr) boneHeirarchy1 + 72L) = 0L;
    *(long*) ((IntPtr) boneHeirarchy1 + 88L) = 0L;
    D3DXEXTENDEDFRAME* mat = (D3DXEXTENDEDFRAME*) ((IntPtr) boneHeirarchy1 + 8L);
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EBONE_SUB_CHUNK_2\u002EGetMatrix((BONE_SUB_CHUNK_2*) (num1 * 48L /*0x30*/ + *(long*) ((IntPtr) obj0 + 140L)), (D3DXMATRIX*) mat);
    D3DXMATRIX d3Dxmatrix;
    \u003CModule\u003E.D3DXMatrixMultiply(&d3Dxmatrix, (D3DXMATRIX*) mat, parentTransform);
    D3DXEXTENDEDFRAME* d3DxextendedframePtr2 = (D3DXEXTENDEDFRAME*) \u003CModule\u003E.@new(168UL);
    D3DXEXTENDEDFRAME* d3DxextendedframePtr3;
    // ISSUE: fault handler
    try
    {
      d3DxextendedframePtr3 = (IntPtr) d3DxextendedframePtr2 == IntPtr.Zero ? (D3DXEXTENDEDFRAME*) 0L : \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002E\u007Bctor\u007D(d3DxextendedframePtr2);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) d3DxextendedframePtr2);
    }
    _D3DXFRAME* d3DxframePtr = (_D3DXFRAME*) d3DxextendedframePtr3;
    *(long*) d3DxextendedframePtr3 = (long) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECopyXFileSafeString((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040GNOHACJB\u0040BONE_OFFSET_MATRIX\u003F\u0024AA\u0040);
    *(long*) ((IntPtr) d3DxextendedframePtr3 + 80L /*0x50*/) = 0L;
    *(long*) ((IntPtr) d3DxextendedframePtr3 + 72L) = 0L;
    *(long*) ((IntPtr) d3DxextendedframePtr3 + 88L) = 0L;
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EBONE_SUB_CHUNK_1\u002EGetMatrix((BONE_SUB_CHUNK_1*) (num1 * 60L + *(long*) ((IntPtr) obj0 + 132L)), (D3DXMATRIX*) ((IntPtr) d3DxextendedframePtr3 + 8L));
    *(long*) ((IntPtr) boneHeirarchy1 + 88L) = (long) d3DxextendedframePtr3;
    int bonenum1 = 0;
    if (0U < (uint) *(int*) ((IntPtr) obj0 + 103L))
    {
      long num2 = 0;
      do
      {
        if (*(int*) (*(long*) ((IntPtr) obj0 + 132L) + num2 + 4L) == bonenum)
        {
          D3DXEXTENDEDFRAME* boneHeirarchy2 = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002ECreateBoneHeirarchy(obj0, bonenum1, &d3Dxmatrix);
          if ((IntPtr) d3DxframePtr == IntPtr.Zero)
          {
            *(long*) ((IntPtr) boneHeirarchy1 + 88L) = (long) boneHeirarchy2;
            d3DxframePtr = (_D3DXFRAME*) boneHeirarchy2;
          }
          else
          {
            *(long*) ((IntPtr) d3DxframePtr + 80L /*0x50*/) = (long) boneHeirarchy2;
            d3DxframePtr = (_D3DXFRAME*) boneHeirarchy2;
          }
        }
        ++bonenum1;
        num2 += 60L;
      }
      while ((uint) bonenum1 < (uint) *(int*) ((IntPtr) obj0 + 103L));
    }
    D3DXEXTENDEDFRAME* helpers = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EGetHelpers(obj0, bonenum, &d3Dxmatrix);
    if ((IntPtr) d3DxframePtr == IntPtr.Zero)
      *(long*) ((IntPtr) boneHeirarchy1 + 88L) = (long) helpers;
    else
      *(long*) ((IntPtr) d3DxframePtr + 80L /*0x50*/) = (long) helpers;
    return boneHeirarchy1;
  }

  internal static unsafe D3DXEXTENDEDFRAME* FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EGetHelpers(
    [In] CompiledModel* obj0,
    int bonenum,
    D3DXMATRIX* parentTransform)
  {
    D3DXEXTENDEDFRAME* d3DxextendedframePtr1 = (D3DXEXTENDEDFRAME*) 0L;
    D3DXEXTENDEDFRAME* helpers = (D3DXEXTENDEDFRAME*) 0L;
    int num1 = 0;
    if ((ushort) 0 < *(ushort*) ((IntPtr) obj0 + 51L))
    {
      long num2 = 0;
      do
      {
        if (*(int*) (num2 + *(long*) ((IntPtr) obj0 + 67L) + 52L) == bonenum)
        {
          if ((IntPtr) d3DxextendedframePtr1 != IntPtr.Zero)
          {
            D3DXEXTENDEDFRAME* d3DxextendedframePtr2 = (D3DXEXTENDEDFRAME*) \u003CModule\u003E.@new(168UL);
            D3DXEXTENDEDFRAME* d3DxextendedframePtr3;
            // ISSUE: fault handler
            try
            {
              d3DxextendedframePtr3 = (IntPtr) d3DxextendedframePtr2 == IntPtr.Zero ? (D3DXEXTENDEDFRAME*) 0L : \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002E\u007Bctor\u007D(d3DxextendedframePtr2);
            }
            __fault
            {
              \u003CModule\u003E.delete((void*) d3DxextendedframePtr2);
            }
            // ISSUE: initblk instruction
            __memset((IntPtr) d3DxextendedframePtr3, 0, 168);
            *(long*) ((IntPtr) d3DxextendedframePtr1 + 80L /*0x50*/) = (long) d3DxextendedframePtr3;
            d3DxextendedframePtr1 = d3DxextendedframePtr3;
          }
          else
          {
            D3DXEXTENDEDFRAME* d3DxextendedframePtr4 = (D3DXEXTENDEDFRAME*) \u003CModule\u003E.@new(168UL);
            D3DXEXTENDEDFRAME* d3DxextendedframePtr5;
            // ISSUE: fault handler
            try
            {
              d3DxextendedframePtr5 = (IntPtr) d3DxextendedframePtr4 == IntPtr.Zero ? (D3DXEXTENDEDFRAME*) 0L : \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002E\u007Bctor\u007D(d3DxextendedframePtr4);
            }
            __fault
            {
              \u003CModule\u003E.delete((void*) d3DxextendedframePtr4);
            }
            d3DxextendedframePtr1 = d3DxextendedframePtr5;
            helpers = d3DxextendedframePtr5;
          }
          CompiledModel* compiledModelPtr = obj0;
          int crc = *(int*) (*(long*) ((IntPtr) compiledModelPtr + 67L) + num2);
          int hdmyString = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EFindHDMYString(compiledModelPtr, (uint) crc);
          sbyte* src = (sbyte*) \u003CModule\u003E.new\u005B\u005D(1024UL /*0x0400*/);
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) src, ref \u003CModule\u003E.\u003F\u003F_C\u0040_05DHHFPMJA\u0040HDMY_\u003F\u0024AA\u0040, 6);
          if (hdmyString > -1)
          {
            long num3 = *(long*) ((long) hdmyString * 8L + *(long*) ((IntPtr) obj0 + 87L));
            sbyte* numPtr = src + 5L;
            sbyte num4;
            do
            {
              num4 = *(sbyte*) num3;
              *numPtr = num4;
              ++num3;
              ++numPtr;
            }
            while (num4 != (sbyte) 0);
          }
          else
          {
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) (src + 5L), ref \u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040POPMPNFF\u0040NAME_NOT_FOUND\u003F\u0024AA\u0040, 15);
          }
          *(long*) d3DxextendedframePtr1 = (long) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECopyXFileSafeString(src);
          \u003CModule\u003E.delete\u005B\u005D((void*) src);
          D3DXMATRIX d3Dxmatrix1;
          \u003CModule\u003E.D3DXMatrixInverse(&d3Dxmatrix1, (float*) 0L, parentTransform);
          D3DXMATRIX d3Dxmatrix2;
          \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EHDMY\u002EGetMatrix((HDMY*) ((long) num1 * 56L + *(long*) ((IntPtr) obj0 + 67L)), &d3Dxmatrix2);
          \u003CModule\u003E.D3DXMatrixMultiply((D3DXMATRIX*) ((IntPtr) d3DxextendedframePtr1 + 8L), &d3Dxmatrix2, &d3Dxmatrix1);
        }
        ++num1;
        num2 += 56L;
      }
      while (num1 < (int) *(ushort*) ((IntPtr) obj0 + 51L));
    }
    int num5 = 0;
    if ((ushort) 0 < *(ushort*) ((IntPtr) obj0 + 49L))
    {
      long num6 = 0;
      do
      {
        if (*(int*) (*(long*) ((IntPtr) obj0 + 59L) + num6 + 16L /*0x10*/) == bonenum)
        {
          if ((IntPtr) d3DxextendedframePtr1 != IntPtr.Zero)
          {
            D3DXEXTENDEDFRAME* d3DxextendedframePtr6 = (D3DXEXTENDEDFRAME*) \u003CModule\u003E.@new(168UL);
            D3DXEXTENDEDFRAME* d3DxextendedframePtr7;
            // ISSUE: fault handler
            try
            {
              d3DxextendedframePtr7 = (IntPtr) d3DxextendedframePtr6 == IntPtr.Zero ? (D3DXEXTENDEDFRAME*) 0L : \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002E\u007Bctor\u007D(d3DxextendedframePtr6);
            }
            __fault
            {
              \u003CModule\u003E.delete((void*) d3DxextendedframePtr6);
            }
            // ISSUE: initblk instruction
            __memset((IntPtr) d3DxextendedframePtr7, 0, 168);
            *(long*) ((IntPtr) d3DxextendedframePtr1 + 80L /*0x50*/) = (long) d3DxextendedframePtr7;
            d3DxextendedframePtr1 = d3DxextendedframePtr7;
          }
          else
          {
            D3DXEXTENDEDFRAME* d3DxextendedframePtr8 = (D3DXEXTENDEDFRAME*) \u003CModule\u003E.@new(168UL);
            D3DXEXTENDEDFRAME* d3DxextendedframePtr9;
            // ISSUE: fault handler
            try
            {
              d3DxextendedframePtr9 = (IntPtr) d3DxextendedframePtr8 == IntPtr.Zero ? (D3DXEXTENDEDFRAME*) 0L : \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002E\u007Bctor\u007D(d3DxextendedframePtr8);
            }
            __fault
            {
              \u003CModule\u003E.delete((void*) d3DxextendedframePtr8);
            }
            d3DxextendedframePtr1 = d3DxextendedframePtr9;
            helpers = d3DxextendedframePtr9;
          }
          int hpntString = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EFindHPNTString(obj0, (uint) *(int*) (num6 + *(long*) ((IntPtr) obj0 + 59L)));
          sbyte* src = (sbyte*) \u003CModule\u003E.new\u005B\u005D(1024UL /*0x0400*/);
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) src, ref \u003CModule\u003E.\u003F\u003F_C\u0040_05LIHIPBGP\u0040HPNT_\u003F\u0024AA\u0040, 6);
          if (hpntString > -1)
          {
            long num7 = *(long*) ((long) hpntString * 8L + *(long*) ((IntPtr) obj0 + 77L));
            sbyte* numPtr = src + 5L;
            sbyte num8;
            do
            {
              num8 = *(sbyte*) num7;
              *numPtr = num8;
              ++num7;
              ++numPtr;
            }
            while (num8 != (sbyte) 0);
          }
          else
          {
            // ISSUE: cpblk instruction
            __memcpy((IntPtr) (src + 5L), ref \u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040POPMPNFF\u0040NAME_NOT_FOUND\u003F\u0024AA\u0040, 15);
          }
          *(long*) d3DxextendedframePtr1 = (long) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECopyXFileSafeString(src);
          \u003CModule\u003E.delete\u005B\u005D((void*) src);
          D3DXMATRIX d3Dxmatrix3;
          \u003CModule\u003E.D3DXMatrixInverse(&d3Dxmatrix3, (float*) 0L, parentTransform);
          HPNT* hpntPtr = (HPNT*) (num6 + *(long*) ((IntPtr) obj0 + 59L));
          \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040M arrayTypeBy0BaM;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ref arrayTypeBy0BaM = 1f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 4) = 0.0f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 8) = 0.0f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 12) = 0.0f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 16 /*0x10*/) = 0.0f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 20) = 1f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 24) = 0.0f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 28) = 0.0f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 32 /*0x20*/) = 0.0f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 36) = 0.0f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 40) = 1f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 44) = 0.0f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 60) = 1f;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 48 /*0x30*/) = *(float*) ((IntPtr) hpntPtr + 4L);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 52) = *(float*) ((IntPtr) hpntPtr + 8L);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(float&) ((IntPtr) &arrayTypeBy0BaM + 56) = *(float*) ((IntPtr) hpntPtr + 12L);
          D3DXMATRIX d3Dxmatrix4 = (D3DXMATRIX) arrayTypeBy0BaM;
          \u003CModule\u003E.D3DXMatrixMultiply((D3DXMATRIX*) ((IntPtr) d3DxextendedframePtr1 + 8L), &d3Dxmatrix4, &d3Dxmatrix3);
        }
        ++num5;
        num6 += 20L;
      }
      while (num5 < (int) *(ushort*) ((IntPtr) obj0 + 49L));
    }
    return helpers;
  }

  internal static unsafe MTRL* FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EAddMaterial(
    [In] CompiledModel* obj0,
    uint id)
  {
    int num1 = 0;
    uint num2 = (uint) *(int*) ((IntPtr) obj0 + 95L);
    if (0U < num2)
    {
      long num3 = *(long*) ((IntPtr) obj0 + 204L);
      while (*(int*) num3 != (int) id)
      {
        ++num1;
        num3 += 45L;
        if ((uint) num1 >= (uint) *(int*) ((IntPtr) obj0 + 95L))
          goto label_5;
      }
      Console.WriteLine("add duplicate material");
      return (MTRL*) 0L;
    }
label_5:
    ulong num4 = (ulong) (num2 + 1U);
    ulong num5;
    if (num4 <= 409927646082434480UL /*0x05B05B05B05B05B0*/)
    {
      ulong num6 = num4 * 45UL;
      if (num6 <= 18446744073709551611UL)
      {
        num5 = num6 + 4UL;
        goto label_9;
      }
    }
    num5 = ulong.MaxValue;
label_9:
    MTRL* mtrlPtr1 = (MTRL*) \u003CModule\u003E.new\u005B\u005D(num5);
    MTRL* mtrlPtr2;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) mtrlPtr1 != IntPtr.Zero)
      {
        uint count = (uint) num4;
        *(int*) mtrlPtr1 = (int) count;
        MTRL* ptr = (MTRL*) ((IntPtr) mtrlPtr1 + 4L);
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.__ehvec_ctor((void*) ptr, 45UL, (int) count, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002EIntegration\u002EMTRL\u002E\u007Bctor\u007D), (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002EIntegration\u002EMTRL\u002E\u007Bdtor\u007D));
        mtrlPtr2 = ptr;
      }
      else
        mtrlPtr2 = (MTRL*) 0L;
    }
    __fault
    {
      \u003CModule\u003E.delete\u005B\u005D((void*) mtrlPtr1);
    }
    // ISSUE: initblk instruction
    __memset((IntPtr) mtrlPtr2, 0, (long) (uint) (*(int*) ((IntPtr) obj0 + 95L) + 1) * 45L);
    long num7 = *(long*) ((IntPtr) obj0 + 204L);
    if (num7 != 0L)
    {
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) mtrlPtr2, num7, (long) (uint) *(int*) ((IntPtr) obj0 + 95L) * 45L);
      MTRL* ptr = (MTRL*) *(long*) ((IntPtr) obj0 + 204L);
      if ((IntPtr) ptr != IntPtr.Zero)
      {
        MTRL* mtrlPtr3 = (MTRL*) ((IntPtr) ptr - 4L);
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.__ehvec_dtor((void*) ptr, 45UL, *(int*) mtrlPtr3, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002EIntegration\u002EMTRL\u002E\u007Bdtor\u007D));
        \u003CModule\u003E.delete\u005B\u005D((void*) mtrlPtr3);
      }
    }
    *(int*) ((IntPtr) obj0 + 95L) = *(int*) ((IntPtr) obj0 + 95L) + 1;
    int num8 = *(int*) ((IntPtr) obj0 + 95L);
    *(long*) ((IntPtr) obj0 + 204L) = (long) mtrlPtr2;
    *(int*) ((long) (uint) (num8 - 1) * 45L + (IntPtr) mtrlPtr2) = (int) id;
    return (MTRL*) ((long) (uint) (*(int*) ((IntPtr) obj0 + 95L) - 1) * 45L + *(long*) ((IntPtr) obj0 + 204L));
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002ERemoveMaterial(
    [In] CompiledModel* obj0,
    uint id)
  {
    int num1 = 0;
    if (0U >= (uint) *(int*) ((IntPtr) obj0 + 95L))
      return;
    long num2 = 0;
    do
    {
      if (*(int*) (*(long*) ((IntPtr) obj0 + 204L) + num2) == (int) id)
      {
        *(int*) ((IntPtr) obj0 + 95L) = *(int*) ((IntPtr) obj0 + 95L) - 1;
        ulong num3 = (ulong) (uint) *(int*) ((IntPtr) obj0 + 95L);
        ulong num4;
        if (num3 <= 409927646082434480UL /*0x05B05B05B05B05B0*/)
        {
          ulong num5 = num3 * 45UL;
          if (num5 <= 18446744073709551611UL)
          {
            num4 = num5 + 4UL;
            goto label_7;
          }
        }
        num4 = ulong.MaxValue;
label_7:
        MTRL* mtrlPtr1 = (MTRL*) \u003CModule\u003E.new\u005B\u005D(num4);
        MTRL* mtrlPtr2;
        // ISSUE: fault handler
        try
        {
          if ((IntPtr) mtrlPtr1 != IntPtr.Zero)
          {
            uint count = (uint) num3;
            *(int*) mtrlPtr1 = (int) count;
            MTRL* ptr = (MTRL*) ((IntPtr) mtrlPtr1 + 4L);
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.__ehvec_ctor((void*) ptr, 45UL, (int) count, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002EIntegration\u002EMTRL\u002E\u007Bctor\u007D), (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002EIntegration\u002EMTRL\u002E\u007Bdtor\u007D));
            mtrlPtr2 = ptr;
          }
          else
            mtrlPtr2 = (MTRL*) 0L;
        }
        __fault
        {
          \u003CModule\u003E.delete\u005B\u005D((void*) mtrlPtr1);
        }
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) mtrlPtr2, *(long*) ((IntPtr) obj0 + 204L), (long) num1 * 45L);
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) mtrlPtr2, ((long) num1 + 1L) * 45L + *(long*) ((IntPtr) obj0 + 204L), (long) (uint) (*(int*) ((IntPtr) obj0 + 95L) - num1) * 45L);
        MTRL* ptr1 = (MTRL*) *(long*) ((IntPtr) obj0 + 204L);
        if ((IntPtr) ptr1 != IntPtr.Zero)
        {
          MTRL* mtrlPtr3 = (MTRL*) ((IntPtr) ptr1 - 4L);
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.__ehvec_dtor((void*) ptr1, 45UL, *(int*) mtrlPtr3, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002EIntegration\u002EMTRL\u002E\u007Bdtor\u007D));
          \u003CModule\u003E.delete\u005B\u005D((void*) mtrlPtr3);
        }
        *(long*) ((IntPtr) obj0 + 204L) = (long) mtrlPtr2;
      }
      ++num1;
      num2 += 45L;
    }
    while ((uint) num1 < (uint) *(int*) ((IntPtr) obj0 + 95L));
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EDestroyMaterials(
    [In] CompiledModel* obj0)
  {
    int num1 = 0;
    if (0U < (uint) *(int*) ((IntPtr) obj0 + 95L))
    {
      CompiledModel* compiledModelPtr = (CompiledModel*) ((IntPtr) obj0 + 204L);
      long num2 = 0;
      do
      {
        \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) (*(long*) compiledModelPtr + num2 + 4L));
        ++num1;
        num2 += 45L;
      }
      while ((uint) num1 < (uint) *(int*) ((IntPtr) obj0 + 95L));
    }
    long num3 = *(long*) ((IntPtr) obj0 + 204L);
    if (num3 != 0L)
    {
      MTRL* ptr = (MTRL*) num3;
      MTRL* mtrlPtr = (MTRL*) ((IntPtr) ptr - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ptr, 45UL, *(int*) mtrlPtr, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002EIntegration\u002EMTRL\u002E\u007Bdtor\u007D));
      \u003CModule\u003E.delete\u005B\u005D((void*) mtrlPtr);
      *(long*) ((IntPtr) obj0 + 204L) = 0L;
    }
    *(int*) ((IntPtr) obj0 + 95L) = 0;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EClearSubMeshes(
    [In] CompiledModel* obj0)
  {
    if (*(long*) ((IntPtr) obj0 + 212L) == 0L)
      return;
    int num1 = 0;
    if (0U < (uint) *(int*) ((IntPtr) obj0 + 99L))
    {
      long num2 = 0;
      do
      {
        SUBM* submPtr = (SUBM*) *(long*) (num2 + *(long*) ((IntPtr) obj0 + 212L));
        if ((IntPtr) submPtr != IntPtr.Zero)
        {
          \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ESUBM\u002E\u007Bdtor\u007D(submPtr);
          \u003CModule\u003E.delete((void*) submPtr);
        }
        ++num1;
        num2 += 8L;
      }
      while ((uint) num1 < (uint) *(int*) ((IntPtr) obj0 + 99L));
    }
    \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 212L));
    *(long*) ((IntPtr) obj0 + 212L) = 0L;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EDestroySubMeshes(
    [In] CompiledModel* obj0)
  {
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EClearSubMeshes(obj0);
    *(int*) ((IntPtr) obj0 + 99L) = 0;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EClearHelpers(
    [In] CompiledModel* obj0)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 59L);
    if (num1 != 0UL)
    {
      \u003CModule\u003E.delete\u005B\u005D((void*) num1);
      *(long*) ((IntPtr) obj0 + 59L) = 0L;
    }
    ulong num2 = (ulong) *(long*) ((IntPtr) obj0 + 67L);
    if (num2 != 0UL)
    {
      \u003CModule\u003E.delete\u005B\u005D((void*) num2);
      *(long*) ((IntPtr) obj0 + 67L) = 0L;
    }
    if (*(long*) ((IntPtr) obj0 + 77L) != 0L)
    {
      ushort num3 = 0;
      if ((ushort) 0 < *(ushort*) ((IntPtr) obj0 + 75L))
      {
        do
        {
          \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((long) num3 * 8L + *(long*) ((IntPtr) obj0 + 77L)));
          ++num3;
        }
        while ((uint) num3 < (uint) *(ushort*) ((IntPtr) obj0 + 75L));
      }
      \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 77L));
      *(long*) ((IntPtr) obj0 + 77L) = 0L;
    }
    if (*(long*) ((IntPtr) obj0 + 87L) == 0L)
      return;
    ushort num4 = 0;
    if ((ushort) 0 < *(ushort*) ((IntPtr) obj0 + 85L))
    {
      do
      {
        \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((long) num4 * 8L + *(long*) ((IntPtr) obj0 + 87L)));
        ++num4;
      }
      while ((uint) num4 < (uint) *(ushort*) ((IntPtr) obj0 + 85L));
    }
    \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 87L));
    *(long*) ((IntPtr) obj0 + 87L) = 0L;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EDestroyHelpers(
    [In] CompiledModel* obj0)
  {
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EClearHelpers(obj0);
    *(short*) ((IntPtr) obj0 + 75L) = (short) 0;
    *(short*) ((IntPtr) obj0 + 85L) = (short) 0;
    *(int*) ((IntPtr) obj0 + 53L) = 0;
    *(short*) ((IntPtr) obj0 + 49L) = (short) 0;
    *(short*) ((IntPtr) obj0 + 51L) = (short) 0;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EClearBones(
    [In] CompiledModel* obj0)
  {
    int num1 = 0;
    if (0U < (uint) *(int*) ((IntPtr) obj0 + 103L))
    {
      CompiledModel* compiledModelPtr = (CompiledModel*) ((IntPtr) obj0 + 124L);
      long num2 = 0;
      do
      {
        \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) (*(long*) compiledModelPtr + num2));
        ++num1;
        num2 += 8L;
      }
      while ((uint) num1 < (uint) *(int*) ((IntPtr) obj0 + 103L));
    }
    \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 124L));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 132L));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 140L));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 148L));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 116L));
    *(long*) ((IntPtr) obj0 + 124L) = 0L;
    *(long*) ((IntPtr) obj0 + 132L) = 0L;
    *(long*) ((IntPtr) obj0 + 140L) = 0L;
    *(long*) ((IntPtr) obj0 + 148L) = 0L;
    *(long*) ((IntPtr) obj0 + 116L) = 0L;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EDestroyBones(
    [In] CompiledModel* obj0)
  {
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EClearBones(obj0);
    *(int*) ((IntPtr) obj0 + 103L) = 0;
    *(int*) ((IntPtr) obj0 + 107L) = 0;
    *(sbyte*) ((IntPtr) obj0 + 8L) = (sbyte) 0;
  }

  internal static unsafe int FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EAddBone(
    [In] CompiledModel* obj0,
    sbyte* bonename)
  {
    BONE_SUB_CHUNK_1* boneSubChunk1Ptr = (BONE_SUB_CHUNK_1*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) (*(int*) ((IntPtr) obj0 + 103L) + 1) * 60UL);
    BONE_SUB_CHUNK_2* boneSubChunk2Ptr = (BONE_SUB_CHUNK_2*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) (*(int*) ((IntPtr) obj0 + 103L) + 1) * 48UL /*0x30*/);
    BONE_SUB_CHUNK_3* boneSubChunk3Ptr = (BONE_SUB_CHUNK_3*) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) (*(int*) ((IntPtr) obj0 + 103L) + 1) * 64UL /*0x40*/);
    // ISSUE: initblk instruction
    __memset((IntPtr) boneSubChunk1Ptr, 0, (long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 60L);
    // ISSUE: initblk instruction
    __memset((IntPtr) boneSubChunk2Ptr, 0, (long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 48L /*0x30*/);
    // ISSUE: initblk instruction
    __memset((IntPtr) boneSubChunk3Ptr, 0, (long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 64L /*0x40*/);
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 132L);
    if (num1 != 0UL)
    {
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) boneSubChunk1Ptr, (long) num1, (long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 60L);
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) boneSubChunk2Ptr, *(long*) ((IntPtr) obj0 + 140L), (long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 48L /*0x30*/);
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) boneSubChunk3Ptr, *(long*) ((IntPtr) obj0 + 148L), (long) (uint) *(int*) ((IntPtr) obj0 + 103L) * 64L /*0x40*/);
      \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 132L));
      \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 140L));
      \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 148L));
    }
    *(int*) ((IntPtr) obj0 + 103L) = *(int*) ((IntPtr) obj0 + 103L) + 1;
    *(long*) ((IntPtr) obj0 + 132L) = (long) boneSubChunk1Ptr;
    *(long*) ((IntPtr) obj0 + 140L) = (long) boneSubChunk2Ptr;
    *(long*) ((IntPtr) obj0 + 148L) = (long) boneSubChunk3Ptr;
    sbyte* numPtr1 = bonename;
    if (*bonename != (sbyte) 0)
    {
      do
      {
        ++numPtr1;
      }
      while (*numPtr1 != (sbyte) 0);
    }
    long count = (long) ((IntPtr) numPtr1 - (IntPtr) bonename);
    *(int*) ((long) (uint) (*(int*) ((IntPtr) obj0 + 103L) - 1) * 60L + *(long*) ((IntPtr) obj0 + 132L)) = -1 - (int) ZLib.CRC32(uint.MaxValue, (void*) bonename, (int) count);
    sbyte** numPtr2 = (sbyte**) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) obj0 + 103L) * 8UL);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) numPtr2, *(long*) ((IntPtr) obj0 + 124L), (long) (uint) (*(int*) ((IntPtr) obj0 + 103L) - 1) * 8L);
    long num2 = *(long*) ((IntPtr) obj0 + 124L);
    if (num2 != 0L)
      \u003CModule\u003E.delete((void*) num2);
    *(long*) ((IntPtr) obj0 + 124L) = (long) numPtr2;
    sbyte* numPtr3 = bonename;
    if (*bonename != (sbyte) 0)
    {
      do
      {
        ++numPtr3;
      }
      while (*numPtr3 != (sbyte) 0);
    }
    sbyte* numPtr4 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) ((IntPtr) numPtr3 - (IntPtr) bonename + 1L));
    *(long*) ((long) (uint) (*(int*) ((IntPtr) obj0 + 103L) - 1) * 8L + *(long*) ((IntPtr) obj0 + 124L)) = (long) numPtr4;
    sbyte* numPtr5 = bonename;
    long num3 = *(long*) ((long) (uint) (*(int*) ((IntPtr) obj0 + 103L) - 1) * 8L + *(long*) ((IntPtr) obj0 + 124L));
    sbyte num4;
    do
    {
      num4 = *numPtr5;
      *(sbyte*) num3 = num4;
      ++numPtr5;
      ++num3;
    }
    while (num4 != (sbyte) 0);
    return *(int*) ((IntPtr) obj0 + 103L) - 1;
  }

  internal static unsafe SUBM* FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EAddSubMesh(
    [In] CompiledModel* obj0)
  {
    SUBM** submPtr1 = (SUBM**) \u003CModule\u003E.new\u005B\u005D((ulong) (uint) (*(int*) ((IntPtr) obj0 + 99L) + 1) * 8UL);
    ulong num = (ulong) *(long*) ((IntPtr) obj0 + 212L);
    if (num != 0UL)
    {
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) submPtr1, (long) num, (long) (uint) *(int*) ((IntPtr) obj0 + 99L) * 8L);
      \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 212L));
    }
    *(int*) ((IntPtr) obj0 + 99L) = *(int*) ((IntPtr) obj0 + 99L) + 1;
    *(long*) ((IntPtr) obj0 + 212L) = (long) submPtr1;
    SUBM* submPtr2 = (SUBM*) \u003CModule\u003E.@new(144UL /*0x90*/);
    SUBM* submPtr3;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) submPtr2 != IntPtr.Zero)
      {
        // ISSUE: initblk instruction
        __memset((IntPtr) submPtr2, 0, 144 /*0x90*/);
        submPtr3 = submPtr2;
      }
      else
        submPtr3 = (SUBM*) 0L;
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) submPtr2);
    }
    *(long*) ((long) (uint) (*(int*) ((IntPtr) obj0 + 99L) - 1) * 8L + *(long*) ((IntPtr) obj0 + 212L)) = (long) submPtr3;
    return (SUBM*) *(long*) ((long) (uint) (*(int*) ((IntPtr) obj0 + 99L) - 1) * 8L + *(long*) ((IntPtr) obj0 + 212L));
  }

  internal static unsafe int FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EFindHPNTString(
    [In] CompiledModel* obj0,
    uint crc)
  {
    int hpntString = 0;
    if ((ushort) 0 < *(ushort*) ((IntPtr) obj0 + 75L))
    {
      CompiledModel* compiledModelPtr = (CompiledModel*) ((IntPtr) obj0 + 77L);
      long num1 = 0;
      do
      {
        long src = *(long*) (*(long*) compiledModelPtr + num1);
        long num2 = src;
        long num3 = num2;
        if (*(sbyte*) num2 != (sbyte) 0)
        {
          do
          {
            ++num3;
          }
          while (*(sbyte*) num3 != (sbyte) 0);
        }
        ulong count = (ulong) (num3 - num2);
        if (-1 - (int) ZLib.CRC32(uint.MaxValue, (void*) src, (int) count) != (int) crc)
        {
          ++hpntString;
          num1 += 8L;
        }
        else
          goto label_6;
      }
      while (hpntString < (int) *(ushort*) ((IntPtr) obj0 + 75L));
      goto label_7;
label_6:
      return hpntString;
    }
label_7:
    return -1;
  }

  internal static unsafe int FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EFindHDMYString(
    [In] CompiledModel* obj0,
    uint crc)
  {
    int hdmyString = 0;
    if ((ushort) 0 < *(ushort*) ((IntPtr) obj0 + 85L))
    {
      CompiledModel* compiledModelPtr = (CompiledModel*) ((IntPtr) obj0 + 87L);
      long num1 = 0;
      do
      {
        long src = *(long*) (*(long*) compiledModelPtr + num1);
        long num2 = src;
        long num3 = num2;
        if (*(sbyte*) num2 != (sbyte) 0)
        {
          do
          {
            ++num3;
          }
          while (*(sbyte*) num3 != (sbyte) 0);
        }
        ulong count = (ulong) (num3 - num2);
        if (-1 - (int) ZLib.CRC32(uint.MaxValue, (void*) src, (int) count) != (int) crc)
        {
          ++hdmyString;
          num1 += 8L;
        }
        else
          goto label_6;
      }
      while (hdmyString < (int) *(ushort*) ((IntPtr) obj0 + 85L));
      goto label_7;
label_6:
      return hdmyString;
    }
label_7:
    return -1;
  }

  internal static unsafe int FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EFindBone(
    [In] CompiledModel* obj0,
    uint crc)
  {
    int bone = 0;
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 103L);
    if (0U < num1)
    {
      long num2 = *(long*) ((IntPtr) obj0 + 132L);
      while (*(int*) num2 != (int) crc)
      {
        ++bone;
        num2 += 60L;
        if ((uint) bone >= num1)
          goto label_5;
      }
      return bone;
    }
label_5:
    return -1;
  }

  internal static unsafe uint FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EAddHPNTString(
    [In] CompiledModel* obj0,
    sbyte* name)
  {
    ushort num1 = (ushort) ((int) *(ushort*) ((IntPtr) obj0 + 75L) + 1);
    *(short*) ((IntPtr) obj0 + 75L) = (short) num1;
    sbyte** numPtr1 = (sbyte**) \u003CModule\u003E.new\u005B\u005D((ulong) num1 * 8UL);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) numPtr1, *(long*) ((IntPtr) obj0 + 77L), (long) ((int) *(ushort*) ((IntPtr) obj0 + 75L) - 1) * 8L);
    long num2 = *(long*) ((IntPtr) obj0 + 77L);
    if (num2 != 0L)
      \u003CModule\u003E.delete((void*) num2);
    *(long*) ((IntPtr) obj0 + 77L) = (long) numPtr1;
    sbyte* numPtr2 = name;
    if (*name != (sbyte) 0)
    {
      do
      {
        ++numPtr2;
      }
      while (*numPtr2 != (sbyte) 0);
    }
    sbyte* numPtr3 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) ((IntPtr) numPtr2 - (IntPtr) name + 1L));
    *(long*) (*(long*) ((IntPtr) obj0 + 77L) + (long) *(ushort*) ((IntPtr) obj0 + 75L) * 8L - 8L) = (long) numPtr3;
    sbyte* numPtr4 = name;
    long num3 = *(long*) (*(long*) ((IntPtr) obj0 + 77L) + (long) *(ushort*) ((IntPtr) obj0 + 75L) * 8L - 8L);
    sbyte num4;
    do
    {
      num4 = *numPtr4;
      *(sbyte*) num3 = num4;
      ++numPtr4;
      ++num3;
    }
    while (num4 != (sbyte) 0);
    int num5 = (int) *(ushort*) ((IntPtr) obj0 + 75L) - 1;
    if (num5 > 0)
    {
      do
      {
        int num6 = 1;
        long num7 = 0;
        long num8 = (long) num5;
        if (num8 > 0L)
        {
          do
          {
            long num9 = num7 * 8L;
            long num10 = num9 + *(long*) ((IntPtr) obj0 + 77L);
            long num11 = *(long*) (num10 + 8L);
            long num12 = num11;
            long num13 = *(long*) num10;
            sbyte num14 = *(sbyte*) num13;
            sbyte num15 = *(sbyte*) num12;
            if ((int) num14 >= (int) num15)
            {
              long num16 = num13 - num11;
              while ((int) num14 <= (int) num15)
              {
                if (num14 != (sbyte) 0)
                {
                  ++num12;
                  num14 = *(sbyte*) (num16 + num12);
                  num15 = *(sbyte*) num12;
                  if ((int) num14 < (int) num15)
                    goto label_14;
                }
                else
                  goto label_14;
              }
              num6 = 0;
              sbyte* numPtr5 = (sbyte*) *(long*) num10;
              *(long*) num10 = num11;
              *(long*) (*(long*) ((IntPtr) obj0 + 77L) + num9 + 8L) = (long) numPtr5;
            }
label_14:
            ++num7;
          }
          while (num7 < num8);
          if (num6 == 0)
            num5 += -1;
          else
            break;
        }
        else
          break;
      }
      while (num5 > 0);
    }
    sbyte* numPtr6 = name;
    if (*name != (sbyte) 0)
    {
      do
      {
        ++numPtr6;
      }
      while (*numPtr6 != (sbyte) 0);
    }
    long count = (long) ((IntPtr) numPtr6 - (IntPtr) name);
    return uint.MaxValue - ZLib.CRC32(uint.MaxValue, (void*) name, (int) count);
  }

  internal static unsafe uint FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EAddHDMYString(
    [In] CompiledModel* obj0,
    sbyte* name)
  {
    ushort num1 = (ushort) ((int) *(ushort*) ((IntPtr) obj0 + 85L) + 1);
    *(short*) ((IntPtr) obj0 + 85L) = (short) num1;
    sbyte** numPtr1 = (sbyte**) \u003CModule\u003E.new\u005B\u005D((ulong) num1 * 8UL);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) numPtr1, *(long*) ((IntPtr) obj0 + 87L), (long) ((int) *(ushort*) ((IntPtr) obj0 + 85L) - 1) * 8L);
    long num2 = *(long*) ((IntPtr) obj0 + 87L);
    if (num2 != 0L)
      \u003CModule\u003E.delete((void*) num2);
    *(long*) ((IntPtr) obj0 + 87L) = (long) numPtr1;
    sbyte* numPtr2 = name;
    if (*name != (sbyte) 0)
    {
      do
      {
        ++numPtr2;
      }
      while (*numPtr2 != (sbyte) 0);
    }
    sbyte* numPtr3 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) ((IntPtr) numPtr2 - (IntPtr) name + 1L));
    *(long*) (*(long*) ((IntPtr) obj0 + 87L) + (long) *(ushort*) ((IntPtr) obj0 + 85L) * 8L - 8L) = (long) numPtr3;
    sbyte* numPtr4 = name;
    long num3 = *(long*) (*(long*) ((IntPtr) obj0 + 87L) + (long) *(ushort*) ((IntPtr) obj0 + 85L) * 8L - 8L);
    sbyte num4;
    do
    {
      num4 = *numPtr4;
      *(sbyte*) num3 = num4;
      ++numPtr4;
      ++num3;
    }
    while (num4 != (sbyte) 0);
    int num5 = (int) *(ushort*) ((IntPtr) obj0 + 85L) - 1;
    if (num5 > 0)
    {
      do
      {
        int num6 = 1;
        long num7 = 0;
        long num8 = (long) num5;
        if (num8 > 0L)
        {
          do
          {
            long num9 = num7 * 8L;
            long num10 = num9 + *(long*) ((IntPtr) obj0 + 87L);
            long num11 = *(long*) (num10 + 8L);
            long num12 = num11;
            long num13 = *(long*) num10;
            sbyte num14 = *(sbyte*) num13;
            sbyte num15 = *(sbyte*) num12;
            if ((int) num14 >= (int) num15)
            {
              long num16 = num13 - num11;
              while ((int) num14 <= (int) num15)
              {
                if (num14 != (sbyte) 0)
                {
                  ++num12;
                  num14 = *(sbyte*) (num16 + num12);
                  num15 = *(sbyte*) num12;
                  if ((int) num14 < (int) num15)
                    goto label_14;
                }
                else
                  goto label_14;
              }
              num6 = 0;
              sbyte* numPtr5 = (sbyte*) *(long*) num10;
              *(long*) num10 = num11;
              *(long*) (*(long*) ((IntPtr) obj0 + 87L) + num9 + 8L) = (long) numPtr5;
            }
label_14:
            ++num7;
          }
          while (num7 < num8);
          if (num6 == 0)
            num5 += -1;
          else
            break;
        }
        else
          break;
      }
      while (num5 > 0);
    }
    sbyte* numPtr6 = name;
    if (*name != (sbyte) 0)
    {
      do
      {
        ++numPtr6;
      }
      while (*numPtr6 != (sbyte) 0);
    }
    long count = (long) ((IntPtr) numPtr6 - (IntPtr) name);
    return uint.MaxValue - ZLib.CRC32(uint.MaxValue, (void*) name, (int) count);
  }

  internal static unsafe HPNT* FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EAddHPNT(
    [In] CompiledModel* obj0,
    sbyte* name)
  {
    ushort num1 = (ushort) ((int) *(ushort*) ((IntPtr) obj0 + 49L) + 1);
    *(short*) ((IntPtr) obj0 + 49L) = (short) num1;
    HPNT* hpntPtr = (HPNT*) \u003CModule\u003E.new\u005B\u005D((ulong) num1 * 20UL);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) hpntPtr, *(long*) ((IntPtr) obj0 + 59L), (long) ((int) *(ushort*) ((IntPtr) obj0 + 49L) - 1) * 20L);
    long num2 = *(long*) ((IntPtr) obj0 + 59L);
    if (num2 != 0L)
      \u003CModule\u003E.delete((void*) num2);
    *(long*) ((IntPtr) obj0 + 59L) = (long) hpntPtr;
    sbyte* numPtr = name;
    if (*name != (sbyte) 0)
    {
      do
      {
        ++numPtr;
      }
      while (*numPtr != (sbyte) 0);
    }
    long count = (long) ((IntPtr) numPtr - (IntPtr) name);
    uint crc = uint.MaxValue - ZLib.CRC32(uint.MaxValue, (void*) name, (int) count);
    if (\u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EFindHPNTString(obj0, crc) == -1)
    {
      int num3 = (int) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EAddHPNTString(obj0, name);
    }
    *(int*) (*(long*) ((IntPtr) obj0 + 59L) + (long) *(ushort*) ((IntPtr) obj0 + 49L) * 20L - 20L) = (int) crc;
    int num4 = (int) *(ushort*) ((IntPtr) obj0 + 49L) - 1;
    int num5 = num4;
    int num6 = num4;
    if (num6 > 0)
    {
      do
      {
        int num7 = 1;
        int num8 = 0;
        long num9 = (long) num6;
        if (num9 > 0L)
        {
          long num10 = 0;
          ulong num11 = (ulong) num9;
          do
          {
            long num12 = num10 + *(long*) ((IntPtr) obj0 + 59L);
            if ((uint) *(int*) num12 > (uint) *(int*) (num12 + 20L))
            {
              num7 = 0;
              HPNT hpnt;
              // ISSUE: cpblk instruction
              __memcpy(ref hpnt, num12, 20);
              long num13 = num12;
              // ISSUE: cpblk instruction
              __memcpy(num13, num13 + 20L, 20);
              // ISSUE: cpblk instruction
              __memcpy(*(long*) ((IntPtr) obj0 + 59L) + num10 + 20L, ref hpnt, 20);
              if (num5 == num8)
                ++num5;
              else if (num5 == num8 + 1)
                num5 += -1;
            }
            ++num8;
            num10 += 20L;
            --num11;
          }
          while (num11 > 0UL);
          if (num7 == 0)
            num6 += -1;
          else
            break;
        }
        else
          break;
      }
      while (num6 > 0);
    }
    return (HPNT*) ((long) num5 * 20L + *(long*) ((IntPtr) obj0 + 59L));
  }

  internal static unsafe HDMY* FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EAddHDMY(
    [In] CompiledModel* obj0,
    sbyte* name)
  {
    ushort num1 = (ushort) ((int) *(ushort*) ((IntPtr) obj0 + 51L) + 1);
    *(short*) ((IntPtr) obj0 + 51L) = (short) num1;
    HDMY* hdmyPtr = (HDMY*) \u003CModule\u003E.new\u005B\u005D((ulong) num1 * 56UL);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) hdmyPtr, *(long*) ((IntPtr) obj0 + 67L), (long) ((int) *(ushort*) ((IntPtr) obj0 + 51L) - 1) * 56L);
    long num2 = *(long*) ((IntPtr) obj0 + 67L);
    if (num2 != 0L)
      \u003CModule\u003E.delete((void*) num2);
    *(long*) ((IntPtr) obj0 + 67L) = (long) hdmyPtr;
    sbyte* numPtr = name;
    if (*name != (sbyte) 0)
    {
      do
      {
        ++numPtr;
      }
      while (*numPtr != (sbyte) 0);
    }
    long count = (long) ((IntPtr) numPtr - (IntPtr) name);
    uint crc = uint.MaxValue - ZLib.CRC32(uint.MaxValue, (void*) name, (int) count);
    if (\u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EFindHDMYString(obj0, crc) == -1)
    {
      int num3 = (int) \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECompiledModel\u002EAddHDMYString(obj0, name);
    }
    *(int*) (*(long*) ((IntPtr) obj0 + 67L) + (long) *(ushort*) ((IntPtr) obj0 + 51L) * 56L - 56L) = (int) crc;
    int num4 = (int) *(ushort*) ((IntPtr) obj0 + 51L) - 1;
    int num5 = num4;
    int num6 = num4;
    if (num6 > 0)
    {
      do
      {
        int num7 = 1;
        int num8 = 0;
        long num9 = (long) num6;
        if (num9 > 0L)
        {
          long num10 = 0;
          ulong num11 = (ulong) num9;
          do
          {
            long num12 = num10 + *(long*) ((IntPtr) obj0 + 67L);
            if ((uint) *(int*) num12 > (uint) *(int*) (num12 + 56L))
            {
              num7 = 0;
              HDMY hdmy;
              // ISSUE: cpblk instruction
              __memcpy(ref hdmy, num12, 56);
              long num13 = num12;
              // ISSUE: cpblk instruction
              __memcpy(num13, num13 + 56L, 56);
              // ISSUE: cpblk instruction
              __memcpy(*(long*) ((IntPtr) obj0 + 67L) + num10 + 56L, ref hdmy, 56);
              if (num5 == num8)
                ++num5;
              else if (num5 == num8 + 1)
                num5 += -1;
            }
            ++num8;
            num10 += 56L;
            --num11;
          }
          while (num11 > 0UL);
          if (num7 == 0)
            num6 += -1;
          else
            break;
        }
        else
          break;
      }
      while (num6 > 0);
    }
    return (HDMY*) ((long) num5 * 56L + *(long*) ((IntPtr) obj0 + 67L));
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002EDestroy(
    [In] D3DXEXTENDEDFRAME* obj0)
  {
    ulong num1 = (ulong) *(long*) obj0;
    if (num1 != 0UL)
    {
      \u003CModule\u003E.delete\u005B\u005D((void*) num1);
      *(long*) obj0 = 0L;
    }
    ulong num2 = (ulong) *(long*) ((IntPtr) obj0 + 72L);
    if (num2 != 0UL)
    {
      if (*(long*) ((long) num2 + 24L) != 0L)
      {
        int num3 = 0;
        if (0U < (uint) *(int*) ((long) num2 + 40L))
        {
          long num4 = 0;
          do
          {
            ulong num5 = (ulong) *(long*) (num4 + *(long*) (*(long*) ((IntPtr) obj0 + 72L) + 24L) + 72L);
            if (num5 != 0UL)
            {
              \u003CModule\u003E.delete\u005B\u005D((void*) num5);
              *(long*) (num4 + *(long*) (*(long*) ((IntPtr) obj0 + 72L) + 24L) + 72L) = 0L;
            }
            ++num3;
            num4 += 80L /*0x50*/;
          }
          while ((uint) num3 < (uint) *(int*) (*(long*) ((IntPtr) obj0 + 72L) + 40L));
        }
        \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) (*(long*) ((IntPtr) obj0 + 72L) + 24L));
      }
      long num6 = *(long*) ((IntPtr) obj0 + 72L) + 16L /*0x10*/;
      if (*(long*) num6 != 0L)
      {
        long num7 = *(long*) num6;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num8 = (int) __calli((__FnPtr<uint (IntPtr)>) *(long*) (*(long*) num7 + 16L /*0x10*/))((IntPtr) num7);
        *(long*) (*(long*) ((IntPtr) obj0 + 72L) + 16L /*0x10*/) = 0L;
      }
      ulong num9 = (ulong) *(long*) ((IntPtr) obj0 + 72L);
      if (*(long*) num9 != 0L)
      {
        \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) num9);
        *(long*) *(long*) ((IntPtr) obj0 + 72L) = 0L;
      }
      long num10 = *(long*) ((IntPtr) obj0 + 72L) + 56L;
      if (*(long*) num10 != 0L)
      {
        long num11 = *(long*) num10;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num12 = (int) __calli((__FnPtr<uint (IntPtr)>) *(long*) (*(long*) num11 + 16L /*0x10*/))((IntPtr) num11);
        *(long*) (*(long*) ((IntPtr) obj0 + 72L) + 56L) = 0L;
      }
      \u003CModule\u003E.delete((void*) *(long*) ((IntPtr) obj0 + 72L));
      *(long*) ((IntPtr) obj0 + 72L) = 0L;
    }
    ulong num13 = (ulong) *(long*) ((IntPtr) obj0 + 96L /*0x60*/);
    if (num13 != 0UL)
    {
      long num14 = (long) num13;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num15 = (int) __calli((__FnPtr<uint (IntPtr)>) *(long*) (*(long*) num14 + 16L /*0x10*/))((IntPtr) num14);
      *(long*) ((IntPtr) obj0 + 96L /*0x60*/) = 0L;
    }
    ulong num16 = (ulong) *(long*) ((IntPtr) obj0 + 104L + 8L);
    if (num16 != 0UL)
    {
      RootObject* rootObjectPtr = (RootObject*) num16;
      uint num17 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
      if (num17 > 0U)
        *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num17 - 1;
      if (*(int*) ((IntPtr) rootObjectPtr + 8L) == 0)
      {
        Texture* texturePtr1 = (Texture*) *(long*) ((IntPtr) obj0 + 104L + 8L);
        if ((IntPtr) texturePtr1 != IntPtr.Zero)
        {
          Texture* texturePtr2 = texturePtr1;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) texturePtr1)((IntPtr) texturePtr2, 1U);
        }
      }
      *(long*) ((IntPtr) obj0 + 104L + 8L) = 0L;
    }
    ulong num18 = (ulong) *(long*) ((IntPtr) obj0 + 120L + 8L);
    if (num18 != 0UL)
    {
      RootObject* rootObjectPtr = (RootObject*) num18;
      uint num19 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
      if (num19 > 0U)
        *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num19 - 1;
      if (*(int*) ((IntPtr) rootObjectPtr + 8L) == 0)
      {
        Texture* texturePtr3 = (Texture*) *(long*) ((IntPtr) obj0 + 120L + 8L);
        if ((IntPtr) texturePtr3 != IntPtr.Zero)
        {
          Texture* texturePtr4 = texturePtr3;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) texturePtr3)((IntPtr) texturePtr4, 1U);
        }
      }
      *(long*) ((IntPtr) obj0 + 120L + 8L) = 0L;
    }
    ulong num20 = (ulong) *(long*) ((IntPtr) obj0 + 136L + 8L);
    if (num20 != 0UL)
    {
      RootObject* rootObjectPtr = (RootObject*) num20;
      uint num21 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
      if (num21 > 0U)
        *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num21 - 1;
      if (*(int*) ((IntPtr) rootObjectPtr + 8L) == 0)
      {
        Texture* texturePtr5 = (Texture*) *(long*) ((IntPtr) obj0 + 136L + 8L);
        if ((IntPtr) texturePtr5 != IntPtr.Zero)
        {
          Texture* texturePtr6 = texturePtr5;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) texturePtr5)((IntPtr) texturePtr6, 1U);
        }
      }
      *(long*) ((IntPtr) obj0 + 136L + 8L) = 0L;
    }
    ulong num22 = (ulong) *(long*) ((IntPtr) obj0 + 160L /*0xA0*/);
    if (num22 != 0UL)
    {
      \u003CModule\u003E.delete\u005B\u005D((void*) num22);
      *(long*) ((IntPtr) obj0 + 160L /*0xA0*/) = 0L;
    }
    ulong num23 = (ulong) *(long*) ((IntPtr) obj0 + 88L);
    if (num23 != 0UL)
    {
      \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002EDestroy((D3DXEXTENDEDFRAME*) num23);
      \u003CModule\u003E.delete((void*) *(long*) ((IntPtr) obj0 + 88L));
      *(long*) ((IntPtr) obj0 + 88L) = 0L;
    }
    ulong num24 = (ulong) *(long*) ((IntPtr) obj0 + 80L /*0x50*/);
    if (num24 == 0UL)
      return;
    \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ED3DXEXTENDEDFRAME\u002EDestroy((D3DXEXTENDEDFRAME*) num24);
    \u003CModule\u003E.delete((void*) *(long*) ((IntPtr) obj0 + 80L /*0x50*/));
    *(long*) ((IntPtr) obj0 + 80L /*0x50*/) = 0L;
  }

  internal static unsafe SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E\u002E\u003D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E* obj0,
    Texture* pObject)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if ((long) num1 != (IntPtr) pObject)
    {
      if (num1 != 0UL)
      {
        RootObject* rootObjectPtr = (RootObject*) num1;
        uint num2 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
        if (num2 > 0U)
          *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num2 - 1;
        if (*(int*) ((IntPtr) rootObjectPtr + 8L) == 0)
        {
          Texture* texturePtr1 = (Texture*) *(long*) ((IntPtr) obj0 + 8L);
          if ((IntPtr) texturePtr1 != IntPtr.Zero)
          {
            Texture* texturePtr2 = texturePtr1;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) texturePtr1)((IntPtr) texturePtr2, 1U);
          }
        }
      }
      *(long*) ((IntPtr) obj0 + 8L) = (long) pObject;
      if ((IntPtr) pObject != IntPtr.Zero)
        *(int*) ((IntPtr) pObject + 8L) = *(int*) ((IntPtr) pObject + 8L) + 1;
    }
    return obj0;
  }

  internal static unsafe void FableMod\u002EGfx\u002ED3DXModel\u002ESMaterial\u002E\u007Bdtor\u007D(
    [In] D3DXModel.SMaterial* obj0)
  {
    \u003CModule\u003E.FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E\u002E\u007Bdtor\u007D((SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATexture\u003E*) ((IntPtr) obj0 + 72L));
  }

  internal static unsafe SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E\u002E\u007Bctor\u007D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E* obj0,
    Mesh* pObject)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VMesh\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    *(long*) ((IntPtr) obj0 + 8L) = (long) pObject;
    if ((IntPtr) pObject != IntPtr.Zero)
      *(int*) ((IntPtr) pObject + 8L) = *(int*) ((IntPtr) pObject + 8L) + 1;
    return obj0;
  }

  internal static unsafe Mesh* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E\u002E\u002EPEAVMesh\u0040Gfx\u0040FableMod\u0040\u0040(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E* obj0)
  {
    return (Mesh*) *(long*) ((IntPtr) obj0 + 8L);
  }

  internal static unsafe Mesh* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E\u002E\u002D\u003E(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E* obj0)
  {
    return (Mesh*) *(long*) ((IntPtr) obj0 + 8L);
  }

  internal static unsafe SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E\u002E\u007Bctor\u007D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E* obj0,
    Node* pObject)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VNode\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    *(long*) ((IntPtr) obj0 + 8L) = (long) pObject;
    if ((IntPtr) pObject != IntPtr.Zero)
      *(int*) ((IntPtr) pObject + 8L) = *(int*) ((IntPtr) pObject + 8L) + 1;
    return obj0;
  }

  internal static unsafe void FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E\u002E\u007Bdtor\u007D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VNode\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (num1 == 0UL)
      return;
    RootObject* rootObjectPtr = (RootObject*) num1;
    uint num2 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
    if (num2 > 0U)
      *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num2 - 1;
    if (*(int*) ((IntPtr) rootObjectPtr + 8L) != 0)
      return;
    Node* nodePtr1 = (Node*) *(long*) ((IntPtr) obj0 + 8L);
    if ((IntPtr) nodePtr1 != IntPtr.Zero)
    {
      Node* nodePtr2 = nodePtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) nodePtr1)((IntPtr) nodePtr2, 1U);
    }
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
  }

  internal static unsafe Node* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E\u002E\u002D\u003E(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E* obj0)
  {
    return (Node*) *(long*) ((IntPtr) obj0 + 8L);
  }

  internal static unsafe void FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AD3DXModel\u003E\u002E\u007Bdtor\u007D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AD3DXModel\u003E* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VD3DXModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (num1 == 0UL)
      return;
    RootObject* rootObjectPtr = (RootObject*) num1;
    uint num2 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
    if (num2 > 0U)
      *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num2 - 1;
    if (*(int*) ((IntPtr) rootObjectPtr + 8L) != 0)
      return;
    D3DXModel* d3DxModelPtr1 = (D3DXModel*) *(long*) ((IntPtr) obj0 + 8L);
    if ((IntPtr) d3DxModelPtr1 != IntPtr.Zero)
    {
      D3DXModel* d3DxModelPtr2 = d3DxModelPtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) d3DxModelPtr1)((IntPtr) d3DxModelPtr2, 1U);
    }
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
  }

  internal static unsafe void* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E\u002E__vecDelDtor(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E* pointerFableModGfxNodePtr = (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E*) ((IntPtr) obj0 - 8L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL /*0x10*/, *(int*) pointerFableModGfxNodePtr, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) pointerFableModGfxNodePtr);
      return (void*) pointerFableModGfxNodePtr;
    }
    \u003CModule\u003E.FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AD3DXModel\u003E\u002E__vecDelDtor(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AD3DXModel\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AD3DXModel\u003E* fableModGfxD3DxModelPtr = (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AD3DXModel\u003E*) ((IntPtr) obj0 - 8L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL /*0x10*/, *(int*) fableModGfxD3DxModelPtr, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AD3DXModel\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) fableModGfxD3DxModelPtr);
      return (void*) fableModGfxD3DxModelPtr;
    }
    \u003CModule\u003E.FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AD3DXModel\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe uint* FableMod\u002EGfx\u002ESpatial\u002EFlags([In] Spatial* obj0)
  {
    return (uint*) ((IntPtr) obj0 + 32L /*0x20*/);
  }

  internal static unsafe void* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E\u002E__vecDelDtor(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E* pointerFableModGfxMeshPtr = (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E*) ((IntPtr) obj0 - 8L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL /*0x10*/, *(int*) pointerFableModGfxMeshPtr, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) pointerFableModGfxMeshPtr);
      return (void*) pointerFableModGfxMeshPtr;
    }
    \u003CModule\u003E.FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E\u002E\u007Bdtor\u007D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VMesh\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (num1 == 0UL)
      return;
    RootObject* rootObjectPtr = (RootObject*) num1;
    uint num2 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
    if (num2 > 0U)
      *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num2 - 1;
    if (*(int*) ((IntPtr) rootObjectPtr + 8L) != 0)
      return;
    Mesh* meshPtr1 = (Mesh*) *(long*) ((IntPtr) obj0 + 8L);
    if ((IntPtr) meshPtr1 != IntPtr.Zero)
    {
      Mesh* meshPtr2 = meshPtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) meshPtr1)((IntPtr) meshPtr2, 1U);
    }
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
  }

  internal static unsafe Node* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E\u002E\u002EPEAVNode\u0040Gfx\u0040FableMod\u0040\u0040(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E* obj0)
  {
    return (Node*) *(long*) ((IntPtr) obj0 + 8L);
  }

  internal static unsafe ModelSubHeader* FableMod\u002EGfx\u002EIntegration\u002EModelSubHeader\u002E\u007Bctor\u007D(
    [In] ModelSubHeader* obj0,
    sbyte* data)
  {
    // ISSUE: initblk instruction
    __memset((IntPtr) obj0, 0, 72);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0, (IntPtr) data, 48 /*0x30*/);
    void* voidPtr1 = \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) obj0 + 44L) * 4UL);
    *(long*) ((IntPtr) obj0 + 48L /*0x30*/) = (long) voidPtr1;
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 44L);
    ulong num2 = (ulong) num1 * 4UL;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) voidPtr1, (IntPtr) (data + 48L /*0x30*/), (long) num2);
    int num3 = (int) ((long) num2 + 48L /*0x30*/);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 56L, (long) num3 + (IntPtr) data, 4);
    int num4 = (int) ((long) (num1 - 1U) * 4L + (long) (num3 + 4));
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 60L, (long) num4 + (IntPtr) data, 4);
    void* voidPtr2 = \u003CModule\u003E.new\u005B\u005D((ulong) (uint) *(int*) ((IntPtr) obj0 + 60L) * 4UL);
    *(long*) ((IntPtr) obj0 + 64L /*0x40*/) = (long) voidPtr2;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) voidPtr2, (long) (num4 + 4) + (IntPtr) data, (long) (uint) *(int*) ((IntPtr) obj0 + 60L) * 4L);
    return obj0;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EModelSubHeader\u002EWriteToBuffer(
    [In] ModelSubHeader* obj0,
    sbyte* data,
    uint* length)
  {
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) data, (IntPtr) obj0, 48 /*0x30*/);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) (data + 48L /*0x30*/), *(long*) ((IntPtr) obj0 + 48L /*0x30*/), (long) (uint) *(int*) ((IntPtr) obj0 + 44L) * 4L);
    int num1 = (int) (((long) (uint) *(int*) ((IntPtr) obj0 + 44L) + 12L) * 4L);
    // ISSUE: cpblk instruction
    __memcpy((long) num1 + (IntPtr) data, (IntPtr) obj0 + 56L, 4);
    int num2 = num1 + 4;
    int y = 0;
    long num3 = (long) num2;
    if (0U < (uint) (*(int*) ((IntPtr) obj0 + 44L) - 1))
    {
      sbyte* numPtr = (sbyte*) (num3 + (IntPtr) data);
      do
      {
        float num4 = (float) (Math.Pow(2.6666667461395264, (double) y) * 0.0056250002235174179 + 0.019375000149011612);
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) numPtr, ref num4, 4);
        num2 += 4;
        numPtr += 4L;
        ++y;
      }
      while ((uint) y < (uint) (*(int*) ((IntPtr) obj0 + 44L) - 1));
    }
    // ISSUE: cpblk instruction
    __memcpy((long) num2 + (IntPtr) data, (IntPtr) obj0 + 60L, 4);
    int num5 = num2 + 4;
    // ISSUE: cpblk instruction
    __memcpy((long) num5 + (IntPtr) data, *(long*) ((IntPtr) obj0 + 64L /*0x40*/), (long) (uint) *(int*) ((IntPtr) obj0 + 60L) * 4L);
    *length = (uint) (int) ((long) (uint) *(int*) ((IntPtr) obj0 + 60L) * 4L + (long) num5);
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002ESetX(
    [In] PackedXYZ* obj0,
    float f)
  {
    uint num1 = (uint) ((double) f * 1023.0);
    PackedXYZ* packedXyzPtr1 = obj0;
    int num2 = *(int*) packedXyzPtr1 & -2048;
    *(int*) packedXyzPtr1 = num2;
    PackedXYZ* packedXyzPtr2 = obj0;
    int num3 = *(int*) packedXyzPtr2 | (int) num1;
    *(int*) packedXyzPtr2 = num3;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002ESetY(
    [In] PackedXYZ* obj0,
    float f)
  {
    uint num1 = (uint) ((double) f * 1023.0);
    PackedXYZ* packedXyzPtr1 = obj0;
    int num2 = *(int*) packedXyzPtr1 & -4192257;
    *(int*) packedXyzPtr1 = num2;
    PackedXYZ* packedXyzPtr2 = obj0;
    int num3 = *(int*) packedXyzPtr2 | (int) num1 << 11;
    *(int*) packedXyzPtr2 = num3;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002ESetZ(
    [In] PackedXYZ* obj0,
    float f)
  {
    uint num1 = (uint) ((double) f * 511.0);
    PackedXYZ* packedXyzPtr1 = obj0;
    int num2 = *(int*) packedXyzPtr1 & 4194303 /*0x3FFFFF*/;
    *(int*) packedXyzPtr1 = num2;
    PackedXYZ* packedXyzPtr2 = obj0;
    int num3 = *(int*) packedXyzPtr2 | (int) num1 << 22;
    *(int*) packedXyzPtr2 = num3;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002E\u003FA0x23fa0976\u002EParseVertexIndices(
    string faceWord,
    int* riVertex,
    int* riNormal,
    int* riTexCoord)
  {
    // ISSUE: untyped stack allocation
    long num1 = (long) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    char[] chArray = new char[1]{ '/' };
    string[] strArray = faceWord.Split(chArray);
    if (strArray == null)
      return;
    if (strArray.Length != 3)
      return;
    uint exceptionCode;
    try
    {
      *riVertex = int.Parse(strArray[0]) - 1;
    }
    catch (System.Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0L, 0, (void*) 0L) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          *riVertex = -1;
          goto label_12;
        }
        catch (System.Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
label_12:
    try
    {
      *riTexCoord = int.Parse(strArray[1]) - 1;
    }
    catch (System.Exception ex3) when (
    {
      // ISSUE: unable to correctly present filter
      exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0L, 0, (void*) 0L) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num3 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          *riTexCoord = -1;
          goto label_22;
        }
        catch (System.Exception ex4) when (
        {
          // ISSUE: unable to correctly present filter
          num3 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num3 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num3 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num3);
      }
    }
label_22:
    try
    {
      *riNormal = int.Parse(strArray[2]) - 1;
    }
    catch (System.Exception ex5) when (
    {
      // ISSUE: unable to correctly present filter
      exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0L, 0, (void*) 0L) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num4 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          *riNormal = -1;
          return;
        }
        catch (System.Exception ex6) when (
        {
          // ISSUE: unable to correctly present filter
          num4 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num4 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num4 == 0U)
          return;
        throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num4);
      }
    }
  }

  internal static unsafe Vertex_20_20* FableMod\u002EGfx\u002EIntegration\u002EVertex_20_20\u002E\u007Bctor\u007D(
    [In] Vertex_20_20* obj0)
  {
    return obj0;
  }

  internal static unsafe Vertex_28_20* FableMod\u002EGfx\u002EIntegration\u002EVertex_28_20\u002E\u007Bctor\u007D(
    [In] Vertex_28_20* obj0)
  {
    return obj0;
  }

  internal static unsafe void __vec_ctor(
    void* __t,
    ulong __s,
    int __n,
    __FnPtr<void* (void*)> __f)
  {
    __n += -1;
    if (__n < 0)
      return;
    do
    {
      void* voidPtr1 = __t;
      // ISSUE: function pointer call
      void* voidPtr2 = __calli(__f)(voidPtr1);
      __t = (void*) ((long) __s + (IntPtr) __t);
      __n += -1;
    }
    while (__n >= 0);
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002Epush_back(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0,
    D3DXVECTOR3* _Val)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (((IntPtr) _Val >= (long) num1 || *(long*) obj0 > (IntPtr) _Val ? 0 : 1) != 0)
    {
      IntPtr num2 = ((IntPtr) _Val - *(long*) obj0) / 12L;
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      D3DXVECTOR3* d3DxvectoR3Ptr1 = (D3DXVECTOR3*) (num2 * 12L + *(long*) obj0);
      D3DXVECTOR3* d3DxvectoR3Ptr2 = (D3DXVECTOR3*) *(long*) ((IntPtr) obj0 + 8L);
      D3DXVECTOR3* d3DxvectoR3Ptr3 = d3DxvectoR3Ptr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) d3DxvectoR3Ptr2 != IntPtr.Zero)
        {
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) d3DxvectoR3Ptr2, (IntPtr) d3DxvectoR3Ptr1, 12);
        }
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) d3DxvectoR3Ptr3, (void*) d3DxvectoR3Ptr2);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 12L;
    }
    else
    {
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      D3DXVECTOR3* d3DxvectoR3Ptr4 = (D3DXVECTOR3*) *(long*) ((IntPtr) obj0 + 8L);
      D3DXVECTOR3* d3DxvectoR3Ptr5 = d3DxvectoR3Ptr4;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) d3DxvectoR3Ptr4 != IntPtr.Zero)
        {
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) d3DxvectoR3Ptr4, (IntPtr) _Val, 12);
        }
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) d3DxvectoR3Ptr5, (void*) d3DxvectoR3Ptr4);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 12L;
    }
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0)
  {
    if (*(long*) obj0 != 0L)
    {
      \u003CModule\u003E.std\u002E_Container_base0\u002E_Orphan_all((_Container_base0*) obj0);
      \u003CModule\u003E.delete((void*) *(long*) obj0);
    }
    *(long*) obj0 = 0L;
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
    *(long*) ((IntPtr) obj0 + 16L /*0x10*/) = 0L;
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002Ereserve(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0,
    ulong _Count)
  {
    // ISSUE: untyped stack allocation
    long num1 = (long) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    if (1537228672809129301UL < _Count)
      \u003CModule\u003E.std\u002E_Xlength_error((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040OLBABOEK\u0040vector\u003F\u0024DMT\u003F\u0024DO\u003F5too\u003F5long\u003F\u0024AA\u0040);
    if ((ulong) (*(long*) ((IntPtr) obj0 + 16L /*0x10*/) - *(long*) obj0) / 12UL >= _Count)
      return;
    D3DXVECTOR3* _Ptr1 = \u003CModule\u003E.std\u002Eallocator\u003CD3DXVECTOR3\u003E\u002Eallocate((allocator\u003CD3DXVECTOR3\u003E*) ((IntPtr) obj0 + 24L), _Count);
    try
    {
      vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* allocatorD3DxvectoR3Ptr = obj0;
      long _First = *(long*) allocatorD3DxvectoR3Ptr;
      long _Last = *(long*) ((IntPtr) obj0 + 8L);
      D3DXVECTOR3* _Ptr2 = _Ptr1;
      \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002E_Umove\u003Cstruct\u0020D3DXVECTOR3\u0020\u002A\u003E(allocatorD3DxvectoR3Ptr, (D3DXVECTOR3*) _First, (D3DXVECTOR3*) _Last, _Ptr2);
    }
    catch (System.Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0L, 0, (void*) 0L) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Eallocator\u003CD3DXVECTOR3\u003E\u002Edeallocate((allocator\u003CD3DXVECTOR3\u003E*) ((IntPtr) obj0 + 24L), _Ptr1, _Count);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (System.Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
    long num3 = *(long*) obj0;
    ulong num4 = (ulong) (*(long*) ((IntPtr) obj0 + 8L) - num3) / 12UL;
    if (num3 != 0L)
      \u003CModule\u003E.delete((void*) num3);
    \u003CModule\u003E.std\u002E_Container_base0\u002E_Orphan_all((_Container_base0*) obj0);
    *(long*) ((IntPtr) obj0 + 16L /*0x10*/) = (long) ((long) _Count * 12L + (IntPtr) _Ptr1);
    *(long*) ((IntPtr) obj0 + 8L) = (long) ((long) num4 * 12L + (IntPtr) _Ptr1);
    *(long*) obj0 = (long) _Ptr1;
  }

  internal static unsafe ulong std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002Esize(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0)
  {
    return (ulong) (*(long*) ((IntPtr) obj0 + 8L) - *(long*) obj0) / 12UL;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002Eempty(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0)
  {
    return *(long*) obj0 == *(long*) ((IntPtr) obj0 + 8L);
  }

  internal static unsafe D3DXVECTOR3* std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002E\u005B\u005D(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0,
    ulong _Pos)
  {
    return (D3DXVECTOR3*) ((long) _Pos * 12L + *(long*) obj0);
  }

  internal static unsafe D3DXVECTOR3* std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002E\u005B\u005D(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0,
    ulong _Pos)
  {
    return (D3DXVECTOR3*) ((long) _Pos * 12L + *(long*) obj0);
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002Epush_back(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0,
    D3DXVECTOR3* _Val)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (((IntPtr) _Val >= (long) num1 || *(long*) obj0 > (IntPtr) _Val ? 0 : 1) != 0)
    {
      IntPtr num2 = ((IntPtr) _Val - *(long*) obj0) / 12L;
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      D3DXVECTOR3* d3DxvectoR3Ptr1 = (D3DXVECTOR3*) (num2 * 12L + *(long*) obj0);
      D3DXVECTOR3* d3DxvectoR3Ptr2 = (D3DXVECTOR3*) *(long*) ((IntPtr) obj0 + 8L);
      D3DXVECTOR3* d3DxvectoR3Ptr3 = d3DxvectoR3Ptr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) d3DxvectoR3Ptr2 != IntPtr.Zero)
        {
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) d3DxvectoR3Ptr2, (IntPtr) d3DxvectoR3Ptr1, 12);
        }
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) d3DxvectoR3Ptr3, (void*) d3DxvectoR3Ptr2);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 12L;
    }
    else
    {
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      void* voidPtr = (void*) *(long*) ((IntPtr) obj0 + 8L);
      D3DXVECTOR3* d3DxvectoR3Ptr = (D3DXVECTOR3*) voidPtr;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) voidPtr != IntPtr.Zero)
        {
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) voidPtr, (IntPtr) _Val, 12);
        }
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) d3DxvectoR3Ptr, voidPtr);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 12L;
    }
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002Eclear(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0)
  {
    _Vector_const_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u0020\u003E _Last_arg;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref _Last_arg = *(long*) ((IntPtr) obj0 + 8L);
    _Vector_const_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u0020\u003E _First_arg;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref _First_arg = *(long*) obj0;
    _Vector_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u0020\u003E allocatorD3DxvectoR3;
    \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002Eerase(obj0, &allocatorD3DxvectoR3, _First_arg, _Last_arg);
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002Epush_back(
    [In] vector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E* obj0,
    D3DXVECTOR2* _Val)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (((IntPtr) _Val >= (long) num1 || *(long*) obj0 > (IntPtr) _Val ? 0 : 1) != 0)
    {
      IntPtr num2 = (IntPtr) _Val - *(long*) obj0 >> 3;
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      D3DXVECTOR2* d3DxvectoR2Ptr1 = (D3DXVECTOR2*) (num2 * 8L + *(long*) obj0);
      D3DXVECTOR2* d3DxvectoR2Ptr2 = (D3DXVECTOR2*) *(long*) ((IntPtr) obj0 + 8L);
      D3DXVECTOR2* d3DxvectoR2Ptr3 = d3DxvectoR2Ptr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) d3DxvectoR2Ptr2 != IntPtr.Zero)
        {
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) d3DxvectoR2Ptr2, (IntPtr) d3DxvectoR2Ptr1, 8);
        }
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) d3DxvectoR2Ptr3, (void*) d3DxvectoR2Ptr2);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 8L;
    }
    else
    {
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      D3DXVECTOR2* d3DxvectoR2Ptr4 = (D3DXVECTOR2*) *(long*) ((IntPtr) obj0 + 8L);
      D3DXVECTOR2* d3DxvectoR2Ptr5 = d3DxvectoR2Ptr4;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) d3DxvectoR2Ptr4 != IntPtr.Zero)
        {
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) d3DxvectoR2Ptr4, (IntPtr) _Val, 8);
        }
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) d3DxvectoR2Ptr5, (void*) d3DxvectoR2Ptr4);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 8L;
    }
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] vector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E* obj0)
  {
    if (*(long*) obj0 != 0L)
    {
      \u003CModule\u003E.std\u002E_Container_base0\u002E_Orphan_all((_Container_base0*) obj0);
      \u003CModule\u003E.delete((void*) *(long*) obj0);
    }
    *(long*) obj0 = 0L;
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
    *(long*) ((IntPtr) obj0 + 16L /*0x10*/) = 0L;
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002Ereserve(
    [In] vector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E* obj0,
    ulong _Count)
  {
    // ISSUE: untyped stack allocation
    long num1 = (long) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    if (2305843009213693951UL /*0x1FFFFFFFFFFFFFFF*/ < _Count)
      \u003CModule\u003E.std\u002E_Xlength_error((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040OLBABOEK\u0040vector\u003F\u0024DMT\u003F\u0024DO\u003F5too\u003F5long\u003F\u0024AA\u0040);
    if ((ulong) (*(long*) ((IntPtr) obj0 + 16L /*0x10*/) - *(long*) obj0 >> 3) >= _Count)
      return;
    D3DXVECTOR2* _Ptr1 = \u003CModule\u003E.std\u002Eallocator\u003CD3DXVECTOR2\u003E\u002Eallocate((allocator\u003CD3DXVECTOR2\u003E*) ((IntPtr) obj0 + 24L), _Count);
    try
    {
      vector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E* allocatorD3DxvectoR2Ptr = obj0;
      long _First = *(long*) allocatorD3DxvectoR2Ptr;
      long _Last = *(long*) ((IntPtr) obj0 + 8L);
      D3DXVECTOR2* _Ptr2 = _Ptr1;
      \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002E_Umove\u003Cstruct\u0020D3DXVECTOR2\u0020\u002A\u003E(allocatorD3DxvectoR2Ptr, (D3DXVECTOR2*) _First, (D3DXVECTOR2*) _Last, _Ptr2);
    }
    catch (System.Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0L, 0, (void*) 0L) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Eallocator\u003CD3DXVECTOR2\u003E\u002Edeallocate((allocator\u003CD3DXVECTOR2\u003E*) ((IntPtr) obj0 + 24L), _Ptr1, _Count);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (System.Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
    long num3 = *(long*) obj0;
    ulong num4 = (ulong) (*(long*) ((IntPtr) obj0 + 8L) - num3 >> 3);
    if (num3 != 0L)
      \u003CModule\u003E.delete((void*) num3);
    \u003CModule\u003E.std\u002E_Container_base0\u002E_Orphan_all((_Container_base0*) obj0);
    *(long*) ((IntPtr) obj0 + 16L /*0x10*/) = (long) ((long) _Count * 8L + (IntPtr) _Ptr1);
    *(long*) ((IntPtr) obj0 + 8L) = (long) ((long) num4 * 8L + (IntPtr) _Ptr1);
    *(long*) obj0 = (long) _Ptr1;
  }

  internal static unsafe D3DXVECTOR2* std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002E\u005B\u005D(
    [In] vector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E* obj0,
    ulong _Pos)
  {
    return (D3DXVECTOR2*) ((long) _Pos * 8L + *(long*) obj0);
  }

  internal static unsafe D3DXVECTOR2* std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002E\u005B\u005D(
    [In] vector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E* obj0,
    ulong _Pos)
  {
    return (D3DXVECTOR2*) ((long) _Pos * 8L + *(long*) obj0);
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002Epush_back(
    [In] vector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E* obj0,
    D3DXVECTOR2* _Val)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (((IntPtr) _Val >= (long) num1 || *(long*) obj0 > (IntPtr) _Val ? 0 : 1) != 0)
    {
      IntPtr num2 = (IntPtr) _Val - *(long*) obj0 >> 3;
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      D3DXVECTOR2* d3DxvectoR2Ptr1 = (D3DXVECTOR2*) (num2 * 8L + *(long*) obj0);
      D3DXVECTOR2* d3DxvectoR2Ptr2 = (D3DXVECTOR2*) *(long*) ((IntPtr) obj0 + 8L);
      D3DXVECTOR2* d3DxvectoR2Ptr3 = d3DxvectoR2Ptr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) d3DxvectoR2Ptr2 != IntPtr.Zero)
        {
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) d3DxvectoR2Ptr2, (IntPtr) d3DxvectoR2Ptr1, 8);
        }
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) d3DxvectoR2Ptr3, (void*) d3DxvectoR2Ptr2);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 8L;
    }
    else
    {
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      void* voidPtr = (void*) *(long*) ((IntPtr) obj0 + 8L);
      D3DXVECTOR2* d3DxvectoR2Ptr = (D3DXVECTOR2*) voidPtr;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) voidPtr != IntPtr.Zero)
        {
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) voidPtr, (IntPtr) _Val, 8);
        }
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) d3DxvectoR2Ptr, voidPtr);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 8L;
    }
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002Eclear(
    [In] vector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E* obj0)
  {
    _Vector_const_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u0020\u003E _Last_arg;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref _Last_arg = *(long*) ((IntPtr) obj0 + 8L);
    _Vector_const_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u0020\u003E _First_arg;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref _First_arg = *(long*) obj0;
    _Vector_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u0020\u003E allocatorD3DxvectoR2;
    \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002Eerase(obj0, &allocatorD3DxvectoR2, _First_arg, _Last_arg);
  }

  internal static unsafe void std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002Epush_back(
    [In] vector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E* obj0,
    int* _Val)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (((IntPtr) _Val >= (long) num1 || *(long*) obj0 > (IntPtr) _Val ? 0 : 1) != 0)
    {
      IntPtr num2 = (IntPtr) _Val - *(long*) obj0 >> 2;
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      int* numPtr1 = (int*) (num2 * 4L + *(long*) obj0);
      int* numPtr2 = (int*) *(long*) ((IntPtr) obj0 + 8L);
      int* numPtr3 = numPtr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) numPtr2 != IntPtr.Zero)
          *numPtr2 = *numPtr1;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) numPtr3, (void*) numPtr2);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 4L;
    }
    else
    {
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      int* numPtr4 = (int*) *(long*) ((IntPtr) obj0 + 8L);
      int* numPtr5 = numPtr4;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) numPtr4 != IntPtr.Zero)
          *numPtr4 = *_Val;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) numPtr5, (void*) numPtr4);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 4L;
    }
  }

  internal static unsafe void std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] vector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E* obj0)
  {
    if (*(long*) obj0 != 0L)
    {
      \u003CModule\u003E.std\u002E_Container_base0\u002E_Orphan_all((_Container_base0*) obj0);
      \u003CModule\u003E.delete((void*) *(long*) obj0);
    }
    *(long*) obj0 = 0L;
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
    *(long*) ((IntPtr) obj0 + 16L /*0x10*/) = 0L;
  }

  internal static unsafe void std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002Ereserve(
    [In] vector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E* obj0,
    ulong _Count)
  {
    // ISSUE: untyped stack allocation
    long num1 = (long) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    if (4611686018427387903UL /*0x3FFFFFFFFFFFFFFF*/ < _Count)
      \u003CModule\u003E.std\u002E_Xlength_error((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040OLBABOEK\u0040vector\u003F\u0024DMT\u003F\u0024DO\u003F5too\u003F5long\u003F\u0024AA\u0040);
    if ((ulong) (*(long*) ((IntPtr) obj0 + 16L /*0x10*/) - *(long*) obj0 >> 2) >= _Count)
      return;
    int* _Ptr1 = \u003CModule\u003E.std\u002Eallocator\u003Cint\u003E\u002Eallocate((allocator\u003Cint\u003E*) ((IntPtr) obj0 + 24L), _Count);
    try
    {
      vector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E* intStdAllocatorIntPtr = obj0;
      long _First = *(long*) intStdAllocatorIntPtr;
      long _Last = *(long*) ((IntPtr) obj0 + 8L);
      int* _Ptr2 = _Ptr1;
      \u003CModule\u003E.std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002E_Umove\u003Cint\u0020\u002A\u003E(intStdAllocatorIntPtr, (int*) _First, (int*) _Last, _Ptr2);
    }
    catch (System.Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0L, 0, (void*) 0L) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Eallocator\u003Cint\u003E\u002Edeallocate((allocator\u003Cint\u003E*) ((IntPtr) obj0 + 24L), _Ptr1, _Count);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (System.Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
    long num3 = *(long*) obj0;
    ulong num4 = (ulong) (*(long*) ((IntPtr) obj0 + 8L) - num3 >> 2);
    if (num3 != 0L)
      \u003CModule\u003E.delete((void*) num3);
    \u003CModule\u003E.std\u002E_Container_base0\u002E_Orphan_all((_Container_base0*) obj0);
    *(long*) ((IntPtr) obj0 + 16L /*0x10*/) = (long) ((long) _Count * 4L + (IntPtr) _Ptr1);
    *(long*) ((IntPtr) obj0 + 8L) = (long) ((long) num4 * 4L + (IntPtr) _Ptr1);
    *(long*) obj0 = (long) _Ptr1;
  }

  internal static unsafe void std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002Epush_back(
    [In] vector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E* obj0,
    int* _Val)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (((IntPtr) _Val >= (long) num1 || *(long*) obj0 > (IntPtr) _Val ? 0 : 1) != 0)
    {
      IntPtr num2 = (IntPtr) _Val - *(long*) obj0 >> 2;
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      int* numPtr1 = (int*) (num2 * 4L + *(long*) obj0);
      int* numPtr2 = (int*) *(long*) ((IntPtr) obj0 + 8L);
      int* numPtr3 = numPtr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) numPtr2 != IntPtr.Zero)
          *numPtr2 = *numPtr1;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) numPtr3, (void*) numPtr2);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 4L;
    }
    else
    {
      if ((long) num1 == *(long*) ((IntPtr) obj0 + 16L /*0x10*/))
        \u003CModule\u003E.std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002E_Reserve(obj0, 1UL);
      void* voidPtr = (void*) *(long*) ((IntPtr) obj0 + 8L);
      int* numPtr = (int*) voidPtr;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) voidPtr != IntPtr.Zero)
          *(int*) voidPtr = *_Val;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) numPtr, voidPtr);
      }
      *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) obj0 + 8L) + 4L;
    }
  }

  internal static unsafe void std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002Eclear(
    [In] vector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E* obj0)
  {
    long num1 = *(long*) ((IntPtr) obj0 + 8L);
    _Vector_iterator\u003Cstd\u003A\u003A_Vector_val\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u0020\u003E intStdAllocatorInt1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref intStdAllocatorInt1 = num1;
    _Vector_iterator\u003Cstd\u003A\u003A_Vector_val\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u0020\u003E intStdAllocatorInt2;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref intStdAllocatorInt2 = *(long*) obj0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(long&) ref intStdAllocatorInt2 == ^(long&) ref intStdAllocatorInt1)
      return;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ulong num2 = (ulong) (num1 - ^(long&) ref intStdAllocatorInt1 >> 2) * 4UL;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E.memmove((void*) ^(long&) ref intStdAllocatorInt2, (void*) ^(long&) ref intStdAllocatorInt1, num2);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    *(long*) ((IntPtr) obj0 + 8L) = (long) num2 + ^(long&) ref intStdAllocatorInt2;
  }

  internal static unsafe _Vector_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u0020\u003E* std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002Eerase(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0,
    [In] _Vector_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u0020\u003E* obj1,
    _Vector_const_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u0020\u003E _First_arg,
    _Vector_const_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u0020\u003E _Last_arg)
  {
    _Vector_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u0020\u003E allocatorD3DxvectoR3;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref allocatorD3DxvectoR3 = ^(long&) ref _First_arg;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(long&) ref _First_arg != ^(long&) ref _Last_arg)
    {
      D3DXVECTOR3* d3DxvectoR3Ptr1 = (D3DXVECTOR3*) *(long*) ((IntPtr) obj0 + 8L);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      D3DXVECTOR3* d3DxvectoR3Ptr2 = (D3DXVECTOR3*) ^(long&) ref _First_arg;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      D3DXVECTOR3* d3DxvectoR3Ptr3 = (D3DXVECTOR3*) ^(long&) ref _Last_arg;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(long&) ref _Last_arg != (IntPtr) d3DxvectoR3Ptr1)
      {
        do
        {
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) d3DxvectoR3Ptr2, (IntPtr) d3DxvectoR3Ptr3, 12);
          d3DxvectoR3Ptr2 += 12L;
          d3DxvectoR3Ptr3 += 12L;
        }
        while (d3DxvectoR3Ptr3 != d3DxvectoR3Ptr1);
      }
      *(long*) ((IntPtr) obj0 + 8L) = (long) d3DxvectoR3Ptr2;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref allocatorD3DxvectoR3, 8);
    return obj1;
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002E_Reserve(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0,
    ulong _Count)
  {
    long num1 = *(long*) obj0;
    ulong num2 = (ulong) (*(long*) ((IntPtr) obj0 + 8L) - num1) / 12UL;
    if (1537228672809129301UL - _Count < num2)
      \u003CModule\u003E.std\u002E_Xlength_error((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040OLBABOEK\u0040vector\u003F\u0024DMT\u003F\u0024DO\u003F5too\u003F5long\u003F\u0024AA\u0040);
    ulong num3 = _Count + num2;
    long num4 = (*(long*) ((IntPtr) obj0 + 16L /*0x10*/) - num1) / 12L;
    if (num3 <= (ulong) num4)
      return;
    ulong num5 = (ulong) num4;
    ulong num6 = num5 >> 1;
    ulong num7 = 1537228672809129301UL - num6 >= num5 ? num6 + num5 : 0UL;
    ulong num8 = num7;
    ulong _Count1 = num7 < num3 ? num3 : num8;
    \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002Ereserve(obj0, _Count1);
  }

  internal static unsafe void std\u002Eallocator\u003CD3DXVECTOR3\u003E\u002Edeallocate(
    [In] allocator\u003CD3DXVECTOR3\u003E* obj0,
    D3DXVECTOR3* _Ptr,
    ulong __unnamed001)
  {
    \u003CModule\u003E.delete((void*) _Ptr);
  }

  internal static unsafe D3DXVECTOR3* std\u002Eallocator\u003CD3DXVECTOR3\u003E\u002Eallocate(
    [In] allocator\u003CD3DXVECTOR3\u003E* obj0,
    ulong _Count)
  {
    void* voidPtr = (void*) 0L;
    if (_Count > 0UL)
    {
      if (1537228672809129301UL >= _Count)
      {
        voidPtr = \u003CModule\u003E.@new(_Count * 12UL);
        if ((IntPtr) voidPtr != IntPtr.Zero)
          goto label_3;
      }
      sbyte* numPtr = (sbyte*) 0L;
      bad_alloc badAlloc;
      \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) &badAlloc, &numPtr);
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(long&) ref badAlloc = (long) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) &badAlloc);
      }
      \u003CModule\u003E._CxxThrowException((void*) &badAlloc, &\u003CModule\u003E._TI2\u003FAVbad_alloc\u0040std\u0040\u0040);
      return (D3DXVECTOR3*) 0L;
    }
label_3:
    return (D3DXVECTOR3*) voidPtr;
  }

  internal static unsafe _Vector_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u0020\u003E* std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002Eerase(
    [In] vector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E* obj0,
    [In] _Vector_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u0020\u003E* obj1,
    _Vector_const_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u0020\u003E _First_arg,
    _Vector_const_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u0020\u003E _Last_arg)
  {
    _Vector_iterator\u003Cstd\u003A\u003A_Vector_val\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u0020\u003E allocatorD3DxvectoR2;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref allocatorD3DxvectoR2 = ^(long&) ref _First_arg;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(long&) ref _First_arg != ^(long&) ref _Last_arg)
    {
      D3DXVECTOR2* d3DxvectoR2Ptr1 = (D3DXVECTOR2*) *(long*) ((IntPtr) obj0 + 8L);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      D3DXVECTOR2* d3DxvectoR2Ptr2 = (D3DXVECTOR2*) ^(long&) ref _First_arg;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      D3DXVECTOR2* d3DxvectoR2Ptr3 = (D3DXVECTOR2*) ^(long&) ref _Last_arg;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(long&) ref _Last_arg != (IntPtr) d3DxvectoR2Ptr1)
      {
        do
        {
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) d3DxvectoR2Ptr2, (IntPtr) d3DxvectoR2Ptr3, 8);
          d3DxvectoR2Ptr2 += 8L;
          d3DxvectoR2Ptr3 += 8L;
        }
        while (d3DxvectoR2Ptr3 != d3DxvectoR2Ptr1);
      }
      *(long*) ((IntPtr) obj0 + 8L) = (long) d3DxvectoR2Ptr2;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref allocatorD3DxvectoR2, 8);
    return obj1;
  }

  internal static unsafe void std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002E_Reserve(
    [In] vector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E* obj0,
    ulong _Count)
  {
    long num1 = *(long*) obj0;
    ulong num2 = (ulong) (*(long*) ((IntPtr) obj0 + 8L) - num1 >> 3);
    if (2305843009213693951UL /*0x1FFFFFFFFFFFFFFF*/ - _Count < num2)
      \u003CModule\u003E.std\u002E_Xlength_error((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040OLBABOEK\u0040vector\u003F\u0024DMT\u003F\u0024DO\u003F5too\u003F5long\u003F\u0024AA\u0040);
    ulong num3 = _Count + num2;
    long num4 = *(long*) ((IntPtr) obj0 + 16L /*0x10*/) - num1 >> 3;
    if (num3 <= (ulong) num4)
      return;
    ulong num5 = (ulong) num4;
    ulong num6 = num5 >> 1;
    ulong num7 = 2305843009213693951UL /*0x1FFFFFFFFFFFFFFF*/ - num6 >= num5 ? num6 + num5 : 0UL;
    ulong num8 = num7;
    ulong _Count1 = num7 < num3 ? num3 : num8;
    \u003CModule\u003E.std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002Ereserve(obj0, _Count1);
  }

  internal static unsafe void std\u002Eallocator\u003CD3DXVECTOR2\u003E\u002Edeallocate(
    [In] allocator\u003CD3DXVECTOR2\u003E* obj0,
    D3DXVECTOR2* _Ptr,
    ulong __unnamed001)
  {
    \u003CModule\u003E.delete((void*) _Ptr);
  }

  internal static unsafe D3DXVECTOR2* std\u002Eallocator\u003CD3DXVECTOR2\u003E\u002Eallocate(
    [In] allocator\u003CD3DXVECTOR2\u003E* obj0,
    ulong _Count)
  {
    void* voidPtr = (void*) 0L;
    if (_Count > 0UL)
    {
      if (2305843009213693951UL /*0x1FFFFFFFFFFFFFFF*/ >= _Count)
      {
        voidPtr = \u003CModule\u003E.@new(_Count * 8UL);
        if ((IntPtr) voidPtr != IntPtr.Zero)
          goto label_3;
      }
      sbyte* numPtr = (sbyte*) 0L;
      bad_alloc badAlloc;
      \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) &badAlloc, &numPtr);
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(long&) ref badAlloc = (long) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) &badAlloc);
      }
      \u003CModule\u003E._CxxThrowException((void*) &badAlloc, &\u003CModule\u003E._TI2\u003FAVbad_alloc\u0040std\u0040\u0040);
      return (D3DXVECTOR2*) 0L;
    }
label_3:
    return (D3DXVECTOR2*) voidPtr;
  }

  internal static unsafe void std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002E_Reserve(
    [In] vector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E* obj0,
    ulong _Count)
  {
    long num1 = *(long*) obj0;
    ulong num2 = (ulong) (*(long*) ((IntPtr) obj0 + 8L) - num1 >> 2);
    if (4611686018427387903UL /*0x3FFFFFFFFFFFFFFF*/ - _Count < num2)
      \u003CModule\u003E.std\u002E_Xlength_error((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BD\u0040OLBABOEK\u0040vector\u003F\u0024DMT\u003F\u0024DO\u003F5too\u003F5long\u003F\u0024AA\u0040);
    ulong num3 = _Count + num2;
    long num4 = *(long*) ((IntPtr) obj0 + 16L /*0x10*/) - num1 >> 2;
    if (num3 <= (ulong) num4)
      return;
    ulong num5 = (ulong) num4;
    ulong num6 = num5 >> 1;
    ulong num7 = 4611686018427387903UL /*0x3FFFFFFFFFFFFFFF*/ - num6 >= num5 ? num6 + num5 : 0UL;
    ulong num8 = num7;
    ulong _Count1 = num7 < num3 ? num3 : num8;
    \u003CModule\u003E.std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002Ereserve(obj0, _Count1);
  }

  internal static unsafe void std\u002Eallocator\u003Cint\u003E\u002Edeallocate(
    [In] allocator\u003Cint\u003E* obj0,
    int* _Ptr,
    ulong __unnamed001)
  {
    \u003CModule\u003E.delete((void*) _Ptr);
  }

  internal static unsafe int* std\u002Eallocator\u003Cint\u003E\u002Eallocate(
    [In] allocator\u003Cint\u003E* obj0,
    ulong _Count)
  {
    void* voidPtr = (void*) 0L;
    if (_Count > 0UL)
    {
      if (4611686018427387903UL /*0x3FFFFFFFFFFFFFFF*/ >= _Count)
      {
        voidPtr = \u003CModule\u003E.@new(_Count * 4UL);
        if ((IntPtr) voidPtr != IntPtr.Zero)
          goto label_3;
      }
      sbyte* numPtr = (sbyte*) 0L;
      bad_alloc badAlloc;
      \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) &badAlloc, &numPtr);
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(long&) ref badAlloc = (long) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) &badAlloc);
      }
      \u003CModule\u003E._CxxThrowException((void*) &badAlloc, &\u003CModule\u003E._TI2\u003FAVbad_alloc\u0040std\u0040\u0040);
      return (int*) 0L;
    }
label_3:
    return (int*) voidPtr;
  }

  internal static unsafe CTFixed\u003Cshort\u002C11\u002C2048\u003E* CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u003D(
    [In] CTFixed\u003Cshort\u002C11\u002C2048\u003E* obj0,
    float fValue)
  {
    *(short*) obj0 = (short) (int) \u003CModule\u003E.floorf(fValue * 2048f);
    return obj0;
  }

  internal static unsafe SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E\u002E\u003D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ANode\u003E* obj0,
    Node* pObject)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if ((long) num1 != (IntPtr) pObject)
    {
      if (num1 != 0UL)
      {
        RootObject* rootObjectPtr = (RootObject*) num1;
        uint num2 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
        if (num2 > 0U)
          *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num2 - 1;
        if (*(int*) ((IntPtr) rootObjectPtr + 8L) == 0)
        {
          Node* nodePtr1 = (Node*) *(long*) ((IntPtr) obj0 + 8L);
          if ((IntPtr) nodePtr1 != IntPtr.Zero)
          {
            Node* nodePtr2 = nodePtr1;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) nodePtr1)((IntPtr) nodePtr2, 1U);
          }
        }
      }
      *(long*) ((IntPtr) obj0 + 8L) = (long) pObject;
      if ((IntPtr) pObject != IntPtr.Zero)
        *(int*) ((IntPtr) pObject + 8L) = *(int*) ((IntPtr) pObject + 8L) + 1;
    }
    return obj0;
  }

  internal static unsafe void std\u002E_Cons_val\u003Cclass\u0020std\u003A\u003Aallocator\u003Cstruct\u0020D3DXVECTOR3\u003E\u002Cstruct\u0020D3DXVECTOR3\u002Cstruct\u0020D3DXVECTOR3\u003E(
    allocator\u003CD3DXVECTOR3\u003E* _Alval,
    D3DXVECTOR3* _Pdest,
    D3DXVECTOR3* _Src)
  {
    D3DXVECTOR3* d3DxvectoR3Ptr = _Pdest;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) _Pdest == IntPtr.Zero)
        return;
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) _Pdest, (IntPtr) _Src, 12);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) d3DxvectoR3Ptr, (void*) _Pdest);
    }
  }

  internal static unsafe D3DXVECTOR3* std\u002Evector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E\u002E_Umove\u003Cstruct\u0020D3DXVECTOR3\u0020\u002A\u003E(
    [In] vector\u003CD3DXVECTOR3\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR3\u003E\u0020\u003E* obj0,
    D3DXVECTOR3* _First,
    D3DXVECTOR3* _Last,
    D3DXVECTOR3* _Ptr)
  {
    _Nonscalar_ptr_iterator_tag nonscalarPtrIteratorTag;
    _Nonscalar_ptr_iterator_tag __unnamed005 = nonscalarPtrIteratorTag;
    return \u003CModule\u003E.std\u002E_Uninit_move\u003Cstruct\u0020D3DXVECTOR3\u0020\u002A\u002Cstruct\u0020D3DXVECTOR3\u0020\u002A\u002Cclass\u0020std\u003A\u003Aallocator\u003Cstruct\u0020D3DXVECTOR3\u003E\u002Cstruct\u0020D3DXVECTOR3\u003E(_First, _Last, _Ptr, (allocator\u003CD3DXVECTOR3\u003E*) ((IntPtr) obj0 + 24L), (D3DXVECTOR3*) 0L, __unnamed005);
  }

  internal static unsafe void std\u002E_Cons_val\u003Cclass\u0020std\u003A\u003Aallocator\u003Cstruct\u0020D3DXVECTOR2\u003E\u002Cstruct\u0020D3DXVECTOR2\u002Cstruct\u0020D3DXVECTOR2\u003E(
    allocator\u003CD3DXVECTOR2\u003E* _Alval,
    D3DXVECTOR2* _Pdest,
    D3DXVECTOR2* _Src)
  {
    D3DXVECTOR2* d3DxvectoR2Ptr = _Pdest;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) _Pdest == IntPtr.Zero)
        return;
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) _Pdest, (IntPtr) _Src, 8);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) d3DxvectoR2Ptr, (void*) _Pdest);
    }
  }

  internal static unsafe D3DXVECTOR2* std\u002Evector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E\u002E_Umove\u003Cstruct\u0020D3DXVECTOR2\u0020\u002A\u003E(
    [In] vector\u003CD3DXVECTOR2\u002Cstd\u003A\u003Aallocator\u003CD3DXVECTOR2\u003E\u0020\u003E* obj0,
    D3DXVECTOR2* _First,
    D3DXVECTOR2* _Last,
    D3DXVECTOR2* _Ptr)
  {
    _Nonscalar_ptr_iterator_tag nonscalarPtrIteratorTag;
    _Nonscalar_ptr_iterator_tag __unnamed005 = nonscalarPtrIteratorTag;
    return \u003CModule\u003E.std\u002E_Uninit_move\u003Cstruct\u0020D3DXVECTOR2\u0020\u002A\u002Cstruct\u0020D3DXVECTOR2\u0020\u002A\u002Cclass\u0020std\u003A\u003Aallocator\u003Cstruct\u0020D3DXVECTOR2\u003E\u002Cstruct\u0020D3DXVECTOR2\u003E(_First, _Last, _Ptr, (allocator\u003CD3DXVECTOR2\u003E*) ((IntPtr) obj0 + 24L), (D3DXVECTOR2*) 0L, __unnamed005);
  }

  internal static unsafe int* std\u002Evector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E\u002E_Umove\u003Cint\u0020\u002A\u003E(
    [In] vector\u003Cint\u002Cstd\u003A\u003Aallocator\u003Cint\u003E\u0020\u003E* obj0,
    int* _First,
    int* _Last,
    int* _Ptr)
  {
    ulong num = (ulong) (((IntPtr) _Last - (IntPtr) _First >> 2) * 4L);
    return (int*) ((IntPtr) \u003CModule\u003E.memmove((void*) _Ptr, (void*) _First, num) + (long) num);
  }

  [SpecialName]
  internal static unsafe bad_alloc* std\u002Ebad_alloc\u002E\u007Bctor\u007D(
    [In] bad_alloc* obj0,
    bad_alloc* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe D3DXVECTOR3* std\u002E_Uninit_move\u003Cstruct\u0020D3DXVECTOR3\u0020\u002A\u002Cstruct\u0020D3DXVECTOR3\u0020\u002A\u002Cclass\u0020std\u003A\u003Aallocator\u003Cstruct\u0020D3DXVECTOR3\u003E\u002Cstruct\u0020D3DXVECTOR3\u003E(
    D3DXVECTOR3* _First,
    D3DXVECTOR3* _Last,
    D3DXVECTOR3* _Dest,
    allocator\u003CD3DXVECTOR3\u003E* _Al,
    D3DXVECTOR3* __unnamed004,
    _Nonscalar_ptr_iterator_tag __unnamed005)
  {
    // ISSUE: untyped stack allocation
    long num1 = (long) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    D3DXVECTOR3* d3DxvectoR3Ptr = _Dest;
    try
    {
      for (; _First != _Last; _First += 12L)
      {
        \u003CModule\u003E.std\u002E_Cons_val\u003Cclass\u0020std\u003A\u003Aallocator\u003Cstruct\u0020D3DXVECTOR3\u003E\u002Cstruct\u0020D3DXVECTOR3\u002Cstruct\u0020D3DXVECTOR3\u003E(_Al, _Dest, _First);
        _Dest += 12L;
      }
    }
    catch (System.Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0L, 0, (void*) 0L) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          while (d3DxvectoR3Ptr != _Dest)
            d3DxvectoR3Ptr += 12L;
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (System.Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
    return _Dest;
  }

  internal static unsafe D3DXVECTOR2* std\u002E_Uninit_move\u003Cstruct\u0020D3DXVECTOR2\u0020\u002A\u002Cstruct\u0020D3DXVECTOR2\u0020\u002A\u002Cclass\u0020std\u003A\u003Aallocator\u003Cstruct\u0020D3DXVECTOR2\u003E\u002Cstruct\u0020D3DXVECTOR2\u003E(
    D3DXVECTOR2* _First,
    D3DXVECTOR2* _Last,
    D3DXVECTOR2* _Dest,
    allocator\u003CD3DXVECTOR2\u003E* _Al,
    D3DXVECTOR2* __unnamed004,
    _Nonscalar_ptr_iterator_tag __unnamed005)
  {
    // ISSUE: untyped stack allocation
    long num1 = (long) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    D3DXVECTOR2* d3DxvectoR2Ptr = _Dest;
    try
    {
      for (; _First != _Last; _First += 8L)
      {
        \u003CModule\u003E.std\u002E_Cons_val\u003Cclass\u0020std\u003A\u003Aallocator\u003Cstruct\u0020D3DXVECTOR2\u003E\u002Cstruct\u0020D3DXVECTOR2\u002Cstruct\u0020D3DXVECTOR2\u003E(_Al, _Dest, _First);
        _Dest += 8L;
      }
    }
    catch (System.Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0L, 0, (void*) 0L) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          while (d3DxvectoR2Ptr != _Dest)
            d3DxvectoR2Ptr += 8L;
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (System.Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
    return _Dest;
  }

  internal static unsafe void delete(void* _param0, void* _param1)
  {
  }

  internal static unsafe void std\u002Ebad_alloc\u002E\u007Bdtor\u007D([In] bad_alloc* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe void* std\u002Ebad_alloc\u002E__vecDelDtor([In] bad_alloc* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      bad_alloc* badAllocPtr = (bad_alloc*) ((IntPtr) obj0 - 8L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 24UL, *(int*) badAllocPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebad_alloc\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete((void*) badAllocPtr);
      return (void*) badAllocPtr;
    }
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xd127aafc\u002EApplyEffects(
    Spatial* pSpatial)
  {
    Node* nodePtr = (Node*) \u003CModule\u003E.__RTDynamicCast((void*) pSpatial, 0, (void*) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u00408, (void*) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVNode\u0040Gfx\u0040FableMod\u0040\u0040\u00408, 0);
    if ((IntPtr) nodePtr != IntPtr.Zero)
    {
      int num1 = \u003CModule\u003E.FableMod\u002EGfx\u002ENode\u002ENumChildren(nodePtr);
      int num2 = 0;
      if (0 >= num1)
        return;
      do
      {
        \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xd127aafc\u002EApplyEffects(\u003CModule\u003E.FableMod\u002EGfx\u002ENode\u002EGetChildAt(nodePtr, num2));
        ++num2;
      }
      while (num2 < num1);
    }
    else
    {
      Mesh* meshPtr = (Mesh*) \u003CModule\u003E.__RTDynamicCast((void*) pSpatial, 0, (void*) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u00408, (void*) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVMesh\u0040Gfx\u0040FableMod\u0040\u0040\u00408, 0);
      if ((IntPtr) meshPtr == IntPtr.Zero)
        return;
      *(int*) ((IntPtr) meshPtr + 320L) = *(int*) ((IntPtr) meshPtr + 320L) | 1;
    }
  }

  internal static unsafe uint* FableMod\u002EGfx\u002EMesh\u002ERenderFlags([In] Mesh* obj0)
  {
    return (uint*) ((IntPtr) obj0 + 320L);
  }

  internal static double _Pow_int\u003Cdouble\u003E(double _X, int _Y)
  {
    uint num1 = _Y < 0 ? (uint) -_Y : (uint) _Y;
    double num2 = 1.0;
    while (true)
    {
      if (((int) num1 & 1) != 0)
        num2 *= _X;
      num1 >>= 1;
      if (num1 != 0U)
      {
        double num3 = _X;
        _X = num3 * num3;
      }
      else
        break;
    }
    return _Y >= 0 ? num2 : 1.0 / num2;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xa15d0f8f\u002EApplyTreeFlags(
    Spatial* pSpatial,
    [MarshalAs(UnmanagedType.U1)] bool bFlags,
    uint uiFlags,
    [MarshalAs(UnmanagedType.U1)] bool bRenderFlags,
    uint uiRenderFlags)
  {
    Node* nodePtr = (Node*) \u003CModule\u003E.__RTDynamicCast((void*) pSpatial, 0, (void*) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u00408, (void*) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVNode\u0040Gfx\u0040FableMod\u0040\u0040\u00408, 0);
    if ((IntPtr) nodePtr != IntPtr.Zero)
    {
      int num1 = \u003CModule\u003E.FableMod\u002EGfx\u002ENode\u002ENumChildren(nodePtr);
      int num2 = 0;
      if (0 >= num1)
        return;
      do
      {
        \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002E\u003FA0xa15d0f8f\u002EApplyTreeFlags(\u003CModule\u003E.FableMod\u002EGfx\u002ENode\u002EGetChildAt(nodePtr, num2), bFlags, uiFlags, bRenderFlags, uiRenderFlags);
        ++num2;
      }
      while (num2 < num1);
    }
    else
    {
      Mesh* meshPtr = (Mesh*) \u003CModule\u003E.__RTDynamicCast((void*) pSpatial, 0, (void*) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u00408, (void*) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVMesh\u0040Gfx\u0040FableMod\u0040\u0040\u00408, 0);
      if ((IntPtr) meshPtr == IntPtr.Zero)
        return;
      if (bRenderFlags)
        *(int*) ((IntPtr) meshPtr + 320L) = *(int*) ((IntPtr) meshPtr + 320L) | (int) uiRenderFlags;
      else
        *(int*) ((IntPtr) meshPtr + 320L) = *(int*) ((IntPtr) meshPtr + 320L) & ~(int) uiRenderFlags;
      if (bFlags)
        *(int*) ((IntPtr) meshPtr + 32L /*0x20*/) = *(int*) ((IntPtr) meshPtr + 32L /*0x20*/) | (int) uiFlags;
      else
        *(int*) ((IntPtr) meshPtr + 32L /*0x20*/) = *(int*) ((IntPtr) meshPtr + 32L /*0x20*/) & ~(int) uiFlags;
    }
  }

  internal static unsafe void FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ASpatial\u003E\u002E\u007Bdtor\u007D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ASpatial\u003E* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VSpatial\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (num1 == 0UL)
      return;
    RootObject* rootObjectPtr = (RootObject*) num1;
    uint num2 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
    if (num2 > 0U)
      *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num2 - 1;
    if (*(int*) ((IntPtr) rootObjectPtr + 8L) != 0)
      return;
    Spatial* spatialPtr1 = (Spatial*) *(long*) ((IntPtr) obj0 + 8L);
    if ((IntPtr) spatialPtr1 != IntPtr.Zero)
    {
      Spatial* spatialPtr2 = spatialPtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) spatialPtr1)((IntPtr) spatialPtr2, 1U);
    }
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
  }

  internal static unsafe uint* FableMod\u002EGfx\u002ESpatial\u002EID([In] Spatial* obj0)
  {
    return (uint*) ((IntPtr) obj0 + 272L);
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002E\u003FA0x98271962\u002ECreateDirtyRect(
    EditableTexture* pTexture,
    int iX,
    int iY,
    int iSize,
    tagRECT* pArea)
  {
    int num1 = iX - iSize;
    int num2 = iY - iSize;
    int num3 = iX + iSize;
    int num4 = iY + iSize;
    int num5 = num1 < 0 ? 0 : num1;
    int num6 = num2 < 0 ? 0 : num2;
    if ((uint) num3 > \u003CModule\u003E.FableMod\u002EGfx\u002ETexture\u002EGetWidth((Texture*) pTexture, 0U))
      num3 = (int) \u003CModule\u003E.FableMod\u002EGfx\u002ETexture\u002EGetWidth((Texture*) pTexture, 0U);
    if ((uint) num4 > \u003CModule\u003E.FableMod\u002EGfx\u002ETexture\u002EGetHeight((Texture*) pTexture, 0U))
      num4 = (int) \u003CModule\u003E.FableMod\u002EGfx\u002ETexture\u002EGetHeight((Texture*) pTexture, 0U);
    *(int*) pArea = num5;
    *(int*) ((IntPtr) pArea + 4L) = num6;
    *(int*) ((IntPtr) pArea + 8L) = num3;
    *(int*) ((IntPtr) pArea + 12L) = num4;
  }

  internal static unsafe Spatial* FableMod\u002EGfx\u002EIntegration\u002E\u003FA0x98271962\u002EGetIDObject(
    Spatial* pSpatial)
  {
    if (*(int*) ((IntPtr) pSpatial + 272L) == 0)
    {
      do
      {
        ulong num = (ulong) *(long*) ((IntPtr) pSpatial + 24L);
        if (num != 0UL)
          pSpatial = (Spatial*) num;
        else
          goto label_4;
      }
      while (*(int*) ((IntPtr) pSpatial + 272L) == 0);
      goto label_3;
label_4:
      return (Spatial*) 0L;
    }
label_3:
    return pSpatial;
  }

  internal static unsafe SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E\u002E\u003D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AMesh\u003E* obj0,
    Mesh* pObject)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if ((long) num1 != (IntPtr) pObject)
    {
      if (num1 != 0UL)
      {
        RootObject* rootObjectPtr = (RootObject*) num1;
        uint num2 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
        if (num2 > 0U)
          *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num2 - 1;
        if (*(int*) ((IntPtr) rootObjectPtr + 8L) == 0)
        {
          Mesh* meshPtr1 = (Mesh*) *(long*) ((IntPtr) obj0 + 8L);
          if ((IntPtr) meshPtr1 != IntPtr.Zero)
          {
            Mesh* meshPtr2 = meshPtr1;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) meshPtr1)((IntPtr) meshPtr2, 1U);
          }
        }
      }
      *(long*) ((IntPtr) obj0 + 8L) = (long) pObject;
      if ((IntPtr) pObject != IntPtr.Zero)
        *(int*) ((IntPtr) pObject + 8L) = *(int*) ((IntPtr) pObject + 8L) + 1;
    }
    return obj0;
  }

  internal static unsafe SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E\u002E\u007Bctor\u007D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E* obj0,
    ArrowheadModel* pObject)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VArrowheadModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    *(long*) ((IntPtr) obj0 + 8L) = (long) pObject;
    if ((IntPtr) pObject != IntPtr.Zero)
      *(int*) ((IntPtr) pObject + 8L) = *(int*) ((IntPtr) pObject + 8L) + 1;
    return obj0;
  }

  internal static unsafe void FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E\u002E\u007Bdtor\u007D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VArrowheadModel\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (num1 == 0UL)
      return;
    RootObject* rootObjectPtr = (RootObject*) num1;
    uint num2 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
    if (num2 > 0U)
      *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num2 - 1;
    if (*(int*) ((IntPtr) rootObjectPtr + 8L) != 0)
      return;
    ArrowheadModel* arrowheadModelPtr1 = (ArrowheadModel*) *(long*) ((IntPtr) obj0 + 8L);
    if ((IntPtr) arrowheadModelPtr1 != IntPtr.Zero)
    {
      ArrowheadModel* arrowheadModelPtr2 = arrowheadModelPtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) arrowheadModelPtr1)((IntPtr) arrowheadModelPtr2, 1U);
    }
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
  }

  internal static unsafe void* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E\u002E__vecDelDtor(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E* gfxArrowheadModelPtr = (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E*) ((IntPtr) obj0 - 8L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL /*0x10*/, *(int*) gfxArrowheadModelPtr, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) gfxArrowheadModelPtr);
      return (void*) gfxArrowheadModelPtr;
    }
    \u003CModule\u003E.FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AArrowheadModel\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static float fabs(float _X) => (float) Math.Abs((double) _X);

  internal static unsafe sbyte* FableMod\u002EGfx\u002EIntegration\u002ECopyXFileSafeString(
    sbyte* src)
  {
    sbyte* numPtr1 = src;
    sbyte num1 = *src;
    if (num1 != (sbyte) 0)
    {
      do
      {
        ++numPtr1;
      }
      while (*numPtr1 != (sbyte) 0);
    }
    int num2 = (int) ((IntPtr) numPtr1 - (IntPtr) src);
    sbyte* numPtr2;
    if (num1 >= (sbyte) 48 /*0x30*/ && num1 <= (sbyte) 57)
    {
      ++num2;
      numPtr2 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (num2 + 1));
      sbyte* numPtr3 = src;
      long num3 = (long) ((IntPtr) numPtr2 - (IntPtr) src + 1L);
      sbyte num4;
      do
      {
        num4 = *numPtr3;
        *(sbyte*) (num3 + (IntPtr) numPtr3) = num4;
        ++numPtr3;
      }
      while (num4 != (sbyte) 0);
      *numPtr2 = (sbyte) 88;
    }
    else
    {
      numPtr2 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (num2 + 1));
      sbyte* numPtr4 = src;
      long num5 = (long) ((IntPtr) numPtr2 - (IntPtr) src);
      sbyte num6;
      do
      {
        num6 = *numPtr4;
        *(sbyte*) (num5 + (IntPtr) numPtr4) = num6;
        ++numPtr4;
      }
      while (num6 != (sbyte) 0);
    }
    long num7 = (long) num2;
    if (0L < num7)
    {
      sbyte* numPtr5 = numPtr2;
      ulong num8 = (ulong) num7;
      do
      {
        sbyte num9 = *numPtr5;
        *numPtr5 = num9 != (sbyte) 32 /*0x20*/ ? (num9 == (sbyte) 35 ? (sbyte) 95 : *numPtr5) : (sbyte) 45;
        ++numPtr5;
        --num8;
      }
      while (num8 > 0UL);
    }
    return numPtr2;
  }

  internal static unsafe sbyte* FableMod\u002EGfx\u002EIntegration\u002EStringFromXFileString(
    sbyte* src)
  {
    sbyte* numPtr1 = src;
    sbyte num1 = *src;
    if (num1 != (sbyte) 0)
    {
      do
      {
        ++numPtr1;
      }
      while (*numPtr1 != (sbyte) 0);
    }
    int num2 = (int) ((IntPtr) numPtr1 - (IntPtr) src);
    sbyte* numPtr2;
    if (num1 == (sbyte) 88)
    {
      numPtr2 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (num2 + 1));
      sbyte* numPtr3 = src + 1L;
      sbyte* numPtr4 = numPtr3;
      long num3 = (long) ((IntPtr) numPtr2 - (IntPtr) numPtr3);
      sbyte num4;
      do
      {
        num4 = *numPtr4;
        *(sbyte*) (num3 + (IntPtr) numPtr4) = num4;
        ++numPtr4;
      }
      while (num4 != (sbyte) 0);
    }
    else
    {
      numPtr2 = (sbyte*) \u003CModule\u003E.new\u005B\u005D((ulong) (num2 + 1));
      sbyte* numPtr5 = src;
      long num5 = (long) ((IntPtr) numPtr2 - (IntPtr) src);
      sbyte num6;
      do
      {
        num6 = *numPtr5;
        *(sbyte*) (num5 + (IntPtr) numPtr5) = num6;
        ++numPtr5;
      }
      while (num6 != (sbyte) 0);
    }
    long num7 = (long) num2;
    if (0L < num7)
    {
      sbyte* numPtr6 = numPtr2;
      ulong num8 = (ulong) num7;
      do
      {
        sbyte* numPtr7 = numPtr6;
        int num9 = *numPtr7 == (sbyte) 45 ? 32 /*0x20*/ : (int) *numPtr6;
        *numPtr7 = (sbyte) num9;
        ++numPtr6;
        --num8;
      }
      while (num8 > 0UL);
    }
    return numPtr2;
  }

  internal static unsafe void* FableMod\u002EGfx\u002EException\u002E__vecDelDtor(
    [In] FableMod.Gfx.Exception* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FableMod.Gfx.Exception* exceptionPtr = (FableMod.Gfx.Exception*) ((IntPtr) obj0 - 8L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL /*0x10*/, *(int*) exceptionPtr, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002EException\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) exceptionPtr);
      return (void*) exceptionPtr;
    }
    \u003CModule\u003E.FableMod\u002EGfx\u002EException\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATerrain\u003E\u002E\u007Bdtor\u007D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATerrain\u003E* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VTerrain\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (num1 == 0UL)
      return;
    RootObject* rootObjectPtr = (RootObject*) num1;
    uint num2 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
    if (num2 > 0U)
      *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num2 - 1;
    if (*(int*) ((IntPtr) rootObjectPtr + 8L) != 0)
      return;
    Terrain* terrainPtr1 = (Terrain*) *(long*) ((IntPtr) obj0 + 8L);
    if ((IntPtr) terrainPtr1 != IntPtr.Zero)
    {
      Terrain* terrainPtr2 = terrainPtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) terrainPtr1)((IntPtr) terrainPtr2, 1U);
    }
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
  }

  internal static unsafe void* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATerrain\u003E\u002E__vecDelDtor(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATerrain\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATerrain\u003E* fableModGfxTerrainPtr = (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATerrain\u003E*) ((IntPtr) obj0 - 8L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL /*0x10*/, *(int*) fableModGfxTerrainPtr, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATerrain\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) fableModGfxTerrainPtr);
      return (void*) fableModGfxTerrainPtr;
    }
    \u003CModule\u003E.FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003ATerrain\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AEditableTexture\u003E\u002E__vecDelDtor(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AEditableTexture\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AEditableTexture\u003E* gfxEditableTexturePtr = (SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AEditableTexture\u003E*) ((IntPtr) obj0 - 8L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL /*0x10*/, *(int*) gfxEditableTexturePtr, (__FnPtr<void (void*)>) __methodptr(FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AEditableTexture\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) gfxEditableTexturePtr);
      return (void*) gfxEditableTexturePtr;
    }
    \u003CModule\u003E.FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AEditableTexture\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FableMod\u002EGfx\u002ESmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AEditableTexture\u003E\u002E\u007Bdtor\u007D(
    [In] SmartPointer\u003CFableMod\u003A\u003AGfx\u003A\u003AEditableTexture\u003E* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024SmartPointer\u0040VEditableTexture\u0040Gfx\u0040FableMod\u0040\u0040\u0040Gfx\u0040FableMod\u0040\u00406B\u0040;
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 8L);
    if (num1 == 0UL)
      return;
    RootObject* rootObjectPtr = (RootObject*) num1;
    uint num2 = (uint) *(int*) ((IntPtr) rootObjectPtr + 8L);
    if (num2 > 0U)
      *(int*) ((IntPtr) rootObjectPtr + 8L) = (int) num2 - 1;
    if (*(int*) ((IntPtr) rootObjectPtr + 8L) != 0)
      return;
    EditableTexture* editableTexturePtr1 = (EditableTexture*) *(long*) ((IntPtr) obj0 + 8L);
    if ((IntPtr) editableTexturePtr1 != IntPtr.Zero)
    {
      EditableTexture* editableTexturePtr2 = editableTexturePtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) editableTexturePtr1)((IntPtr) editableTexturePtr2, 1U);
    }
    *(long*) ((IntPtr) obj0 + 8L) = 0L;
  }

  internal static unsafe float FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetX(
    [In] PackedXYZ* obj0)
  {
    int num = *(int*) obj0 & 2047 /*0x07FF*/;
    if (num > 1023 /*0x03FF*/)
      num += -2048;
    return (float) num / 1023f;
  }

  internal static unsafe float FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetY(
    [In] PackedXYZ* obj0)
  {
    int num = *(int*) obj0 >>> 11 & 2047 /*0x07FF*/;
    if (num > 1023 /*0x03FF*/)
      num += -2048;
    return (float) num / 1023f;
  }

  internal static unsafe float FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetZ(
    [In] PackedXYZ* obj0)
  {
    int num = *(int*) obj0 >>> 22;
    if (num > 511 /*0x01FF*/)
      num += -1024;
    return (float) num / 511f;
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002EVGRP\u002E\u007Bdtor\u007D(
    [In] VGRP* obj0)
  {
    if (*(long*) ((IntPtr) obj0 + 4L) == 0L)
      return;
    uint num1 = 0;
    if (0U < (uint) *(int*) obj0)
    {
      long num2 = 0;
      do
      {
        VGRPSub* vgrpSubPtr = (VGRPSub*) *(long*) (num2 + *(long*) ((IntPtr) obj0 + 4L));
        if ((IntPtr) vgrpSubPtr != IntPtr.Zero)
        {
          ulong num3 = (ulong) *(long*) ((IntPtr) vgrpSubPtr + 8L);
          if (num3 != 0UL)
            \u003CModule\u003E.delete\u005B\u005D((void*) num3);
          \u003CModule\u003E.delete((void*) vgrpSubPtr);
        }
        ++num1;
        num2 += 8L;
      }
      while (num1 < (uint) *(int*) obj0);
    }
    \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 4L));
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ECLTH\u002E\u007Bdtor\u007D(
    [In] CLTH* obj0)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 99L);
    if (num1 != 0UL)
      \u003CModule\u003E.delete\u005B\u005D((void*) num1);
    ulong num2 = (ulong) *(long*) ((IntPtr) obj0 + 111L);
    if (num2 != 0UL)
      \u003CModule\u003E.delete\u005B\u005D((void*) num2);
    ulong num3 = (ulong) *(long*) ((IntPtr) obj0 + 83L);
    if (num3 != 0UL)
      \u003CModule\u003E.delete\u005B\u005D((void*) num3);
    ulong num4 = (ulong) *(long*) ((IntPtr) obj0 + 123L);
    if (num4 != 0UL)
      \u003CModule\u003E.delete\u005B\u005D((void*) num4);
    ulong num5 = (ulong) *(long*) ((IntPtr) obj0 + 44L);
    if (num5 != 0UL)
      \u003CModule\u003E.delete\u005B\u005D((void*) num5);
    ulong num6 = (ulong) *(long*) ((IntPtr) obj0 + 20L);
    if (num6 != 0UL)
      \u003CModule\u003E.delete\u005B\u005D((void*) num6);
    ulong num7 = (ulong) *(long*) ((IntPtr) obj0 + 135L);
    if (num7 != 0UL)
      \u003CModule\u003E.delete\u005B\u005D((void*) num7);
    ulong num8 = (ulong) *(long*) ((IntPtr) obj0 + 147L);
    if (num8 != 0UL)
      \u003CModule\u003E.delete\u005B\u005D((void*) num8);
    if (*(long*) ((IntPtr) obj0 + 160L /*0xA0*/) == 0L)
      return;
    int num9 = 0;
    if (0U < (uint) *(int*) ((IntPtr) obj0 + 156L))
    {
      long num10 = 0;
      do
      {
        VGRP* vgrpPtr = (VGRP*) *(long*) (num10 + *(long*) ((IntPtr) obj0 + 160L /*0xA0*/));
        if ((IntPtr) vgrpPtr != IntPtr.Zero)
        {
          \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EVGRP\u002E\u007Bdtor\u007D(vgrpPtr);
          \u003CModule\u003E.delete((void*) vgrpPtr);
        }
        ++num9;
        num10 += 8L;
      }
      while ((uint) num9 < (uint) *(int*) ((IntPtr) obj0 + 156L));
    }
    \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 160L /*0xA0*/));
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ESUBM\u002E\u007Bdtor\u007D(
    [In] SUBM* obj0)
  {
    ulong num1 = (ulong) *(long*) ((IntPtr) obj0 + 60L);
    if (num1 != 0UL)
      \u003CModule\u003E.delete\u005B\u005D((void*) num1);
    if (*(long*) ((IntPtr) obj0 + 68L) != 0L)
    {
      int num2 = 0;
      if (0U < (uint) *(int*) ((IntPtr) obj0 + 32L /*0x20*/))
      {
        long num3 = 0;
        do
        {
          SUBM_SUB_CHUNK_2* submSubChunk2Ptr = (SUBM_SUB_CHUNK_2*) *(long*) (num3 + *(long*) ((IntPtr) obj0 + 68L));
          if ((IntPtr) submSubChunk2Ptr != IntPtr.Zero)
          {
            ulong num4 = (ulong) *(long*) ((IntPtr) submSubChunk2Ptr + 19L);
            if (num4 != 0UL)
              \u003CModule\u003E.delete\u005B\u005D((void*) num4);
            \u003CModule\u003E.delete((void*) submSubChunk2Ptr);
          }
          ++num2;
          num3 += 8L;
        }
        while ((uint) num2 < (uint) *(int*) ((IntPtr) obj0 + 32L /*0x20*/));
      }
      \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 68L));
    }
    ulong num5 = (ulong) *(long*) ((IntPtr) obj0 + 124L);
    if (num5 != 0UL)
      \u003CModule\u003E.delete\u005B\u005D((void*) num5);
    ulong num6 = (ulong) *(long*) ((IntPtr) obj0 + 116L);
    if (num6 != 0UL)
      \u003CModule\u003E.delete\u005B\u005D((void*) num6);
    if (*(long*) ((IntPtr) obj0 + 136L) == 0L)
      return;
    int num7 = 0;
    if (0U < (uint) *(int*) ((IntPtr) obj0 + 132L))
    {
      long num8 = 0;
      do
      {
        CLTH* clthPtr = (CLTH*) *(long*) (*(long*) ((IntPtr) obj0 + 136L) + num8);
        if ((IntPtr) clthPtr != IntPtr.Zero)
        {
          \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002ECLTH\u002E\u007Bdtor\u007D(clthPtr);
          \u003CModule\u003E.delete((void*) clthPtr);
        }
        ++num7;
        num8 += 8L;
      }
      while ((uint) num7 < (uint) *(int*) ((IntPtr) obj0 + 132L));
    }
    \u003CModule\u003E.delete\u005B\u005D((void*) *(long*) ((IntPtr) obj0 + 136L));
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ESUBM\u002EGetVertices(
    [In] SUBM* obj0,
    Vertex* vertices)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 108L);
    if (num1 == 12U && *(int*) ((IntPtr) obj0 + 48L /*0x30*/) == 4)
    {
      Vertex_12_4* vertex124Ptr1 = (Vertex_12_4*) *(long*) ((IntPtr) obj0 + 116L);
      long num2 = (long) *(int*) ((IntPtr) obj0 + 36L);
      if (0L >= num2)
        return;
      SUBM* submPtr1 = (SUBM*) ((IntPtr) obj0 + 76L);
      SUBM* submPtr2 = (SUBM*) ((IntPtr) obj0 + 80L /*0x50*/);
      SUBM* submPtr3 = (SUBM*) ((IntPtr) obj0 + 84L);
      SUBM* submPtr4 = (SUBM*) ((IntPtr) obj0 + 92L);
      SUBM* submPtr5 = (SUBM*) ((IntPtr) obj0 + 96L /*0x60*/);
      SUBM* submPtr6 = (SUBM*) ((IntPtr) obj0 + 100L);
      Vertex_12_4* vertex124Ptr2 = (Vertex_12_4*) ((IntPtr) vertex124Ptr1 + 4L);
      Vertex* vertexPtr1 = (Vertex*) ((IntPtr) vertices + 8L);
      ulong num3 = (ulong) num2;
      do
      {
        int num4 = *(int*) ((IntPtr) vertex124Ptr2 - 4L) & 2047 /*0x07FF*/;
        if (num4 > 1023 /*0x03FF*/)
          num4 += -2048;
        float num5 = (float) num4 / 1023f;
        *(float*) ((IntPtr) vertexPtr1 - 8L) = num5;
        int num6 = *(int*) ((IntPtr) vertex124Ptr2 - 4L) >>> 11 & 2047 /*0x07FF*/;
        if (num6 > 1023 /*0x03FF*/)
          num6 += -2048;
        float num7 = (float) num6 / 1023f;
        *(float*) ((IntPtr) vertexPtr1 - 4L) = num7;
        int num8 = *(int*) ((IntPtr) vertex124Ptr2 - 4L) >>> 22;
        if (num8 > 511 /*0x01FF*/)
          num8 += -1024;
        float num9 = (float) num8 / 511f;
        *(float*) vertexPtr1 = num9;
        float num10 = num5 * *(float*) submPtr1;
        *(float*) ((IntPtr) vertexPtr1 - 8L) = num10;
        *(float*) ((IntPtr) vertexPtr1 - 4L) = num7 * *(float*) submPtr2;
        *(float*) vertexPtr1 = num9 * *(float*) submPtr3;
        *(float*) ((IntPtr) vertexPtr1 - 8L) = num10 + *(float*) submPtr4;
        *(float*) ((IntPtr) vertexPtr1 - 4L) = *(float*) ((IntPtr) vertexPtr1 - 4L) + *(float*) submPtr5;
        Vertex* vertexPtr2 = vertexPtr1;
        double num11 = (double) (*(float*) vertexPtr2 + *(float*) submPtr6);
        *(float*) vertexPtr2 = (float) num11;
        int num12 = *(int*) vertex124Ptr2 & 2047 /*0x07FF*/;
        if (num12 > 1023 /*0x03FF*/)
          num12 += -2048;
        *(float*) ((IntPtr) vertexPtr1 + 4L) = (float) num12 / 1023f;
        int num13 = *(int*) vertex124Ptr2 >>> 11 & 2047 /*0x07FF*/;
        if (num13 > 1023 /*0x03FF*/)
          num13 += -2048;
        *(float*) ((IntPtr) vertexPtr1 + 8L) = (float) num13 / 1023f;
        int num14 = *(int*) vertex124Ptr2 >>> 22;
        if (num14 > 511 /*0x01FF*/)
          num14 += -1024;
        *(float*) ((IntPtr) vertexPtr1 + 12L) = (float) num14 / 511f;
        *(float*) ((IntPtr) vertexPtr1 + 16L /*0x10*/) = (float) *(short*) ((IntPtr) vertex124Ptr2 + 4L) * 0.00048828125f;
        *(float*) ((IntPtr) vertexPtr1 + 20L) = (float) *(short*) ((IntPtr) vertex124Ptr2 + 6L) * 0.00048828125f;
        vertex124Ptr2 += 12L;
        vertexPtr1 += 32L /*0x20*/;
        --num3;
      }
      while (num3 > 0UL);
    }
    else if (num1 == 20U && *(int*) ((IntPtr) obj0 + 48L /*0x30*/) == 4)
    {
      Vertex_20_4* vertex204Ptr1 = (Vertex_20_4*) *(long*) ((IntPtr) obj0 + 116L);
      int num15 = *(int*) ((IntPtr) obj0 + 36L);
      int num16 = 0;
      long num17 = (long) num15;
      if (0L >= num17)
        return;
      SUBM* submPtr7 = (SUBM*) ((IntPtr) obj0 + 76L);
      SUBM* submPtr8 = (SUBM*) ((IntPtr) obj0 + 80L /*0x50*/);
      SUBM* submPtr9 = (SUBM*) ((IntPtr) obj0 + 84L);
      SUBM* submPtr10 = (SUBM*) ((IntPtr) obj0 + 92L);
      SUBM* submPtr11 = (SUBM*) ((IntPtr) obj0 + 96L /*0x60*/);
      SUBM* submPtr12 = (SUBM*) ((IntPtr) obj0 + 100L);
      Vertex_20_4* vertex204Ptr2 = (Vertex_20_4*) ((IntPtr) vertex204Ptr1 + 16L /*0x10*/);
      Vertex* vertexPtr = (Vertex*) ((IntPtr) vertices + 8L);
      ulong num18 = (ulong) num17;
      do
      {
        Vertex_20_4* vertex204Ptr3 = (Vertex_20_4*) ((long) num16 * 20L + (IntPtr) vertex204Ptr1);
        float x = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetX((PackedXYZ*) vertex204Ptr3);
        *(float*) ((IntPtr) vertexPtr - 8L) = x;
        float y = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetY((PackedXYZ*) vertex204Ptr3);
        *(float*) ((IntPtr) vertexPtr - 4L) = y;
        float z = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetZ((PackedXYZ*) vertex204Ptr3);
        *(float*) vertexPtr = z;
        float num19 = x * *(float*) submPtr7;
        *(float*) ((IntPtr) vertexPtr - 8L) = num19;
        *(float*) ((IntPtr) vertexPtr - 4L) = y * *(float*) submPtr8;
        *(float*) vertexPtr = z * *(float*) submPtr9;
        *(float*) ((IntPtr) vertexPtr - 8L) = num19 + *(float*) submPtr10;
        *(float*) ((IntPtr) vertexPtr - 4L) = *(float*) ((IntPtr) vertexPtr - 4L) + *(float*) submPtr11;
        *(float*) vertexPtr = *(float*) submPtr12 + *(float*) vertexPtr;
        Vertex_20_4* vertex204Ptr4 = (Vertex_20_4*) ((IntPtr) vertex204Ptr3 + 12L);
        *(float*) ((IntPtr) vertexPtr + 4L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetX((PackedXYZ*) vertex204Ptr4);
        *(float*) ((IntPtr) vertexPtr + 8L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetY((PackedXYZ*) vertex204Ptr4);
        *(float*) ((IntPtr) vertexPtr + 12L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetZ((PackedXYZ*) vertex204Ptr4);
        *(float*) ((IntPtr) vertexPtr + 16L /*0x10*/) = (float) *(short*) vertex204Ptr2 * 0.00048828125f;
        *(float*) ((IntPtr) vertexPtr + 20L) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex204Ptr3 + 18L));
        ++num16;
        vertex204Ptr2 += 20L;
        vertexPtr += 32L /*0x20*/;
        --num18;
      }
      while (num18 > 0UL);
    }
    else if (num1 == 20U && *(int*) ((IntPtr) obj0 + 48L /*0x30*/) == 6)
    {
      Vertex_20_6* vertex206Ptr1 = (Vertex_20_6*) *(long*) ((IntPtr) obj0 + 116L);
      int num20 = *(int*) ((IntPtr) obj0 + 36L);
      int num21 = 0;
      long num22 = (long) num20;
      if (0L >= num22)
        return;
      SUBM* submPtr13 = (SUBM*) ((IntPtr) obj0 + 76L);
      SUBM* submPtr14 = (SUBM*) ((IntPtr) obj0 + 80L /*0x50*/);
      SUBM* submPtr15 = (SUBM*) ((IntPtr) obj0 + 84L);
      SUBM* submPtr16 = (SUBM*) ((IntPtr) obj0 + 92L);
      SUBM* submPtr17 = (SUBM*) ((IntPtr) obj0 + 96L /*0x60*/);
      SUBM* submPtr18 = (SUBM*) ((IntPtr) obj0 + 100L);
      Vertex* vertexPtr = (Vertex*) ((IntPtr) vertices + 8L);
      ulong num23 = (ulong) num22;
      do
      {
        Vertex_20_6* vertex206Ptr2 = (Vertex_20_6*) ((long) num21 * 20L + (IntPtr) vertex206Ptr1);
        float x = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetX((PackedXYZ*) vertex206Ptr2);
        *(float*) ((IntPtr) vertexPtr - 8L) = x;
        float y = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetY((PackedXYZ*) vertex206Ptr2);
        *(float*) ((IntPtr) vertexPtr - 4L) = y;
        float z = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetZ((PackedXYZ*) vertex206Ptr2);
        *(float*) vertexPtr = z;
        float num24 = x * *(float*) submPtr13;
        *(float*) ((IntPtr) vertexPtr - 8L) = num24;
        *(float*) ((IntPtr) vertexPtr - 4L) = y * *(float*) submPtr14;
        *(float*) vertexPtr = z * *(float*) submPtr15;
        *(float*) ((IntPtr) vertexPtr - 8L) = num24 + *(float*) submPtr16;
        *(float*) ((IntPtr) vertexPtr - 4L) = *(float*) ((IntPtr) vertexPtr - 4L) + *(float*) submPtr17;
        *(float*) vertexPtr = *(float*) submPtr18 + *(float*) vertexPtr;
        Vertex_20_6* vertex206Ptr3 = (Vertex_20_6*) ((IntPtr) vertex206Ptr2 + 4L);
        *(float*) ((IntPtr) vertexPtr + 4L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetX((PackedXYZ*) vertex206Ptr3);
        *(float*) ((IntPtr) vertexPtr + 8L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetY((PackedXYZ*) vertex206Ptr3);
        *(float*) ((IntPtr) vertexPtr + 12L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetZ((PackedXYZ*) vertex206Ptr3);
        *(float*) ((IntPtr) vertexPtr + 16L /*0x10*/) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex206Ptr2 + 8L));
        *(float*) ((IntPtr) vertexPtr + 20L) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex206Ptr2 + 10L));
        ++num21;
        vertexPtr += 32L /*0x20*/;
        --num23;
      }
      while (num23 > 0UL);
    }
    else if (num1 == 20U && *(int*) ((IntPtr) obj0 + 48L /*0x30*/) == 20)
    {
      Vertex_20_20* vertex2020Ptr1 = (Vertex_20_20*) *(long*) ((IntPtr) obj0 + 116L);
      int num25 = *(int*) ((IntPtr) obj0 + 36L);
      int num26 = 0;
      long num27 = (long) num25;
      if (0L >= num27)
        return;
      SUBM* submPtr19 = (SUBM*) ((IntPtr) obj0 + 76L);
      SUBM* submPtr20 = (SUBM*) ((IntPtr) obj0 + 80L /*0x50*/);
      SUBM* submPtr21 = (SUBM*) ((IntPtr) obj0 + 84L);
      SUBM* submPtr22 = (SUBM*) ((IntPtr) obj0 + 92L);
      SUBM* submPtr23 = (SUBM*) ((IntPtr) obj0 + 96L /*0x60*/);
      SUBM* submPtr24 = (SUBM*) ((IntPtr) obj0 + 100L);
      Vertex* vertexPtr3 = (Vertex*) ((IntPtr) vertices + 8L);
      Vertex_20_20* vertex2020Ptr2 = (Vertex_20_20*) ((IntPtr) vertex2020Ptr1 + 8L);
      ulong num28 = (ulong) num27;
      do
      {
        float num29 = *(float*) ((IntPtr) vertex2020Ptr2 - 8L);
        *(float*) ((IntPtr) vertexPtr3 - 8L) = num29;
        *(float*) ((IntPtr) vertexPtr3 - 4L) = *(float*) ((IntPtr) vertex2020Ptr2 - 4L);
        *(float*) vertexPtr3 = *(float*) vertex2020Ptr2;
        float num30 = num29 * *(float*) submPtr19;
        *(float*) ((IntPtr) vertexPtr3 - 8L) = num30;
        *(float*) ((IntPtr) vertexPtr3 - 4L) = *(float*) ((IntPtr) vertexPtr3 - 4L) * *(float*) submPtr20;
        Vertex* vertexPtr4 = vertexPtr3;
        double num31 = (double) (*(float*) vertexPtr4 * *(float*) submPtr21);
        *(float*) vertexPtr4 = (float) num31;
        *(float*) ((IntPtr) vertexPtr3 - 8L) = num30 + *(float*) submPtr22;
        *(float*) ((IntPtr) vertexPtr3 - 4L) = *(float*) ((IntPtr) vertexPtr3 - 4L) + *(float*) submPtr23;
        Vertex* vertexPtr5 = vertexPtr3;
        double num32 = (double) (*(float*) vertexPtr5 + *(float*) submPtr24);
        *(float*) vertexPtr5 = (float) num32;
        Vertex_20_20* vertex2020Ptr3 = (Vertex_20_20*) ((long) num26 * 20L + (IntPtr) vertex2020Ptr1);
        Vertex_20_20* vertex2020Ptr4 = (Vertex_20_20*) ((IntPtr) vertex2020Ptr3 + 12L);
        *(float*) ((IntPtr) vertexPtr3 + 4L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetX((PackedXYZ*) vertex2020Ptr4);
        *(float*) ((IntPtr) vertexPtr3 + 8L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetY((PackedXYZ*) vertex2020Ptr4);
        *(float*) ((IntPtr) vertexPtr3 + 12L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetZ((PackedXYZ*) vertex2020Ptr4);
        *(float*) ((IntPtr) vertexPtr3 + 16L /*0x10*/) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex2020Ptr3 + 16L /*0x10*/));
        *(float*) ((IntPtr) vertexPtr3 + 20L) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex2020Ptr3 + 18L));
        ++num26;
        vertex2020Ptr2 += 20L;
        vertexPtr3 += 32L /*0x20*/;
        --num28;
      }
      while (num28 > 0UL);
    }
    else if (num1 == 28U && *(int*) ((IntPtr) obj0 + 48L /*0x30*/) == 6)
    {
      Vertex_28_6* vertex286Ptr1 = (Vertex_28_6*) *(long*) ((IntPtr) obj0 + 116L);
      int num33 = *(int*) ((IntPtr) obj0 + 36L);
      int num34 = 0;
      long num35 = (long) num33;
      if (0L >= num35)
        return;
      SUBM* submPtr25 = (SUBM*) ((IntPtr) obj0 + 76L);
      SUBM* submPtr26 = (SUBM*) ((IntPtr) obj0 + 80L /*0x50*/);
      SUBM* submPtr27 = (SUBM*) ((IntPtr) obj0 + 84L);
      SUBM* submPtr28 = (SUBM*) ((IntPtr) obj0 + 92L);
      SUBM* submPtr29 = (SUBM*) ((IntPtr) obj0 + 96L /*0x60*/);
      SUBM* submPtr30 = (SUBM*) ((IntPtr) obj0 + 100L);
      Vertex* vertexPtr = (Vertex*) ((IntPtr) vertices + 8L);
      ulong num36 = (ulong) num35;
      do
      {
        Vertex_28_6* vertex286Ptr2 = (Vertex_28_6*) ((long) num34 * 28L + (IntPtr) vertex286Ptr1);
        float x = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetX((PackedXYZ*) vertex286Ptr2);
        *(float*) ((IntPtr) vertexPtr - 8L) = x;
        float y = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetY((PackedXYZ*) vertex286Ptr2);
        *(float*) ((IntPtr) vertexPtr - 4L) = y;
        float z = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetZ((PackedXYZ*) vertex286Ptr2);
        *(float*) vertexPtr = z;
        float num37 = x * *(float*) submPtr25;
        *(float*) ((IntPtr) vertexPtr - 8L) = num37;
        *(float*) ((IntPtr) vertexPtr - 4L) = y * *(float*) submPtr26;
        *(float*) vertexPtr = z * *(float*) submPtr27;
        *(float*) ((IntPtr) vertexPtr - 8L) = num37 + *(float*) submPtr28;
        *(float*) ((IntPtr) vertexPtr - 4L) = *(float*) ((IntPtr) vertexPtr - 4L) + *(float*) submPtr29;
        *(float*) vertexPtr = *(float*) submPtr30 + *(float*) vertexPtr;
        Vertex_28_6* vertex286Ptr3 = (Vertex_28_6*) ((IntPtr) vertex286Ptr2 + 12L);
        *(float*) ((IntPtr) vertexPtr + 4L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetX((PackedXYZ*) vertex286Ptr3);
        *(float*) ((IntPtr) vertexPtr + 8L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetY((PackedXYZ*) vertex286Ptr3);
        *(float*) ((IntPtr) vertexPtr + 12L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetZ((PackedXYZ*) vertex286Ptr3);
        *(float*) ((IntPtr) vertexPtr + 16L /*0x10*/) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex286Ptr2 + 16L /*0x10*/));
        *(float*) ((IntPtr) vertexPtr + 20L) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex286Ptr2 + 18L));
        ++num34;
        vertexPtr += 32L /*0x20*/;
        --num36;
      }
      while (num36 > 0UL);
    }
    else if (num1 == 28U && *(int*) ((IntPtr) obj0 + 48L /*0x30*/) == 20)
    {
      Vertex_28_20* vertex2820Ptr1 = (Vertex_28_20*) *(long*) ((IntPtr) obj0 + 116L);
      int num38 = *(int*) ((IntPtr) obj0 + 36L);
      int num39 = 0;
      long num40 = (long) num38;
      if (0L >= num40)
        return;
      SUBM* submPtr31 = (SUBM*) ((IntPtr) obj0 + 76L);
      SUBM* submPtr32 = (SUBM*) ((IntPtr) obj0 + 80L /*0x50*/);
      SUBM* submPtr33 = (SUBM*) ((IntPtr) obj0 + 84L);
      SUBM* submPtr34 = (SUBM*) ((IntPtr) obj0 + 92L);
      SUBM* submPtr35 = (SUBM*) ((IntPtr) obj0 + 96L /*0x60*/);
      SUBM* submPtr36 = (SUBM*) ((IntPtr) obj0 + 100L);
      Vertex* vertexPtr6 = (Vertex*) ((IntPtr) vertices + 8L);
      Vertex_28_20* vertex2820Ptr2 = (Vertex_28_20*) ((IntPtr) vertex2820Ptr1 + 8L);
      ulong num41 = (ulong) num40;
      do
      {
        float num42 = *(float*) ((IntPtr) vertex2820Ptr2 - 8L);
        *(float*) ((IntPtr) vertexPtr6 - 8L) = num42;
        *(float*) ((IntPtr) vertexPtr6 - 4L) = *(float*) ((IntPtr) vertex2820Ptr2 - 4L);
        *(float*) vertexPtr6 = *(float*) vertex2820Ptr2;
        float num43 = num42 * *(float*) submPtr31;
        *(float*) ((IntPtr) vertexPtr6 - 8L) = num43;
        *(float*) ((IntPtr) vertexPtr6 - 4L) = *(float*) ((IntPtr) vertexPtr6 - 4L) * *(float*) submPtr32;
        Vertex* vertexPtr7 = vertexPtr6;
        double num44 = (double) (*(float*) vertexPtr7 * *(float*) submPtr33);
        *(float*) vertexPtr7 = (float) num44;
        *(float*) ((IntPtr) vertexPtr6 - 8L) = num43 + *(float*) submPtr34;
        *(float*) ((IntPtr) vertexPtr6 - 4L) = *(float*) ((IntPtr) vertexPtr6 - 4L) + *(float*) submPtr35;
        Vertex* vertexPtr8 = vertexPtr6;
        double num45 = (double) (*(float*) vertexPtr8 + *(float*) submPtr36);
        *(float*) vertexPtr8 = (float) num45;
        Vertex_28_20* vertex2820Ptr3 = (Vertex_28_20*) ((long) num39 * 28L + (IntPtr) vertex2820Ptr1);
        Vertex_28_20* vertex2820Ptr4 = (Vertex_28_20*) ((IntPtr) vertex2820Ptr3 + 20L);
        *(float*) ((IntPtr) vertexPtr6 + 4L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetX((PackedXYZ*) vertex2820Ptr4);
        *(float*) ((IntPtr) vertexPtr6 + 8L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetY((PackedXYZ*) vertex2820Ptr4);
        *(float*) ((IntPtr) vertexPtr6 + 12L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetZ((PackedXYZ*) vertex2820Ptr4);
        *(float*) ((IntPtr) vertexPtr6 + 16L /*0x10*/) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex2820Ptr3 + 24L));
        *(float*) ((IntPtr) vertexPtr6 + 20L) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex2820Ptr3 + 26L));
        ++num39;
        vertex2820Ptr2 += 28L;
        vertexPtr6 += 32L /*0x20*/;
        --num41;
      }
      while (num41 > 0UL);
    }
    else if (num1 == 28U && *(int*) ((IntPtr) obj0 + 48L /*0x30*/) == 22)
    {
      Vertex_28_22* vertex2822Ptr1 = (Vertex_28_22*) *(long*) ((IntPtr) obj0 + 116L);
      int num46 = *(int*) ((IntPtr) obj0 + 36L);
      int num47 = 0;
      long num48 = (long) num46;
      if (0L >= num48)
        return;
      SUBM* submPtr37 = (SUBM*) ((IntPtr) obj0 + 76L);
      SUBM* submPtr38 = (SUBM*) ((IntPtr) obj0 + 80L /*0x50*/);
      SUBM* submPtr39 = (SUBM*) ((IntPtr) obj0 + 84L);
      SUBM* submPtr40 = (SUBM*) ((IntPtr) obj0 + 92L);
      SUBM* submPtr41 = (SUBM*) ((IntPtr) obj0 + 96L /*0x60*/);
      SUBM* submPtr42 = (SUBM*) ((IntPtr) obj0 + 100L);
      Vertex* vertexPtr9 = (Vertex*) ((IntPtr) vertices + 8L);
      Vertex_28_22* vertex2822Ptr2 = (Vertex_28_22*) ((IntPtr) vertex2822Ptr1 + 8L);
      ulong num49 = (ulong) num48;
      do
      {
        float num50 = *(float*) ((IntPtr) vertex2822Ptr2 - 8L);
        *(float*) ((IntPtr) vertexPtr9 - 8L) = num50;
        *(float*) ((IntPtr) vertexPtr9 - 4L) = *(float*) ((IntPtr) vertex2822Ptr2 - 4L);
        *(float*) vertexPtr9 = *(float*) vertex2822Ptr2;
        float num51 = num50 * *(float*) submPtr37;
        *(float*) ((IntPtr) vertexPtr9 - 8L) = num51;
        *(float*) ((IntPtr) vertexPtr9 - 4L) = *(float*) ((IntPtr) vertexPtr9 - 4L) * *(float*) submPtr38;
        Vertex* vertexPtr10 = vertexPtr9;
        double num52 = (double) (*(float*) vertexPtr10 * *(float*) submPtr39);
        *(float*) vertexPtr10 = (float) num52;
        *(float*) ((IntPtr) vertexPtr9 - 8L) = num51 + *(float*) submPtr40;
        *(float*) ((IntPtr) vertexPtr9 - 4L) = *(float*) ((IntPtr) vertexPtr9 - 4L) + *(float*) submPtr41;
        Vertex* vertexPtr11 = vertexPtr9;
        double num53 = (double) (*(float*) vertexPtr11 + *(float*) submPtr42);
        *(float*) vertexPtr11 = (float) num53;
        Vertex_28_22* vertex2822Ptr3 = (Vertex_28_22*) ((long) num47 * 28L + (IntPtr) vertex2822Ptr1);
        Vertex_28_22* vertex2822Ptr4 = (Vertex_28_22*) ((IntPtr) vertex2822Ptr3 + 12L);
        *(float*) ((IntPtr) vertexPtr9 + 4L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetX((PackedXYZ*) vertex2822Ptr4);
        *(float*) ((IntPtr) vertexPtr9 + 8L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetY((PackedXYZ*) vertex2822Ptr4);
        *(float*) ((IntPtr) vertexPtr9 + 12L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetZ((PackedXYZ*) vertex2822Ptr4);
        *(float*) ((IntPtr) vertexPtr9 + 16L /*0x10*/) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex2822Ptr3 + 16L /*0x10*/));
        *(float*) ((IntPtr) vertexPtr9 + 20L) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex2822Ptr3 + 18L));
        ++num47;
        vertex2822Ptr2 += 28L;
        vertexPtr9 += 32L /*0x20*/;
        --num49;
      }
      while (num49 > 0UL);
    }
    else if (num1 == 36U && *(int*) ((IntPtr) obj0 + 48L /*0x30*/) == 4)
    {
      Vertex_36_4* vertex364Ptr1 = (Vertex_36_4*) *(long*) ((IntPtr) obj0 + 116L);
      long num54 = (long) *(int*) ((IntPtr) obj0 + 36L);
      if (0L >= num54)
        return;
      SUBM* submPtr43 = (SUBM*) ((IntPtr) obj0 + 76L);
      SUBM* submPtr44 = (SUBM*) ((IntPtr) obj0 + 80L /*0x50*/);
      SUBM* submPtr45 = (SUBM*) ((IntPtr) obj0 + 84L);
      SUBM* submPtr46 = (SUBM*) ((IntPtr) obj0 + 92L);
      SUBM* submPtr47 = (SUBM*) ((IntPtr) obj0 + 96L /*0x60*/);
      SUBM* submPtr48 = (SUBM*) ((IntPtr) obj0 + 100L);
      Vertex* vertexPtr12 = (Vertex*) ((IntPtr) vertices + 8L);
      Vertex_36_4* vertex364Ptr2 = (Vertex_36_4*) ((IntPtr) vertex364Ptr1 + 8L);
      ulong num55 = (ulong) num54;
      do
      {
        float num56 = *(float*) ((IntPtr) vertex364Ptr2 - 8L);
        *(float*) ((IntPtr) vertexPtr12 - 8L) = num56;
        *(float*) ((IntPtr) vertexPtr12 - 4L) = *(float*) ((IntPtr) vertex364Ptr2 - 4L);
        *(float*) vertexPtr12 = *(float*) vertex364Ptr2;
        float num57 = num56 * *(float*) submPtr43;
        *(float*) ((IntPtr) vertexPtr12 - 8L) = num57;
        *(float*) ((IntPtr) vertexPtr12 - 4L) = *(float*) ((IntPtr) vertexPtr12 - 4L) * *(float*) submPtr44;
        Vertex* vertexPtr13 = vertexPtr12;
        double num58 = (double) (*(float*) vertexPtr13 * *(float*) submPtr45);
        *(float*) vertexPtr13 = (float) num58;
        *(float*) ((IntPtr) vertexPtr12 - 8L) = num57 + *(float*) submPtr46;
        *(float*) ((IntPtr) vertexPtr12 - 4L) = *(float*) ((IntPtr) vertexPtr12 - 4L) + *(float*) submPtr47;
        *(float*) vertexPtr12 = *(float*) submPtr48 + *(float*) vertexPtr12;
        *(float*) ((IntPtr) vertexPtr12 + 4L) = *(float*) ((IntPtr) vertex364Ptr2 + 4L);
        *(float*) ((IntPtr) vertexPtr12 + 8L) = *(float*) ((IntPtr) vertex364Ptr2 + 8L);
        *(float*) ((IntPtr) vertexPtr12 + 12L) = *(float*) ((IntPtr) vertex364Ptr2 + 12L);
        *(float*) ((IntPtr) vertexPtr12 + 16L /*0x10*/) = *(float*) ((IntPtr) vertex364Ptr2 + 16L /*0x10*/);
        *(float*) ((IntPtr) vertexPtr12 + 20L) = *(float*) ((IntPtr) vertex364Ptr2 + 20L);
        vertex364Ptr2 += 36L;
        vertexPtr12 += 32L /*0x20*/;
        --num55;
      }
      while (num55 > 0UL);
    }
    else
    {
      if (num1 != 36U || *(int*) ((IntPtr) obj0 + 48L /*0x30*/) != 22)
        throw new InvalidOperationException("Unknown compiledmodel vertex format");
      Vertex_36_22* vertex3622Ptr1 = (Vertex_36_22*) *(long*) ((IntPtr) obj0 + 116L);
      int num59 = *(int*) ((IntPtr) obj0 + 36L);
      int num60 = 0;
      long num61 = (long) num59;
      if (0L >= num61)
        return;
      SUBM* submPtr49 = (SUBM*) ((IntPtr) obj0 + 76L);
      SUBM* submPtr50 = (SUBM*) ((IntPtr) obj0 + 80L /*0x50*/);
      SUBM* submPtr51 = (SUBM*) ((IntPtr) obj0 + 84L);
      SUBM* submPtr52 = (SUBM*) ((IntPtr) obj0 + 92L);
      SUBM* submPtr53 = (SUBM*) ((IntPtr) obj0 + 96L /*0x60*/);
      SUBM* submPtr54 = (SUBM*) ((IntPtr) obj0 + 100L);
      Vertex* vertexPtr14 = (Vertex*) ((IntPtr) vertices + 8L);
      Vertex_36_22* vertex3622Ptr2 = (Vertex_36_22*) ((IntPtr) vertex3622Ptr1 + 8L);
      ulong num62 = (ulong) num61;
      do
      {
        float num63 = *(float*) ((IntPtr) vertex3622Ptr2 - 8L);
        *(float*) ((IntPtr) vertexPtr14 - 8L) = num63;
        *(float*) ((IntPtr) vertexPtr14 - 4L) = *(float*) ((IntPtr) vertex3622Ptr2 - 4L);
        *(float*) vertexPtr14 = *(float*) vertex3622Ptr2;
        float num64 = num63 * *(float*) submPtr49;
        *(float*) ((IntPtr) vertexPtr14 - 8L) = num64;
        *(float*) ((IntPtr) vertexPtr14 - 4L) = *(float*) ((IntPtr) vertexPtr14 - 4L) * *(float*) submPtr50;
        Vertex* vertexPtr15 = vertexPtr14;
        double num65 = (double) (*(float*) vertexPtr15 * *(float*) submPtr51);
        *(float*) vertexPtr15 = (float) num65;
        *(float*) ((IntPtr) vertexPtr14 - 8L) = num64 + *(float*) submPtr52;
        *(float*) ((IntPtr) vertexPtr14 - 4L) = *(float*) ((IntPtr) vertexPtr14 - 4L) + *(float*) submPtr53;
        *(float*) vertexPtr14 = *(float*) submPtr54 + *(float*) vertexPtr14;
        Vertex_36_22* vertex3622Ptr3 = (Vertex_36_22*) ((long) num60 * 36L + (IntPtr) vertex3622Ptr1);
        Vertex_36_22* vertex3622Ptr4 = (Vertex_36_22*) ((IntPtr) vertex3622Ptr3 + 20L);
        *(float*) ((IntPtr) vertexPtr14 + 4L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetX((PackedXYZ*) vertex3622Ptr4);
        *(float*) ((IntPtr) vertexPtr14 + 8L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetY((PackedXYZ*) vertex3622Ptr4);
        *(float*) ((IntPtr) vertexPtr14 + 12L) = \u003CModule\u003E.FableMod\u002EGfx\u002EIntegration\u002EPackedXYZ\u002EGetZ((PackedXYZ*) vertex3622Ptr4);
        *(float*) ((IntPtr) vertexPtr14 + 16L /*0x10*/) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex3622Ptr3 + 24L));
        *(float*) ((IntPtr) vertexPtr14 + 20L) = \u003CModule\u003E.CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM((CTFixed\u003Cshort\u002C11\u002C2048\u003E*) ((IntPtr) vertex3622Ptr3 + 26L));
        ++num60;
        vertex3622Ptr2 += 36L;
        vertexPtr14 += 32L /*0x20*/;
        --num62;
      }
      while (num62 > 0UL);
    }
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ESUBM\u002EGetFaces(
    [In] SUBM* obj0,
    ushort* faces,
    VertexBones* bones)
  {
    ushort* numPtr1 = (ushort*) *(long*) ((IntPtr) obj0 + 124L);
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    if (0U < (uint) *(int*) ((IntPtr) obj0 + 28L))
    {
      SUBM* submPtr = (SUBM*) ((IntPtr) obj0 + 60L);
      long num4 = 0;
      do
      {
        SUBM_SUB_CHUNK_1* submSubChunk1Ptr = (SUBM_SUB_CHUNK_1*) (num4 + *(long*) submPtr);
        if (*(ushort*) ((IntPtr) submSubChunk1Ptr + 8L) == (ushort) 1)
        {
          uint num5 = (uint) *(int*) ((IntPtr) submSubChunk1Ptr + 4L);
          bool flag = (~(int) num5 & 1) != 0;
          int num6 = (int) num5;
          long num7 = (long) num6;
          if ((uint) num6 < num5 + (uint) *(int*) submSubChunk1Ptr)
          {
            ushort* numPtr2 = (ushort*) ((num7 + 1L) * 2L + (IntPtr) numPtr1);
            do
            {
              if (num6 % 2 == 0)
              {
                ushort num8 = *(ushort*) ((IntPtr) numPtr2 - 2L);
                ushort num9 = *numPtr2;
                if ((int) num8 != (int) num9)
                {
                  ushort num10 = *(ushort*) ((IntPtr) numPtr2 + 2L);
                  ushort num11 = num10;
                  if ((int) num8 != (int) num11 && (int) num11 != (int) num9)
                  {
                    if (flag)
                    {
                      *(short*) ((long) num1 * 2L + (IntPtr) faces) = (short) num10;
                      int num12 = num1 + 1;
                      *(short*) ((long) num12 * 2L + (IntPtr) faces) = (short) *numPtr2;
                      int num13 = num12 + 1;
                      *(short*) ((long) num13 * 2L + (IntPtr) faces) = (short) *(ushort*) ((IntPtr) numPtr2 - 2L);
                      num1 = num13 + 1;
                    }
                    else
                    {
                      *(short*) ((long) num1 * 2L + (IntPtr) faces) = (short) num8;
                      int num14 = num1 + 1;
                      *(short*) ((long) num14 * 2L + (IntPtr) faces) = (short) *numPtr2;
                      int num15 = num14 + 1;
                      *(short*) ((long) num15 * 2L + (IntPtr) faces) = (short) *(ushort*) ((IntPtr) numPtr2 + 2L);
                      num1 = num15 + 1;
                    }
                    ++num2;
                  }
                }
              }
              else
              {
                ushort num16 = *(ushort*) ((IntPtr) numPtr2 - 2L);
                ushort num17 = *numPtr2;
                ushort num18 = num17;
                if ((int) num16 != (int) num18)
                {
                  ushort num19 = *(ushort*) ((IntPtr) numPtr2 + 2L);
                  if ((int) num16 != (int) num19 && (int) num19 != (int) num18)
                  {
                    if (flag)
                    {
                      *(short*) ((long) num1 * 2L + (IntPtr) faces) = (short) num17;
                      int num20 = num1 + 1;
                      *(short*) ((long) num20 * 2L + (IntPtr) faces) = (short) *(ushort*) ((IntPtr) numPtr2 + 2L);
                      int num21 = num20 + 1;
                      *(short*) ((long) num21 * 2L + (IntPtr) faces) = (short) *(ushort*) ((IntPtr) numPtr2 - 2L);
                      num1 = num21 + 1;
                    }
                    else
                    {
                      *(short*) ((long) num1 * 2L + (IntPtr) faces) = (short) num16;
                      int num22 = num1 + 1;
                      *(short*) ((long) num22 * 2L + (IntPtr) faces) = (short) *(ushort*) ((IntPtr) numPtr2 + 2L);
                      int num23 = num22 + 1;
                      *(short*) ((long) num23 * 2L + (IntPtr) faces) = (short) *numPtr2;
                      num1 = num23 + 1;
                    }
                    ++num2;
                  }
                }
              }
              ++num6;
              numPtr2 += 2L;
            }
            while ((uint) num6 < (uint) (*(int*) ((IntPtr) submSubChunk1Ptr + 4L) + *(int*) submSubChunk1Ptr));
          }
        }
        else
        {
          uint num24 = (uint) *(int*) ((IntPtr) submSubChunk1Ptr + 4L);
          int num25 = (int) num24;
          long num26 = (long) num25;
          long num27 = (long) num1;
          if ((uint) num25 < (uint) (*(int*) submSubChunk1Ptr * 3) + num24)
          {
            ushort* numPtr3 = (ushort*) (num27 * 2L + (IntPtr) faces);
            ushort* numPtr4 = (ushort*) ((num26 + 1L) * 2L + (IntPtr) numPtr1);
            do
            {
              *numPtr3 = *(ushort*) ((IntPtr) numPtr4 + 2L);
              ushort* numPtr5 = (ushort*) ((IntPtr) numPtr3 + 2L);
              *numPtr5 = *numPtr4;
              ushort* numPtr6 = (ushort*) ((IntPtr) numPtr5 + 2L);
              *numPtr6 = *(ushort*) ((IntPtr) numPtr4 - 2L);
              num1 += 3;
              numPtr3 = (ushort*) ((IntPtr) numPtr6 + 2L);
              ++num2;
              num25 += 3;
              numPtr4 += 6L;
            }
            while ((uint) num25 < (uint) (*(int*) submSubChunk1Ptr * 3 + *(int*) ((IntPtr) submSubChunk1Ptr + 4L)));
          }
        }
        ++num3;
        num4 += 15L;
      }
      while ((uint) num3 < (uint) *(int*) ((IntPtr) obj0 + 28L));
    }
    ushort num28 = ushort.MaxValue;
    int num29 = num2 * 3;
    if (0 < num29)
    {
      ushort* numPtr7 = faces;
      uint num30 = (uint) num29;
      do
      {
        ushort num31 = *numPtr7;
        num28 = (uint) num31 < (uint) num28 ? num31 : num28;
        numPtr7 += 2L;
        num30 += uint.MaxValue;
      }
      while (num30 > 0U);
    }
    if (0 < num29)
    {
      ushort* numPtr8 = faces;
      uint num32 = (uint) num29;
      do
      {
        ushort* numPtr9 = numPtr8;
        int num33 = (int) *numPtr9 - (int) num28;
        *numPtr9 = (ushort) num33;
        numPtr8 += 2L;
        num32 += uint.MaxValue;
      }
      while (num32 > 0U);
    }
    int num34 = 0;
    if (0U >= (uint) *(int*) ((IntPtr) obj0 + 32L /*0x20*/))
      return;
    long num35 = 0;
    do
    {
      long num36 = *(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L));
      if (*(ushort*) (num36 + 8L) == (ushort) 1)
      {
        int num37 = *(int*) (num36 + 4L);
        int num38 = num37;
        long num39 = (long) num38;
        long num40 = *(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L));
        if ((uint) num38 < (uint) (*(int*) (num40 + 4L) + *(int*) num40))
        {
          ushort* numPtr10 = (ushort*) ((num39 + 1L) * 2L + (IntPtr) numPtr1);
          long num41;
          do
          {
            if (num38 % 2 == 0)
            {
              ushort num42 = *(ushort*) ((IntPtr) numPtr10 - 2L);
              ushort num43 = *numPtr10;
              if ((int) num42 != (int) num43)
              {
                ushort num44 = *(ushort*) ((IntPtr) numPtr10 + 2L);
                ushort num45 = num44;
                if ((int) num42 != (int) num45 && (int) num45 != (int) num43)
                {
                  if ((num37 & 1) == 0)
                  {
                    *(short*) ((long) num1 * 2L + (IntPtr) faces) = (short) num44;
                    int num46 = num1 + 1;
                    *(short*) ((long) num46 * 2L + (IntPtr) faces) = (short) *numPtr10;
                    int num47 = num46 + 1;
                    *(short*) ((long) num47 * 2L + (IntPtr) faces) = (short) *(ushort*) ((IntPtr) numPtr10 - 2L);
                    num1 = num47 + 1;
                  }
                  else
                  {
                    *(short*) ((long) num1 * 2L + (IntPtr) faces) = (short) num42;
                    int num48 = num1 + 1;
                    *(short*) ((long) num48 * 2L + (IntPtr) faces) = (short) *numPtr10;
                    int num49 = num48 + 1;
                    *(short*) ((long) num49 * 2L + (IntPtr) faces) = (short) *(ushort*) ((IntPtr) numPtr10 + 2L);
                    num1 = num49 + 1;
                  }
                }
              }
            }
            else
            {
              ushort num50 = *(ushort*) ((IntPtr) numPtr10 - 2L);
              ushort num51 = *numPtr10;
              ushort num52 = num51;
              if ((int) num50 != (int) num52)
              {
                ushort num53 = *(ushort*) ((IntPtr) numPtr10 + 2L);
                if ((int) num50 != (int) num53 && (int) num53 != (int) num52)
                {
                  if ((num37 & 1) == 0)
                  {
                    *(short*) ((long) num1 * 2L + (IntPtr) faces) = (short) num51;
                    int num54 = num1 + 1;
                    *(short*) ((long) num54 * 2L + (IntPtr) faces) = (short) *(ushort*) ((IntPtr) numPtr10 + 2L);
                    int num55 = num54 + 1;
                    *(short*) ((long) num55 * 2L + (IntPtr) faces) = (short) *(ushort*) ((IntPtr) numPtr10 - 2L);
                    num1 = num55 + 1;
                  }
                  else
                  {
                    *(short*) ((long) num1 * 2L + (IntPtr) faces) = (short) num50;
                    int num56 = num1 + 1;
                    *(short*) ((long) num56 * 2L + (IntPtr) faces) = (short) *(ushort*) ((IntPtr) numPtr10 + 2L);
                    int num57 = num56 + 1;
                    *(short*) ((long) num57 * 2L + (IntPtr) faces) = (short) *numPtr10;
                    num1 = num57 + 1;
                  }
                }
              }
            }
            if ((IntPtr) bones != IntPtr.Zero)
            {
              long num58 = (long) num1;
              ushort* numPtr11 = (ushort*) ((num58 - 3L) * 2L + (IntPtr) faces);
              if (*(byte*) ((IntPtr) bones + (long) *numPtr11 * 9L + 8L) == (byte) 0)
              {
                IntPtr num59 = (long) *numPtr11 * 9L + (IntPtr) bones;
                *(sbyte*) num59 = (sbyte) *(byte*) ((long) ((int) *(byte*) num59 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num60 = *numPtr11;
                IntPtr num61 = (IntPtr) bones + (long) num60 * 9L + 1L;
                *(sbyte*) num61 = (sbyte) *(byte*) ((long) ((int) *(byte*) num61 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num62 = *numPtr11;
                IntPtr num63 = (IntPtr) bones + (long) num62 * 9L + 2L;
                *(sbyte*) num63 = (sbyte) *(byte*) ((long) ((int) *(byte*) num63 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num64 = *numPtr11;
                IntPtr num65 = (IntPtr) bones + (long) num64 * 9L + 3L;
                *(sbyte*) num65 = (sbyte) *(byte*) ((long) ((int) *(byte*) num65 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                *(sbyte*) ((IntPtr) bones + (long) *numPtr11 * 9L + 8L) = (sbyte) 1;
              }
              ushort* numPtr12 = (ushort*) ((num58 - 2L) * 2L + (IntPtr) faces);
              if (*(byte*) ((IntPtr) bones + (long) *numPtr12 * 9L + 8L) == (byte) 0)
              {
                IntPtr num66 = (long) *numPtr12 * 9L + (IntPtr) bones;
                *(sbyte*) num66 = (sbyte) *(byte*) ((long) ((int) *(byte*) num66 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num67 = *numPtr12;
                IntPtr num68 = (IntPtr) bones + (long) num67 * 9L + 1L;
                *(sbyte*) num68 = (sbyte) *(byte*) ((long) ((int) *(byte*) num68 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num69 = *numPtr12;
                IntPtr num70 = (IntPtr) bones + (long) num69 * 9L + 2L;
                *(sbyte*) num70 = (sbyte) *(byte*) ((long) ((int) *(byte*) num70 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num71 = *numPtr12;
                IntPtr num72 = (IntPtr) bones + (long) num71 * 9L + 3L;
                *(sbyte*) num72 = (sbyte) *(byte*) ((long) ((int) *(byte*) num72 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                *(sbyte*) ((IntPtr) bones + (long) *numPtr12 * 9L + 8L) = (sbyte) 1;
              }
              ushort* numPtr13 = (ushort*) ((IntPtr) faces + num58 * 2L - 2L);
              if (*(byte*) ((IntPtr) bones + (long) *numPtr13 * 9L + 8L) == (byte) 0)
              {
                IntPtr num73 = (long) *numPtr13 * 9L + (IntPtr) bones;
                *(sbyte*) num73 = (sbyte) *(byte*) ((long) ((int) *(byte*) num73 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num74 = *numPtr13;
                IntPtr num75 = (IntPtr) bones + (long) num74 * 9L + 1L;
                *(sbyte*) num75 = (sbyte) *(byte*) ((long) ((int) *(byte*) num75 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num76 = *numPtr13;
                IntPtr num77 = (IntPtr) bones + (long) num76 * 9L + 2L;
                *(sbyte*) num77 = (sbyte) *(byte*) ((long) ((int) *(byte*) num77 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num78 = *numPtr13;
                IntPtr num79 = (IntPtr) bones + (long) num78 * 9L + 3L;
                *(sbyte*) num79 = (sbyte) *(byte*) ((long) ((int) *(byte*) num79 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                *(sbyte*) ((IntPtr) bones + (long) *numPtr13 * 9L + 8L) = (sbyte) 1;
              }
            }
            ++num38;
            numPtr10 += 2L;
            num41 = *(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L));
            num37 = *(int*) (num41 + 4L);
          }
          while ((uint) num38 < (uint) (*(int*) num41 + num37));
        }
      }
      else
      {
        int num80 = *(int*) (num36 + 4L);
        long num81 = (long) num80;
        long num82 = (long) num1;
        long num83 = *(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L));
        if ((uint) num80 < (uint) (*(int*) (num83 + 4L) + *(int*) num83 * 3))
        {
          ushort* numPtr14 = (ushort*) (num82 * 2L + (IntPtr) faces);
          ushort* numPtr15 = (ushort*) ((num82 - 2L) * 2L + (IntPtr) faces);
          ushort* numPtr16 = (ushort*) ((num82 - 3L) * 2L + (IntPtr) faces);
          ushort* numPtr17 = (ushort*) ((num81 + 1L) * 2L + (IntPtr) numPtr1);
          long num84;
          do
          {
            *numPtr14 = *(ushort*) ((IntPtr) numPtr17 + 2L);
            ushort* numPtr18 = (ushort*) ((IntPtr) numPtr16 + 2L);
            ushort* numPtr19 = (ushort*) ((IntPtr) numPtr15 + 2L);
            ushort* numPtr20 = (ushort*) ((IntPtr) numPtr14 + 2L);
            *numPtr20 = *numPtr17;
            ushort* numPtr21 = (ushort*) ((IntPtr) numPtr18 + 2L);
            ushort* numPtr22 = (ushort*) ((IntPtr) numPtr19 + 2L);
            ushort* numPtr23 = (ushort*) ((IntPtr) numPtr20 + 2L);
            *numPtr23 = *(ushort*) ((IntPtr) numPtr17 - 2L);
            num1 += 3;
            numPtr16 = (ushort*) ((IntPtr) numPtr21 + 2L);
            numPtr15 = (ushort*) ((IntPtr) numPtr22 + 2L);
            numPtr14 = (ushort*) ((IntPtr) numPtr23 + 2L);
            if ((IntPtr) bones != IntPtr.Zero)
            {
              if (*(byte*) ((IntPtr) bones + (long) *numPtr16 * 9L + 8L) == (byte) 0)
              {
                IntPtr num85 = (long) *numPtr16 * 9L + (IntPtr) bones;
                *(sbyte*) num85 = (sbyte) *(byte*) ((long) ((int) *(byte*) num85 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num86 = *numPtr16;
                IntPtr num87 = (IntPtr) bones + (long) num86 * 9L + 1L;
                *(sbyte*) num87 = (sbyte) *(byte*) ((long) ((int) *(byte*) num87 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num88 = *numPtr16;
                IntPtr num89 = (IntPtr) bones + (long) num88 * 9L + 2L;
                *(sbyte*) num89 = (sbyte) *(byte*) ((long) ((int) *(byte*) num89 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num90 = *numPtr16;
                IntPtr num91 = (IntPtr) bones + (long) num90 * 9L + 3L;
                *(sbyte*) num91 = (sbyte) *(byte*) ((long) ((int) *(byte*) num91 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                *(sbyte*) ((IntPtr) bones + (long) *numPtr16 * 9L + 8L) = (sbyte) 1;
              }
              if (*(byte*) ((IntPtr) bones + (long) *numPtr15 * 9L + 8L) == (byte) 0)
              {
                IntPtr num92 = (long) *numPtr15 * 9L + (IntPtr) bones;
                *(sbyte*) num92 = (sbyte) *(byte*) ((long) ((int) *(byte*) num92 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num93 = *numPtr15;
                IntPtr num94 = (IntPtr) bones + (long) num93 * 9L + 1L;
                *(sbyte*) num94 = (sbyte) *(byte*) ((long) ((int) *(byte*) num94 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num95 = *numPtr15;
                IntPtr num96 = (IntPtr) bones + (long) num95 * 9L + 2L;
                *(sbyte*) num96 = (sbyte) *(byte*) ((long) ((int) *(byte*) num96 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num97 = *numPtr15;
                IntPtr num98 = (IntPtr) bones + (long) num97 * 9L + 3L;
                *(sbyte*) num98 = (sbyte) *(byte*) ((long) ((int) *(byte*) num98 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                *(sbyte*) ((IntPtr) bones + (long) *numPtr15 * 9L + 8L) = (sbyte) 1;
              }
              if (*(byte*) ((IntPtr) bones + (long) *(ushort*) ((IntPtr) numPtr14 - 2L) * 9L + 8L) == (byte) 0)
              {
                IntPtr num99 = (long) *(ushort*) ((IntPtr) numPtr14 - 2L) * 9L + (IntPtr) bones;
                *(sbyte*) num99 = (sbyte) *(byte*) ((long) ((int) *(byte*) num99 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num100 = *(ushort*) ((IntPtr) numPtr14 - 2L);
                IntPtr num101 = (IntPtr) bones + (long) num100 * 9L + 1L;
                *(sbyte*) num101 = (sbyte) *(byte*) ((long) ((int) *(byte*) num101 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num102 = *(ushort*) ((IntPtr) numPtr14 - 2L);
                IntPtr num103 = (IntPtr) bones + (long) num102 * 9L + 2L;
                *(sbyte*) num103 = (sbyte) *(byte*) ((long) ((int) *(byte*) num103 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                ushort num104 = *(ushort*) ((IntPtr) numPtr14 - 2L);
                IntPtr num105 = (IntPtr) bones + (long) num104 * 9L + 3L;
                *(sbyte*) num105 = (sbyte) *(byte*) ((long) ((int) *(byte*) num105 / 3) + *(long*) (*(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L)) + 19L));
                *(sbyte*) ((IntPtr) bones + (long) *(ushort*) ((IntPtr) numPtr14 - 2L) * 9L + 8L) = (sbyte) 1;
              }
            }
            num80 += 3;
            numPtr17 += 6L;
            num84 = *(long*) (num35 + *(long*) ((IntPtr) obj0 + 68L));
          }
          while ((uint) num80 < (uint) (*(int*) num84 * 3 + *(int*) (num84 + 4L)));
        }
      }
      ++num34;
      num35 += 8L;
    }
    while ((uint) num34 < (uint) *(int*) ((IntPtr) obj0 + 32L /*0x20*/));
  }

  internal static unsafe void FableMod\u002EGfx\u002EIntegration\u002ESUBM\u002EGetVertexBones(
    [In] SUBM* obj0,
    VertexBones* bones)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 108L);
    if (num1 == 20U && *(int*) ((IntPtr) obj0 + 48L /*0x30*/) == 4)
    {
      Vertex_20_4* vertex204Ptr1 = (Vertex_20_4*) *(long*) ((IntPtr) obj0 + 116L);
      long num2 = (long) *(int*) ((IntPtr) obj0 + 36L);
      if (0L >= num2)
        return;
      VertexBones* vertexBonesPtr = bones;
      Vertex_20_4* vertex204Ptr2 = (Vertex_20_4*) ((IntPtr) vertex204Ptr1 + 4L);
      ulong num3 = (ulong) num2;
      do
      {
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) vertexBonesPtr, (IntPtr) vertex204Ptr2, 8);
        *(sbyte*) ((IntPtr) vertexBonesPtr + 8L) = (sbyte) 0;
        vertex204Ptr2 += 20L;
        vertexBonesPtr += 9L;
        --num3;
      }
      while (num3 > 0UL);
    }
    else if (num1 == 28U && *(int*) ((IntPtr) obj0 + 48L /*0x30*/) == 6)
    {
      Vertex_28_6* vertex286Ptr1 = (Vertex_28_6*) *(long*) ((IntPtr) obj0 + 116L);
      long num4 = (long) *(int*) ((IntPtr) obj0 + 36L);
      if (0L >= num4)
        return;
      VertexBones* vertexBonesPtr = bones;
      Vertex_28_6* vertex286Ptr2 = (Vertex_28_6*) ((IntPtr) vertex286Ptr1 + 4L);
      ulong num5 = (ulong) num4;
      do
      {
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) vertexBonesPtr, (IntPtr) vertex286Ptr2, 8);
        *(sbyte*) ((IntPtr) vertexBonesPtr + 8L) = (sbyte) 0;
        vertex286Ptr2 += 28L;
        vertexBonesPtr += 9L;
        --num5;
      }
      while (num5 > 0UL);
    }
    else if (num1 == 28U && *(int*) ((IntPtr) obj0 + 48L /*0x30*/) == 20)
    {
      Vertex_28_20* vertex2820Ptr1 = (Vertex_28_20*) *(long*) ((IntPtr) obj0 + 116L);
      long num6 = (long) *(int*) ((IntPtr) obj0 + 36L);
      if (0L >= num6)
        return;
      VertexBones* vertexBonesPtr = bones;
      Vertex_28_20* vertex2820Ptr2 = (Vertex_28_20*) ((IntPtr) vertex2820Ptr1 + 12L);
      ulong num7 = (ulong) num6;
      do
      {
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) vertexBonesPtr, (IntPtr) vertex2820Ptr2, 8);
        *(sbyte*) ((IntPtr) vertexBonesPtr + 8L) = (sbyte) 0;
        vertex2820Ptr2 += 28L;
        vertexBonesPtr += 9L;
        --num7;
      }
      while (num7 > 0UL);
    }
    else
    {
      if (num1 != 36U || *(int*) ((IntPtr) obj0 + 48L /*0x30*/) != 22)
        throw new System.Exception("Sorry, just had an aneurysm: Unknown vertex format.");
      Vertex_36_22* vertex3622Ptr1 = (Vertex_36_22*) *(long*) ((IntPtr) obj0 + 116L);
      long num8 = (long) *(int*) ((IntPtr) obj0 + 36L);
      if (0L >= num8)
        return;
      VertexBones* vertexBonesPtr = bones;
      Vertex_36_22* vertex3622Ptr2 = (Vertex_36_22*) ((IntPtr) vertex3622Ptr1 + 12L);
      ulong num9 = (ulong) num8;
      do
      {
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) vertexBonesPtr, (IntPtr) vertex3622Ptr2, 8);
        *(sbyte*) ((IntPtr) vertexBonesPtr + 8L) = (sbyte) 0;
        vertex3622Ptr2 += 36L;
        vertexBonesPtr += 9L;
        --num9;
      }
      while (num9 > 0UL);
    }
  }

  internal static unsafe float CTFixed\u003Cshort\u002C11\u002C2048\u003E\u002E\u002EM(
    [In] CTFixed\u003Cshort\u002C11\u002C2048\u003E* obj0)
  {
    return (float) *(short*) obj0 * 0.00048828125f;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode()
  {
    return (\u003CModule\u003E.__native_dllmain_reason != uint.MaxValue ? 1 : 0) == 0 || (\u003CModule\u003E.__native_vcclrit_reason != uint.MaxValue ? 1 : 0) != 0 || \u003CModule\u003E.__native_dllmain_reason != 1U && \u003CModule\u003E.__native_dllmain_reason != 0U;
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(
    System.Exception innerException,
    System.Exception nestedException)
  {
    throw new ModuleLoadExceptionHandlerException("A nested exception occurred after the primary exception that caused the C++ module to fail to load.\n", innerException, nestedException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    string errorMessage)
  {
    throw new ModuleLoadException(errorMessage);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    string errorMessage,
    System.Exception innerException)
  {
    throw new ModuleLoadException(errorMessage, innerException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(
    EventHandler handler)
  {
    ModuleUninitializer._ModuleUninitializer.AddHandler(handler);
  }

  [SecuritySafeCritical]
  internal static unsafe Guid \u003CCrtImplementationDetails\u003E\u002EFromGUID(_GUID* guid)
  {
    return new Guid((uint) *(int*) guid, *(ushort*) ((IntPtr) guid + 4L), *(ushort*) ((IntPtr) guid + 6L), *(byte*) ((IntPtr) guid + 8L), *(byte*) ((IntPtr) guid + 9L), *(byte*) ((IntPtr) guid + 10L), *(byte*) ((IntPtr) guid + 11L), *(byte*) ((IntPtr) guid + 12L), *(byte*) ((IntPtr) guid + 13L), *(byte*) ((IntPtr) guid + 14L), *(byte*) ((IntPtr) guid + 15L));
  }

  [SecurityCritical]
  internal static unsafe int __get_default_appdomain(IUnknown** ppUnk)
  {
    ICorRuntimeHost* icorRuntimeHostPtr1 = (ICorRuntimeHost*) 0L;
    int defaultAppdomain;
    try
    {
      Guid riid = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EFromGUID((_GUID*) &\u003CModule\u003E._GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e);
      icorRuntimeHostPtr1 = (ICorRuntimeHost*) RuntimeEnvironment.GetRuntimeInterfaceAsIntPtr(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EFromGUID((_GUID*) &\u003CModule\u003E._GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e), riid).ToPointer();
      goto label_4;
    }
    catch (System.Exception ex)
    {
      defaultAppdomain = Marshal.GetHRForException(ex);
    }
    if (defaultAppdomain < 0)
      goto label_5;
label_4:
    ICorRuntimeHost* icorRuntimeHostPtr2 = icorRuntimeHostPtr1;
    IUnknown** iunknownPtr = ppUnk;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    defaultAppdomain = __calli((__FnPtr<int (IntPtr, IUnknown**)>) *(long*) (*(long*) icorRuntimeHostPtr1 + 104L))((IntPtr) icorRuntimeHostPtr2, iunknownPtr);
    ICorRuntimeHost* icorRuntimeHostPtr3 = icorRuntimeHostPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(long*) (*(long*) icorRuntimeHostPtr3 + 16L /*0x10*/))((IntPtr) icorRuntimeHostPtr3);
label_5:
    return defaultAppdomain;
  }

  internal static unsafe void __release_appdomain(IUnknown* ppUnk)
  {
    IUnknown* iunknownPtr = ppUnk;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(long*) (*(long*) iunknownPtr + 16L /*0x10*/))((IntPtr) iunknownPtr);
  }

  [SecurityCritical]
  internal static unsafe AppDomain \u003CCrtImplementationDetails\u003E\u002EGetDefaultDomain()
  {
    IUnknown* ppUnk = (IUnknown*) 0L;
    int defaultAppdomain = \u003CModule\u003E.__get_default_appdomain(&ppUnk);
    if (defaultAppdomain >= 0)
    {
      try
      {
        return (AppDomain) Marshal.GetObjectForIUnknown(new IntPtr((void*) ppUnk));
      }
      finally
      {
        \u003CModule\u003E.__release_appdomain(ppUnk);
      }
    }
    else
    {
      Marshal.ThrowExceptionForHR(defaultAppdomain);
      return (AppDomain) null;
    }
  }

  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain(
    __FnPtr<int (void*)> function,
    void* cookie)
  {
    Guid riid = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EFromGUID((_GUID*) &\u003CModule\u003E._GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02);
    ICLRRuntimeHost* pointer = (ICLRRuntimeHost*) RuntimeEnvironment.GetRuntimeInterfaceAsIntPtr(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EFromGUID((_GUID*) &\u003CModule\u003E._GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02), riid).ToPointer();
    try
    {
      AppDomain defaultDomain = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EGetDefaultDomain();
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int errorCode = __calli((__FnPtr<int (IntPtr, uint, __FnPtr<int (void*)>, void*)>) *(long*) (*(long*) pointer + 64L /*0x40*/))((IntPtr) pointer, (uint) defaultDomain.Id, function, cookie);
      if (errorCode >= 0)
        return;
      Marshal.ThrowExceptionForHR(errorCode);
    }
    finally
    {
      ICLRRuntimeHost* iclrRuntimeHostPtr = pointer;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(long*) (*(long*) iclrRuntimeHostPtr + 16L /*0x10*/))((IntPtr) iclrRuntimeHostPtr);
    }
  }

  [SecuritySafeCritical]
  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EDoNothing(
    void* cookie)
  {
    GC.KeepAlive((object) int.MaxValue);
    return 0;
  }

  [SecuritySafeCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess()
  {
    if (\u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr = (void**) &\u003CModule\u003E.\u003FA0x54b01a5b\u002E__xc_mp_a;
    if (ref \u003CModule\u003E.\u003FA0x54b01a5b\u002E__xc_mp_a < ref \u003CModule\u003E.\u003FA0x54b01a5b\u002E__xc_mp_z)
    {
      while (*(long*) voidPtr == 0L)
      {
        voidPtr += 8L;
        if ((IntPtr) voidPtr >= ref \u003CModule\u003E.\u003FA0x54b01a5b\u002E__xc_mp_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [SecuritySafeCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative()
  {
    if (\u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr1 = (void**) &\u003CModule\u003E.__xi_a;
    if (ref \u003CModule\u003E.__xi_a < ref \u003CModule\u003E.__xi_z)
    {
      while (*(long*) voidPtr1 == 0L)
      {
        voidPtr1 += 8L;
        if ((IntPtr) voidPtr1 >= ref \u003CModule\u003E.__xi_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    void** voidPtr2 = (void**) &\u003CModule\u003E.__xc_a;
    if (ref \u003CModule\u003E.__xc_a < ref \u003CModule\u003E.__xc_z)
    {
      while (*(long*) voidPtr2 == 0L)
      {
        voidPtr2 += 8L;
        if ((IntPtr) voidPtr2 >= ref \u003CModule\u003E.__xc_z)
          goto label_9;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_9:
    \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [SecuritySafeCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization()
  {
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess() && !\u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA || \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative() && !\u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA && \u003CModule\u003E.__native_startup_state == (__enative_startup_state) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsUninitialization()
  {
    return \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  }

  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize()
  {
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z, (void*) 0L);
  }

  internal static void \u003FA0x54b01a5b\u002E\u003F\u003F__E\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;
  }

  internal static void \u003FA0x54b01a5b\u002E\u003F\u003F__E\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;
  }

  internal static void \u003FA0x54b01a5b\u002E\u003F\u003F__E\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = false;
  }

  internal static void \u003FA0x54b01a5b\u002E\u003F\u003F__E\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;
  }

  internal static void \u003FA0x54b01a5b\u002E\u003F\u003F__E\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;
  }

  internal static void \u003FA0x54b01a5b\u002E\u003F\u003F__E\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;
  }

  internal static void \u003FA0x54b01a5b\u002E\u003F\u003F__E\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during vtable initialization.\n");
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x54b01a5b\u002E__xi_vt_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x54b01a5b\u002E__xi_vt_z);
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize();
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during native initialization.\n");
    \u003CModule\u003E.__security_init_cookie();
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode())
      \u003CModule\u003E._amsg_exit(33);
    switch (\u003CModule\u003E.__native_startup_state)
    {
      case (__enative_startup_state) 0:
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 1;
        if (\u003CModule\u003E._initterm_e((__FnPtr<int ()>*) &\u003CModule\u003E.__xi_a, (__FnPtr<int ()>*) &\u003CModule\u003E.__xi_z) != 0)
          \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EPE\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0));
        \u003CModule\u003E._initterm((__FnPtr<void ()>*) &\u003CModule\u003E.__xc_a, (__FnPtr<void ()>*) &\u003CModule\u003E.__xc_z);
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 2;
        \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
        break;
      case (__enative_startup_state) 1:
        \u003CModule\u003E._amsg_exit(33);
        break;
    }
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during process initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_m();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x54b01a5b\u002E__xc_mp_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x54b01a5b\u002E__xc_mp_z);
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during appdomain initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_app_domain();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x54b01a5b\u002E__xc_ma_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x54b01a5b\u002E__xc_ma_z);
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during registration for the unload events.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(new EventHandler(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload));
  }

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
    \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA || \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
    void* fiberPtrId = \u003CModule\u003E._getFiberPtrId();
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      while (num2 == 0)
      {
        try
        {
        }
        finally
        {
          // ISSUE: cast to a reference type
          void* voidPtr = (void*) Interlocked.CompareExchange((long&) ref \u003CModule\u003E.__native_startup_lock, (long) fiberPtrId, 0L);
          if ((IntPtr) voidPtr == IntPtr.Zero)
            num2 = 1;
          else if (voidPtr == fiberPtrId)
          {
            num1 = 1;
            num2 = 1;
          }
        }
        if (num2 == 0)
          \u003CModule\u003E.Sleep(1000U);
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(obj0);
      if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      {
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(obj0);
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(obj0);
      }
      else
        num3 = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization() ? 1 : num3;
    }
    finally
    {
      if (num1 == 0)
      {
        // ISSUE: cast to a reference type
        Interlocked.Exchange((long&) ref \u003CModule\u003E.__native_startup_lock, 0L);
      }
    }
    if (num3 != 0)
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(obj0);
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(obj0);
    \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 1;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(obj0);
  }

  [SecurityCritical]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain()
  {
    \u003CModule\u003E._app_exit_callback();
  }

  [SecurityCritical]
  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain(
    void* cookie)
  {
    \u003CModule\u003E._exit_callback();
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    if (\u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
    {
      \u003CModule\u003E._cexit();
      \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 0;
      \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    }
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    return 0;
  }

  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsUninitialization())
      return;
    if (AppDomain.CurrentDomain.IsDefaultAppDomain())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain((void*) 0L);
    }
    else
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z, (void*) 0L);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  [PrePrepareMethod]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload(
    object source,
    EventArgs arguments)
  {
    if (\u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA == 0 || Interlocked.Exchange(ref \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA, 1) != 0)
      return;
    int num = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0 ? 1 : 0;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
    if ((byte) num == (byte) 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(
    [In] LanguageSupport* obj0,
    System.Exception innerException)
  {
    try
    {
      bool flag = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
      if (!flag)
        return;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
    }
    catch (System.Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, (System.Exception) null);
    }
  }

  [SecurityCritical]
  internal static unsafe LanguageSupport* \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
    return obj0;
  }

  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(
    [In] LanguageSupport* obj0)
  {
    bool flag = false;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load.\n");
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        Interlocked.Increment(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA);
        flag = true;
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(obj0);
    }
    catch (System.Exception ex)
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, ex);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EPE\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), ex);
    }
    catch
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, (System.Exception) null);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EPE\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), (System.Exception) null);
    }
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  static unsafe \u003CModule\u003E()
  {
    LanguageSupport languageSupport;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(&languageSupport);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(&languageSupport);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D), (void*) &languageSupport);
    }
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(&languageSupport);
  }

  [SecuritySafeCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0,
    string t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe string gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EPE\u0024AAVString\u0040System\u0040\u0040(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    return (string) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [HandleProcessCorruptedStateExceptions]
  internal static unsafe void __ehvec_dtor(
    void* ptr,
    ulong size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    int num = 0;
    ptr = (void*) ((long) count * (long) size + (IntPtr) ptr);
    try
    {
      while (true)
      {
        count += -1;
        if (count >= 0)
        {
          ptr -= (long) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
      num = 1;
    }
    finally
    {
      if (num == 0)
        \u003CModule\u003E.__ArrayUnwind(ptr, size, count, pDtor);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe int \u003FA0x22d466e6\u002EArrayUnwindFilter(_EXCEPTION_POINTERS* pExPtrs)
  {
    if (*(int*) *(long*) pExPtrs != -529697949)
      return 0;
    \u003CModule\u003E.terminate();
    return 0;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  [HandleProcessCorruptedStateExceptions]
  internal static unsafe void __ArrayUnwind(
    void* ptr,
    ulong size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    try
    {
      while (true)
      {
        count += -1;
        if (count >= 0)
        {
          ptr -= (long) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
    }
    catch (System.Exception ex) when (\u003CModule\u003E.\u003FA0x22d466e6\u002EArrayUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [HandleProcessCorruptedStateExceptions]
  [SecurityCritical]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe void ___CxxCallUnwindDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (System.Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [HandleProcessCorruptedStateExceptions]
  internal static unsafe void __ehvec_ctor(
    void* ptr,
    ulong size,
    int count,
    __FnPtr<void (void*)> pCtor,
    __FnPtr<void (void*)> pDtor)
  {
    int num = 0;
    int count1;
    try
    {
      for (count1 = 0; count1 < count; ++count1)
      {
        void* voidPtr = ptr;
        // ISSUE: function pointer call
        __calli(pCtor)(voidPtr);
        ptr = (void*) ((long) size + (IntPtr) ptr);
      }
      num = 1;
    }
    finally
    {
      if (num == 0)
        \u003CModule\u003E.__ArrayUnwind(ptr, size, count1, pDtor);
    }
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe ValueType \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle()
  {
    return (IntPtr) \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA != IntPtr.Zero ? (ValueType) GCHandle.FromIntPtr(new IntPtr(\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA)) : (ValueType) null;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Construct(
    object value)
  {
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA = (void*) 0L;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(value);
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(
    object value)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA = GCHandle.ToIntPtr(GCHandle.Alloc(value)).ToPointer();
    else
      ((GCHandle) valueType).Target = value;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static object \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    return valueType != null ? ((GCHandle) valueType).Target : (object) null;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      return;
    ((GCHandle) valueType).Free();
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA = (void*) 0L;
  }

  [DebuggerStepThrough]
  [SecuritySafeCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized()
  {
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get() != null;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Construct(new object());
      \u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA = 0;
    }
    ++\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002ERemoveRef()
  {
    \u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA += -1;
    if (\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA != 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct();
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x60cd967c\u002E__alloc_global_lock()
  {
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef();
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized();
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static void \u003FA0x60cd967c\u002E__dealloc_global_lock()
  {
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002ERemoveRef();
  }

  [SecurityCritical]
  internal static unsafe void _exit_callback()
  {
    if (\u003CModule\u003E.\u003FA0x60cd967c\u002E__exit_list_size == 0UL)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.\u003FA0x60cd967c\u002E__onexitbegin_m);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.\u003FA0x60cd967c\u002E__onexitend_m);
    if ((IntPtr) local1 != -1L && (IntPtr) local1 != IntPtr.Zero && (IntPtr) local2 != IntPtr.Zero)
    {
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 8L;
            if (local2 < local1)
              goto label_7;
          }
          while (*(long*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          void* voidPtr = \u003CModule\u003E.DecodePointer((void*) *(long*) local2);
          *(long*) local2 = (long) \u003CModule\u003E._encoded_null();
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (IntPtr) voidPtr)();
          local5 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.\u003FA0x60cd967c\u002E__onexitbegin_m);
          local6 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.\u003FA0x60cd967c\u002E__onexitend_m);
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_7:
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
    }
    \u003CModule\u003E.\u003FA0x60cd967c\u002E__dealloc_global_lock();
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe int _initatexit_m()
  {
    if (!\u003CModule\u003E.\u003FA0x60cd967c\u002E__alloc_global_lock())
      return 0;
    \u003CModule\u003E.\u003FA0x60cd967c\u002E__onexitbegin_m = (__FnPtr<void ()>*) \u003CModule\u003E.EncodePointer(Marshal.AllocHGlobal(256 /*0x0100*/).ToPointer());
    \u003CModule\u003E.\u003FA0x60cd967c\u002E__onexitend_m = \u003CModule\u003E.\u003FA0x60cd967c\u002E__onexitbegin_m;
    \u003CModule\u003E.\u003FA0x60cd967c\u002E__exit_list_size = 32UL /*0x20*/;
    return 1;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe int _initatexit_app_domain()
  {
    if (\u003CModule\u003E.\u003FA0x60cd967c\u002E__alloc_global_lock())
    {
      \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) \u003CModule\u003E.EncodePointer(Marshal.AllocHGlobal(256 /*0x0100*/).ToPointer());
      \u003CModule\u003E.__onexitend_app_domain = \u003CModule\u003E.__onexitbegin_app_domain;
      \u003CModule\u003E.__exit_list_size_app_domain = 32UL /*0x20*/;
    }
    return 1;
  }

  [SecurityCritical]
  [HandleProcessCorruptedStateExceptions]
  internal static unsafe void _app_exit_callback()
  {
    if (\u003CModule\u003E.__exit_list_size_app_domain == 0UL)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitend_app_domain);
    try
    {
      if ((IntPtr) local1 == -1L || (IntPtr) local1 == IntPtr.Zero || (IntPtr) local2 == IntPtr.Zero)
        return;
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 8L;
          }
          while (local2 >= local1 && *(long*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          if (local2 >= local1)
          {
            // ISSUE: cast to a function pointer type
            __FnPtr<void ()> local7 = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.DecodePointer((void*) *(long*) local2);
            *(long*) local2 = (long) \u003CModule\u003E._encoded_null();
            // ISSUE: function pointer call
            __calli(local7)();
            local5 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
            local6 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitend_app_domain);
          }
          else
            goto label_12;
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_12:;
    }
    finally
    {
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
      \u003CModule\u003E.\u003FA0x60cd967c\u002E__dealloc_global_lock();
    }
  }

  [SuppressUnmanagedCodeSecurity]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  [DllImport("KERNEL32.dll")]
  public static extern unsafe void* DecodePointer(void* Ptr);

  [SecurityCritical]
  [SuppressUnmanagedCodeSecurity]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DllImport("MSVCR100.dll", CallingConvention = CallingConvention.Cdecl)]
  public static extern unsafe void* _encoded_null();

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SuppressUnmanagedCodeSecurity]
  [DllImport("KERNEL32.dll")]
  public static extern unsafe void* EncodePointer(void* Ptr);

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe int _initterm_e(__FnPtr<int ()>* pfbegin, __FnPtr<int ()>* pfend)
  {
    int num1 = 0;
    if (pfbegin < pfend)
    {
      while (num1 == 0)
      {
        ulong num2 = (ulong) *(long*) pfbegin;
        if (num2 != 0UL)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          num1 = __calli((__FnPtr<int ()>) (long) num2)();
        }
        pfbegin += 8L;
        if (pfbegin >= pfend)
          break;
      }
    }
    return num1;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void _initterm(__FnPtr<void ()>* pfbegin, __FnPtr<void ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      ulong num = (ulong) *(long*) pfbegin;
      if (num != 0UL)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) (long) num)();
      }
      pfbegin += 8L;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static ModuleHandle \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle()
  {
    return typeof (ThisModule).Module.ModuleHandle;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe void _initterm_m(__FnPtr<void* ()>* pfbegin, __FnPtr<void* ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      ulong methodToken = (ulong) *(long*) pfbegin;
      if (methodToken != 0UL)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E((__FnPtr<void* ()>) (long) methodToken))();
      }
      pfbegin += 8L;
    }
    while (pfbegin < pfend);
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe __FnPtr<void* ()> \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E(
    __FnPtr<void* ()> methodToken)
  {
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void* ()>) (IntPtr) \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle().ResolveMethodHandle((int) methodToken).GetFunctionPointer().ToPointer();
  }

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* new\u005B\u005D([In] ulong obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* @new([In] ulong obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void delete\u005B\u005D([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void delete([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern short GetAsyncKeyState([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXMATRIX* D3DXMatrixInverse(
    [In] D3DXMATRIX* obj0,
    [In] float* obj1,
    [In] D3DXMATRIX* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXMATRIX* D3DXMatrixMultiply(
    [In] D3DXMATRIX* obj0,
    [In] D3DXMATRIX* obj1,
    [In] D3DXMATRIX* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXMatrixDecompose(
    [In] D3DXVECTOR3* obj0,
    [In] D3DXQUATERNION* obj1,
    [In] D3DXVECTOR3* obj2,
    [In] D3DXMATRIX* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXMATRIX* D3DXMatrixTransformation(
    [In] D3DXMATRIX* obj0,
    [In] D3DXVECTOR3* obj1,
    [In] D3DXQUATERNION* obj2,
    [In] D3DXVECTOR3* obj3,
    [In] D3DXVECTOR3* obj4,
    [In] D3DXQUATERNION* obj5,
    [In] D3DXVECTOR3* obj6);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXSaveMeshHierarchyToFileW(
    [In] char* obj0,
    [In] uint obj1,
    [In] _D3DXFRAME* obj2,
    [In] ID3DXAnimationController* obj3,
    [In] ID3DXSaveUserData* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESpatial\u002ESetRotation(
    [In] Spatial* obj0,
    [In] D3DXMATRIX* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXMATRIX* D3DXMatrixRotationZ([In] D3DXMATRIX* obj0, [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EMesh\u002ESetModel(
    [In] Mesh* obj0,
    [In] Model* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe Mesh* FableMod\u002EGfx\u002EMesh\u002E\u007Bctor\u007D([In] Mesh* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ED3DXModel\u002EBuild(
    [In] D3DXModel* obj0,
    [In] ID3DXMesh* obj1,
    [In] D3DXModel.SMaterial* obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXModel* FableMod\u002EGfx\u002ED3DXModel\u002E\u007Bctor\u007D(
    [In] D3DXModel* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe Node* FableMod\u002EGfx\u002ENode\u002E\u007Bctor\u007D([In] Node* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* FableMod\u002EGfx\u002EException\u002EGetMsg([In] FableMod.Gfx.Exception* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void __CxxUnregisterExceptionObject([In] void* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern int __CxxQueryExceptionSize();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int __CxxDetectRethrow([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int __CxxRegisterExceptionObject([In] void* obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int __CxxExceptionFilter(
    [In] void* obj0,
    [In] void* obj1,
    [In] int obj2,
    [In] void* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ED3DXModel\u002ELoad(
    [In] D3DXModel* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ERootObject\u002ESetName(
    [In] RootObject* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EOctTreeNode\u002EBuild(
    [In] OctTreeNode* obj0,
    [In] D3DXVECTOR3* obj1,
    [In] D3DXVECTOR3* obj2,
    [In] D3DXVECTOR3* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe OctTree* FableMod\u002EGfx\u002EOctTree\u002E\u007Bctor\u007D(
    [In] OctTree* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe Settings* FableMod\u002EGfx\u002ESettings\u002EGetInstance();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FableMod\u002EGfx\u002ESettings\u002EGetInt(
    [In] Settings* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TerrainManager* FableMod\u002EGfx\u002ETerrainManager\u002EGetInstance();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ETerrainManager\u002ERemoveAll(
    [In] TerrainManager* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern uint FableMod\u002EGfx\u002ERootObject\u002EGetNumObjects();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECamera\u002ERefresh([In] Camera* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe LogFile* FableMod\u002ELogFile\u002EGetInstance();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002ELogFile\u002EOpen([In] LogFile* obj0, [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EManager\u002ESetDirectory([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void FableMod\u002EGfx\u002EManager\u002EDispose();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXSaveSurfaceToFileW(
    [In] char* obj0,
    [In] _D3DXIMAGE_FILEFORMAT obj1,
    [In] IDirect3DSurface9* obj2,
    [In] tagPALETTEENTRY* obj3,
    [In] tagRECT* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EDevice\u002EUnlock([In] Device* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EDevice\u002ELock([In] Device* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EManager\u002EInitialize(
    [In] HWND__* obj0,
    [In] uint obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* memmove([In] void* obj0, [In] void* obj1, [In] ulong obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] exception* obj0,
    [In] exception* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] exception* obj0,
    [In] sbyte** obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void std\u002Eexception\u002E\u007Bdtor\u007D([In] exception* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern float floorf([In] float obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void std\u002E_Xlength_error([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void std\u002E_Container_base0\u002E_Orphan_all(
    [In] _Container_base0* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void _CxxThrowException([In] void* obj0, [In] _s__ThrowInfo* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int strncmp([In] sbyte* obj0, [In] sbyte* obj1, [In] ulong obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXVECTOR4* D3DXVec4Transform(
    [In] D3DXVECTOR4* obj0,
    [In] D3DXVECTOR4* obj1,
    [In] D3DXMATRIX* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe _D3DXFRAME* D3DXFrameFind([In] _D3DXFRAME* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXLoadMeshHierarchyFromXW(
    [In] char* obj0,
    [In] uint obj1,
    [In] IDirect3DDevice9* obj2,
    [In] ID3DXAllocateHierarchy* obj3,
    [In] ID3DXLoadUserData* obj4,
    [In] _D3DXFRAME** obj5,
    [In] ID3DXAnimationController** obj6);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXCreateSkinInfoFVF(
    [In] uint obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] ID3DXSkinInfo** obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXCreateMeshFVF(
    [In] uint obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] uint obj3,
    [In] IDirect3DDevice9* obj4,
    [In] ID3DXMesh** obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXFrameAppendChild([In] _D3DXFRAME* obj0, [In] _D3DXFRAME* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe Spatial* FableMod\u002EGfx\u002ENode\u002EGetChildAt(
    [In] Node* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FableMod\u002EGfx\u002ENode\u002ENumChildren([In] Node* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* __RTDynamicCast(
    [In] void* obj0,
    [In] int obj1,
    [In] void* obj2,
    [In] void* obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXMATRIX* D3DXMatrixTranslation(
    [In] D3DXMATRIX* obj0,
    [In] float obj1,
    [In] float obj2,
    [In] float obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXCreateSphere(
    [In] IDirect3DDevice9* obj0,
    [In] float obj1,
    [In] uint obj2,
    [In] uint obj3,
    [In] ID3DXMesh** obj4,
    [In] ID3DXBuffer** obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int sprintf([In] sbyte* obj0, [In] sbyte* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EDevice\u002EPresent(
    [In] Device* obj0,
    [In] HWND__* obj1,
    [In] tagRECT* obj2,
    [In] tagRECT* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EDevice\u002EEndScene([In] Device* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXMATRIX* D3DXMatrixScaling(
    [In] D3DXMATRIX* obj0,
    [In] float obj1,
    [In] float obj2,
    [In] float obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EDevice\u002EClearBuffers(
    [In] Device* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FableMod\u002EGfx\u002EDevice\u002EBeginScene([In] Device* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXSaveTextureToFileInMemory(
    [In] ID3DXBuffer** obj0,
    [In] _D3DXIMAGE_FILEFORMAT obj1,
    [In] IDirect3DBaseTexture9* obj2,
    [In] tagPALETTEENTRY* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXSaveTextureToFileW(
    [In] char* obj0,
    [In] _D3DXIMAGE_FILEFORMAT obj1,
    [In] IDirect3DBaseTexture9* obj2,
    [In] tagPALETTEENTRY* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXCreateTextureFromFileInMemoryEx(
    [In] IDirect3DDevice9* obj0,
    [In] void* obj1,
    [In] uint obj2,
    [In] uint obj3,
    [In] uint obj4,
    [In] uint obj5,
    [In] uint obj6,
    [In] _D3DFORMAT obj7,
    [In] _D3DPOOL obj8,
    [In] uint obj9,
    [In] uint obj10,
    [In] uint obj11,
    [In] _D3DXIMAGE_INFO* obj12,
    [In] tagPALETTEENTRY* obj13,
    [In] IDirect3DTexture9** obj14);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ETexture\u002ESetD3DTexture(
    [In] Texture* obj0,
    [In] IDirect3DTexture9* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ETexture\u002ESetAlphaRequired(
    [In] Texture* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe Texture* FableMod\u002EGfx\u002ETexture\u002E\u007Bctor\u007D(
    [In] Texture* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXCreateSprite([In] IDirect3DDevice9* obj0, [In] ID3DXSprite** obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXCreateTextureFromFileInMemory(
    [In] IDirect3DDevice9* obj0,
    [In] void* obj1,
    [In] uint obj2,
    [In] IDirect3DTexture9** obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXVECTOR3* FableMod\u002EGfx\u002ESpatial\u002EGetWorldUp(
    [In] Spatial* obj0,
    [In] D3DXVECTOR3* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXVECTOR3* FableMod\u002EGfx\u002ESpatial\u002EGetWorldForward(
    [In] Spatial* obj0,
    [In] D3DXVECTOR3* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESpatial\u002ESetWorldDirection(
    [In] Spatial* obj0,
    [In] D3DXVECTOR3* obj1,
    [In] D3DXVECTOR3* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESpatial\u002ESetWorldTranslation(
    [In] Spatial* obj0,
    [In] D3DXVECTOR3* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ED3DXModel\u002EBuildSphere(
    [In] D3DXModel* obj0,
    [In] float obj1,
    [In] D3DXCOLOR obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern uint FableMod\u002EGfx\u002ESpatial\u002EGetNextID();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ImpostorNode* FableMod\u002EGfx\u002EImpostorNode\u002E\u007Bctor\u007D(
    [In] ImpostorNode* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXMATRIX* D3DXMatrixRotationQuaternion(
    [In] D3DXMATRIX* obj0,
    [In] D3DXQUATERNION* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXQUATERNION* D3DXQuaternionMultiply(
    [In] D3DXQUATERNION* obj0,
    [In] D3DXQUATERNION* obj1,
    [In] D3DXQUATERNION* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXVECTOR3* D3DXVec3TransformCoord(
    [In] D3DXVECTOR3* obj0,
    [In] D3DXVECTOR3* obj1,
    [In] D3DXMATRIX* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXQUATERNION* D3DXQuaternionRotationMatrix(
    [In] D3DXQUATERNION* obj0,
    [In] D3DXMATRIX* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESpatial\u002EDetach([In] Spatial* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECameraController\u002EOnMouseMove(
    [In] CameraController* obj0,
    [In] D3DXVECTOR2* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESelectionBox\u002ESetCenter(
    [In] SelectionBox* obj0,
    [In] D3DXVECTOR3* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESelectionBox\u002EAddRotation(
    [In] SelectionBox* obj0,
    [In] D3DXMATRIX* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXQUATERNION* D3DXQuaternionRotationYawPitchRoll(
    [In] D3DXQUATERNION* obj0,
    [In] float obj1,
    [In] float obj2,
    [In] float obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FableMod\u002EGfx\u002ESelectionBox\u002EHasObject(
    [In] SelectionBox* obj0,
    [In] Spatial* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESelectionBox\u002EStartRotation(
    [In] SelectionBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FableMod\u002EGfx\u002ESelectionBox\u002EHasEnabled(
    [In] SelectionBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESelectionBox\u002EEnableAt(
    [In] SelectionBox* obj0,
    [In] int obj1,
    [MarshalAs(UnmanagedType.U1)] bool _param2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESelectionBox\u002EClear(
    [In] SelectionBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESelectionBox\u002EStopRotation(
    [In] SelectionBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FableMod\u002EGfx\u002ETerrainManager\u002EGetHeight(
    [In] TerrainManager* obj0,
    [In] D3DXVECTOR2* obj1,
    [In] float* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int _swprintf([In] char* obj0, [In] char* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FableMod\u002EGfx\u002ECamera\u002EGetRenderCount([In] Camera* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EDevice\u002EDrawTextW(
    [In] Device* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] char* obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXVECTOR3* FableMod\u002EGfx\u002EAxisBox\u002EGetMin(
    [In] AxisBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXVECTOR3* FableMod\u002EGfx\u002EAxisBox\u002EGetMax(
    [In] AxisBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EDevice\u002EDrawBox(
    [In] Device* obj0,
    [In] D3DXVECTOR3* obj1,
    [In] D3DXVECTOR3* obj2,
    [In] uint* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXVECTOR3* FableMod\u002EGfx\u002ESpatial\u002EGetWorldRight(
    [In] Spatial* obj0,
    [In] D3DXVECTOR3* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe Spatial* FableMod\u002EGfx\u002ESelectionBox\u002EGetObjectAt(
    [In] SelectionBox* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FableMod\u002EGfx\u002ESelectionBox\u002EGetNumObjects(
    [In] SelectionBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FableMod\u002EGfx\u002ESelectionBox\u002EIsEmpty(
    [In] SelectionBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EEditableTexture\u002EUnlock(
    [In] EditableTexture* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EEditableTexture\u002EDrawFilledCircle(
    [In] EditableTexture* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] int obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EEditableTexture\u002EDrawThickLine(
    [In] EditableTexture* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4,
    [In] uint obj5,
    [In] int obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EEditableTexture\u002ELock(
    [In] EditableTexture* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FableMod\u002EGfx\u002ETerrain\u002EGetLocation(
    [In] Terrain* obj0,
    [In] D3DXVECTOR3* obj1,
    [In] D3DXVECTOR3* obj2,
    [In] uint obj3,
    [In] uint obj4,
    [In] uint* obj5,
    [In] uint* obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FableMod\u002EGfx\u002ECamera\u002EScreenToRay(
    [In] Camera* obj0,
    [In] D3DXVECTOR2* obj1,
    [In] D3DXVECTOR3* obj2,
    [In] D3DXVECTOR3* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe EditableTexture* FableMod\u002EGfx\u002EEditableTexture\u002EDuplicate(
    [In] EditableTexture* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EEditableTexture\u002ECopyTo(
    [In] EditableTexture* obj0,
    [In] EditableTexture* obj1,
    [In] tagRECT* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECamera\u002ESetDistanceToCamera(
    [In] Camera* obj0,
    [In] Mesh* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EDevice\u002EDrawLine(
    [In] Device* obj0,
    [In] D3DXVECTOR3* obj1,
    [In] D3DXVECTOR3* obj2,
    [In] uint* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FableMod\u002EGfx\u002ESelectionBox\u002EGetRadius(
    [In] SelectionBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FableMod\u002EGfx\u002EAxisBox\u002EGetDepth([In] AxisBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FableMod\u002EGfx\u002EAxisBox\u002EGetHeight([In] AxisBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FableMod\u002EGfx\u002EAxisBox\u002EGetWidth([In] AxisBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXVECTOR3* FableMod\u002EGfx\u002EAxisBox\u002EGetCenter(
    [In] AxisBox* obj0,
    [In] D3DXVECTOR3* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe D3DXVECTOR3* D3DXVec3Normalize([In] D3DXVECTOR3* obj0, [In] D3DXVECTOR3* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESelectionBox\u002EAdd(
    [In] SelectionBox* obj0,
    [In] Spatial* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESelectionBox\u002EUpdate(
    [In] SelectionBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe Plane* FableMod\u002EGfx\u002EPlane\u002E\u007Bctor\u007D(
    [In] Plane* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EArrowheadModel\u002ESetColor(
    [In] ArrowheadModel* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ArrowheadModel* FableMod\u002EGfx\u002EArrowheadModel\u002E\u007Bctor\u007D(
    [In] ArrowheadModel* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ESpatial\u002ESetRotation(
    [In] Spatial* obj0,
    [In] D3DXVECTOR3* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe SelectionBox* FableMod\u002EGfx\u002ESelectionBox\u002E\u007Bctor\u007D(
    [In] SelectionBox* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FableMod\u002EGfx\u002ETexture\u002EGetHeight(
    [In] Texture* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FableMod\u002EGfx\u002ETexture\u002EGetWidth(
    [In] Texture* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECameraController\u002EOnZoom(
    [In] CameraController* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECameraController\u002EOnUp(
    [In] CameraController* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECameraController\u002EOnLookDown(
    [In] CameraController* obj0,
    [In] D3DXVECTOR2* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECameraController\u002EOnRotateDown(
    [In] CameraController* obj0,
    [In] D3DXVECTOR2* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECameraController\u002EOnMoveDown(
    [In] CameraController* obj0,
    [In] D3DXVECTOR2* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FableMod\u002EGfx\u002ECamera\u002EScreenToWorld(
    [In] Camera* obj0,
    [In] D3DXVECTOR2* obj1,
    [In] float obj2,
    [In] D3DXVECTOR3* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECamera\u002ERenderScene(
    [In] Camera* obj0,
    [In] Spatial* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECamera\u002EUpdate([In] Camera* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECameraController\u002ESetup(
    [In] CameraController* obj0,
    [In] Camera* obj1,
    [In] int obj2,
    [In] int obj3,
    [MarshalAs(UnmanagedType.U1)] bool _param4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FableMod\u002EGfx\u002EDevice\u002EReset([In] Device* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void Sleep([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe Device.EDeviceState FableMod\u002EGfx\u002EDevice\u002ECheckState(
    [In] Device* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECamera\u002ESetViewport(
    [In] Camera* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe CameraController* FableMod\u002EGfx\u002ECameraController\u002E\u007Bctor\u007D(
    [In] CameraController* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe Camera* FableMod\u002EGfx\u002ECamera\u002E\u007Bctor\u007D(
    [In] Camera* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern float tanf([In] float obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ECameraController\u002EUpdate(
    [In] CameraController* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FableMod\u002EGfx\u002ETerrain\u002EIsOver(
    [In] Terrain* obj0,
    [In] D3DXVECTOR3* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EException\u002E\u007Bdtor\u007D(
    [In] FableMod.Gfx.Exception* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FableMod.Gfx.Exception* FableMod\u002EGfx\u002EException\u002E\u007Bctor\u007D(
    [In] FableMod.Gfx.Exception* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002ELogFile\u002EWrite([In] LogFile* obj0, [In] char* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe _D3DFORMAT FableMod\u002EGfx\u002ETexture\u002EGetFormat(
    [In] Texture* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int D3DXCreateRenderToSurface(
    [In] IDirect3DDevice9* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] _D3DFORMAT obj3,
    [In] int obj4,
    [In] _D3DFORMAT obj5,
    [In] ID3DXRenderToSurface** obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern byte FableMod\u002EGfx\u002ETerrain\u002EGetTextureMultiplier();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002EEditableTexture\u002EDrawRawPixel(
    [In] EditableTexture* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ETerrain\u002ESetTextureSpacing(
    [In] Terrain* obj0,
    [In] byte obj1,
    [In] D3DXVECTOR2* obj2,
    [In] EditableTexture* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FableMod\u002EGfx\u002ETerrain\u002EGetTextureSize(
    [In] Terrain* obj0,
    [In] byte obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ETexture\u002ECreate(
    [In] Texture* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] uint obj3,
    [MarshalAs(UnmanagedType.U1)] bool _param4,
    [MarshalAs(UnmanagedType.U1)] bool _param5);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe EditableTexture* FableMod\u002EGfx\u002EEditableTexture\u002E\u007Bctor\u007D(
    [In] EditableTexture* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ETerrain\u002ESetTexture(
    [In] Terrain* obj0,
    [In] uint obj1,
    [In] EditableTexture* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FableMod\u002EGfx\u002EEditableTexture\u002EGetRawPixel(
    [In] EditableTexture* obj0,
    [In] int obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FableMod\u002EGfx\u002ESettings\u002EGetFloat(
    [In] Settings* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] float obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FableMod\u002EGfx\u002ETerrain\u002ECreate(
    [In] Terrain* obj0,
    [In] float* obj1,
    [In] uint obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe Terrain* FableMod\u002EGfx\u002ETerrain\u002E\u007Bctor\u007D(
    [In] Terrain* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* _getFiberPtrId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void _amsg_exit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void __security_init_cookie();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void _cexit();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void terminate();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int __FrameUnwindFilter([In] _EXCEPTION_POINTERS* obj0);
}
